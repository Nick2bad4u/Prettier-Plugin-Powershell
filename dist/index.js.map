{"version":3,"sources":["../src/options.ts","../src/tokenizer.ts","../src/parser.ts","../src/printer.ts","../src/index.ts"],"names":["currentSegment"],"mappings":"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","file":"index.js","sourcesContent":["import type { ParserOptions, SupportOptions } from \"prettier\";\n\nexport type TrailingCommaOption = \"none\" | \"multiline\" | \"all\";\nexport type IndentStyleOption = \"spaces\" | \"tabs\";\nexport type BraceStyleOption = \"1tbs\" | \"allman\";\nexport type KeywordCaseOption = \"preserve\" | \"lower\" | \"upper\" | \"pascal\";\n\nexport interface PluginConfiguration {\n    powershellIndentStyle: IndentStyleOption;\n    powershellIndentSize: number;\n    powershellTrailingComma: TrailingCommaOption;\n    powershellSortHashtableKeys: boolean;\n    powershellBlankLinesBetweenFunctions: number;\n    powershellBlankLineAfterParam: boolean;\n    powershellBraceStyle: BraceStyleOption;\n    powershellLineWidth: number;\n    powershellPreferSingleQuote: boolean;\n    powershellKeywordCase: KeywordCaseOption;\n    powershellRewriteAliases: boolean;\n    powershellRewriteWriteHost: boolean;\n}\n\nexport const pluginOptions: SupportOptions = {\n    powershellIndentStyle: {\n        category: \"PowerShell\",\n        type: \"choice\",\n        default: \"spaces\",\n        description: \"Indent PowerShell code using spaces or tabs.\",\n        choices: [\n            { value: \"spaces\", description: \"Use spaces for indentation.\" },\n            { value: \"tabs\", description: \"Use tabs for indentation.\" },\n        ],\n    },\n    powershellIndentSize: {\n        category: \"PowerShell\",\n        type: \"int\",\n        default: 2,\n        description: \"Number of indentation characters for each level.\",\n        range: { start: 1, end: 8, step: 1 },\n    },\n    powershellTrailingComma: {\n        category: \"PowerShell\",\n        type: \"choice\",\n        default: \"multiline\",\n        description:\n            \"Control trailing commas for array and hashtable literals.\",\n        choices: [\n            {\n                value: \"none\",\n                description: \"Never add a trailing comma or semicolon.\",\n            },\n            {\n                value: \"multiline\",\n                description:\n                    \"Add trailing comma/semicolon when the literal spans multiple lines.\",\n            },\n            {\n                value: \"all\",\n                description:\n                    \"Always add trailing comma/semicolon when possible.\",\n            },\n        ],\n    },\n    powershellSortHashtableKeys: {\n        category: \"PowerShell\",\n        type: \"boolean\",\n        default: false,\n        description: \"Sort hashtable keys alphabetically when formatting.\",\n    },\n    powershellBlankLinesBetweenFunctions: {\n        category: \"PowerShell\",\n        type: \"int\",\n        default: 1,\n        description:\n            \"Number of blank lines to ensure between function declarations.\",\n        range: { start: 0, end: 3, step: 1 },\n    },\n    powershellBlankLineAfterParam: {\n        category: \"PowerShell\",\n        type: \"boolean\",\n        default: true,\n        description:\n            \"Insert a blank line after param(...) blocks inside script blocks.\",\n    },\n    powershellBraceStyle: {\n        category: \"PowerShell\",\n        type: \"choice\",\n        default: \"1tbs\",\n        description:\n            \"Control placement of opening braces for script blocks and functions.\",\n        choices: [\n            {\n                value: \"1tbs\",\n                description:\n                    \"One True Brace Style  keep opening braces on the same line.\",\n            },\n            {\n                value: \"allman\",\n                description:\n                    \"Allman style  place opening braces on the next line.\",\n            },\n        ],\n    },\n    powershellLineWidth: {\n        category: \"PowerShell\",\n        type: \"int\",\n        default: 120,\n        description: \"Maximum preferred line width for PowerShell documents.\",\n        range: { start: 40, end: 200, step: 1 },\n    },\n    powershellPreferSingleQuote: {\n        category: \"PowerShell\",\n        type: \"boolean\",\n        default: false,\n        description:\n            \"Prefer single-quoted strings when no interpolation is required.\",\n    },\n    powershellKeywordCase: {\n        category: \"PowerShell\",\n        type: \"choice\",\n        default: \"preserve\",\n        description: \"Normalise the casing of PowerShell keywords.\",\n        choices: [\n            {\n                value: \"preserve\",\n                description: \"Leave keyword casing unchanged.\",\n            },\n            { value: \"lower\", description: \"Convert keywords to lower-case.\" },\n            { value: \"upper\", description: \"Convert keywords to upper-case.\" },\n            {\n                value: \"pascal\",\n                description: \"Capitalise keywords (PascalCase).\",\n            },\n        ],\n    },\n    powershellRewriteAliases: {\n        category: \"PowerShell\",\n        type: \"boolean\",\n        default: false,\n        description: \"Rewrite common cmdlet aliases to their canonical names.\",\n    },\n    powershellRewriteWriteHost: {\n        category: \"PowerShell\",\n        type: \"boolean\",\n        default: false,\n        description:\n            \"Rewrite Write-Host invocations to Write-Output to discourage host-only output.\",\n    },\n};\n\nexport const defaultOptions = {\n    tabWidth: 2,\n};\n\nexport interface ResolvedOptions {\n    indentStyle: IndentStyleOption;\n    indentSize: number;\n    trailingComma: TrailingCommaOption;\n    sortHashtableKeys: boolean;\n    blankLinesBetweenFunctions: number;\n    blankLineAfterParam: boolean;\n    braceStyle: BraceStyleOption;\n    lineWidth: number;\n    preferSingleQuote: boolean;\n    keywordCase: KeywordCaseOption;\n    rewriteAliases: boolean;\n    rewriteWriteHost: boolean;\n}\n\n/**\n * Resolves PowerShell-specific options and normalizes Prettier options.\n *\n * Note: This function mutates the input `options` object by setting\n * `useTabs`, `tabWidth`, and `printWidth` to ensure consistency between\n * PowerShell-specific settings and Prettier's core settings.\n */\nexport function resolveOptions(options: ParserOptions): ResolvedOptions {\n    const indentStyle =\n        (options.powershellIndentStyle as IndentStyleOption | undefined) ??\n        \"spaces\";\n    const rawIndentOverride = options.powershellIndentSize;\n    const normalizedIndentOverride = Number(rawIndentOverride);\n    const normalizedTabWidth = Number(options.tabWidth);\n    const indentSize =\n        Number.isFinite(normalizedIndentOverride) &&\n        normalizedIndentOverride > 0\n            ? Math.floor(normalizedIndentOverride)\n            : Number.isFinite(normalizedTabWidth) && normalizedTabWidth > 0\n              ? Math.floor(normalizedTabWidth)\n              : 2;\n\n    if (indentStyle === \"tabs\") {\n        options.useTabs = true;\n    } else {\n        options.useTabs = false;\n    }\n    options.tabWidth = indentSize;\n\n    const trailingComma =\n        (options.powershellTrailingComma as TrailingCommaOption | undefined) ??\n        \"multiline\";\n    const sortHashtableKeys = Boolean(options.powershellSortHashtableKeys);\n    const rawBlankLines = Number(\n        options.powershellBlankLinesBetweenFunctions ?? 1\n    );\n    const normalizedBlankLines = Number.isFinite(rawBlankLines)\n        ? rawBlankLines\n        : 1;\n    const blankLinesBetweenFunctions = Math.max(\n        0,\n        Math.min(3, Math.floor(normalizedBlankLines))\n    );\n    let blankLineAfterParam = true;\n    /* c8 ignore next */\n    if (options.powershellBlankLineAfterParam === false) {\n        blankLineAfterParam = false;\n    }\n    const braceStyle =\n        (options.powershellBraceStyle as BraceStyleOption | undefined) ??\n        \"1tbs\";\n    const lineWidth = Math.max(\n        40,\n        Math.min(200, Number(options.powershellLineWidth ?? 120))\n    );\n    const preferSingleQuote = options.powershellPreferSingleQuote === true;\n    const keywordCase =\n        (options.powershellKeywordCase as KeywordCaseOption | undefined) ??\n        \"preserve\";\n    const rewriteAliases = options.powershellRewriteAliases === true;\n    const rewriteWriteHost = options.powershellRewriteWriteHost === true;\n\n    if (!options.printWidth || options.printWidth > lineWidth) {\n        options.printWidth = lineWidth;\n    }\n\n    return {\n        indentStyle,\n        indentSize,\n        trailingComma,\n        sortHashtableKeys,\n        blankLinesBetweenFunctions,\n        blankLineAfterParam,\n        braceStyle,\n        lineWidth,\n        preferSingleQuote,\n        keywordCase,\n        rewriteAliases,\n        rewriteWriteHost,\n    } satisfies ResolvedOptions;\n}\n","import type { HereStringNode } from \"./ast.js\";\r\n\r\nexport type TokenType =\r\n    | \"newline\"\r\n    | \"identifier\"\r\n    | \"keyword\"\r\n    | \"variable\"\r\n    | \"number\"\r\n    | \"string\"\r\n    | \"heredoc\"\r\n    | \"comment\"\r\n    | \"block-comment\"\r\n    | \"attribute\"\r\n    | \"punctuation\"\r\n    | \"operator\"\r\n    | \"unknown\";\r\n\r\nexport interface Token {\r\n    type: TokenType;\r\n    value: string;\r\n    start: number;\r\n    end: number;\r\n    quote?: \"single\" | \"double\";\r\n}\r\n\r\nconst KEYWORDS = new Set([\r\n    \"function\",\r\n    \"if\",\r\n    \"elseif\",\r\n    \"else\",\r\n    \"for\",\r\n    \"foreach\",\r\n    \"while\",\r\n    \"switch\",\r\n    \"try\",\r\n    \"catch\",\r\n    \"finally\",\r\n    \"param\",\r\n    \"class\",\r\n    \"enum\",\r\n    \"begin\",\r\n    \"process\",\r\n    \"end\",\r\n    \"dynamicparam\",\r\n    \"filter\",\r\n    \"workflow\",\r\n    \"configuration\",\r\n    \"inlinescript\",\r\n    \"parallel\",\r\n    \"sequence\",\r\n    \"break\",\r\n    \"continue\",\r\n    \"return\",\r\n    \"throw\",\r\n    \"exit\",\r\n    \"trap\",\r\n    \"data\",\r\n    \"do\",\r\n    \"until\",\r\n    \"default\",\r\n]);\r\n\r\n// PowerShell operators (case-insensitive)\r\nconst POWERSHELL_OPERATORS = new Set([\r\n    // Comparison operators\r\n    \"-eq\", \"-ne\", \"-gt\", \"-ge\", \"-lt\", \"-le\",\r\n    \"-like\", \"-notlike\", \"-match\", \"-notmatch\",\r\n    \"-contains\", \"-notcontains\", \"-in\", \"-notin\",\r\n    \"-is\", \"-isnot\",\r\n    // Case-sensitive variants\r\n    \"-ceq\", \"-cne\", \"-cgt\", \"-cge\", \"-clt\", \"-cle\",\r\n    \"-clike\", \"-cnotlike\", \"-cmatch\", \"-cnotmatch\",\r\n    \"-ccontains\", \"-cnotcontains\", \"-cin\", \"-cnotin\",\r\n    // Case-insensitive explicit variants\r\n    \"-ieq\", \"-ine\", \"-igt\", \"-ige\", \"-ilt\", \"-ile\",\r\n    \"-ilike\", \"-inotlike\", \"-imatch\", \"-inotmatch\",\r\n    \"-icontains\", \"-inotcontains\", \"-iin\", \"-inotin\",\r\n    // Logical operators\r\n    \"-and\", \"-or\", \"-xor\", \"-not\",\r\n    // Bitwise operators\r\n    \"-band\", \"-bor\", \"-bxor\", \"-bnot\", \"-shl\", \"-shr\",\r\n    // String operators\r\n    \"-split\", \"-join\", \"-replace\", \"-f\",\r\n    // Type operators\r\n    \"-as\",\r\n    // Other operators\r\n    \"-creplace\", \"-ireplace\", \"-csplit\", \"-isplit\",\r\n]);\r\n\r\nconst PUNCTUATION = new Set([\r\n    \"{\",\r\n    \"}\",\r\n    \"(\",\r\n    \")\",\r\n    \"[\",\r\n    \"]\",\r\n    \",\",\r\n    \";\",\r\n    \".\",\r\n    \":\",\r\n]);\r\n\r\n// Cached regex patterns for performance\r\n// These are defined at module level to avoid recreation in the tokenize loop\r\nconst WHITESPACE_PATTERN = /\\s/;\r\nconst IDENTIFIER_START_PATTERN = /[A-Za-z_]/;\r\nconst UNICODE_VAR_CHAR_PATTERN = /^[\\p{L}\\p{N}_:-]$/u;\r\nconst HEX_DIGIT_PATTERN = /[0-9A-Fa-f]/;\r\nconst BINARY_DIGIT_PATTERN = /[01]/;\r\nconst DECIMAL_DIGIT_PATTERN = /[0-9]/;\r\nconst NUMBER_SUFFIX_PATTERN = /[dDfFlL]/;\r\nconst UNICODE_IDENTIFIER_START_PATTERN = /[\\p{L}_]/u;\r\nconst UNICODE_IDENTIFIER_CHAR_PATTERN = /[\\p{L}\\p{N}_-]/u;\r\nconst UNICODE_IDENTIFIER_AFTER_DASH_PATTERN = /[-\\p{L}]/u;\r\n\r\n/**\r\n * Tokenizes PowerShell source code into an array of tokens.\r\n *\r\n * This is the first stage of parsing. It breaks the source into meaningful chunks:\r\n * - Keywords (if, function, class, etc.)\r\n * - Operators (-eq, -and, &&, ||, etc.)\r\n * - Variables ($var, $$, $global:name, etc.)\r\n * - Numbers (42, 0xFF, 1.5e10, 100MB, etc.)\r\n * - Strings (single, double, here-strings)\r\n * - Comments (# line, <# block #>)\r\n * - Punctuation ({, }, [, ], etc.)\r\n *\r\n * The tokenizer is designed to be resilient - it will tokenize even\r\n * malformed PowerShell to allow the formatter to work on incomplete code.\r\n *\r\n * @param source - The PowerShell source code to tokenize\r\n * @returns An array of tokens with type, value, and position information\r\n */\r\nexport function tokenize(source: string): Token[] {\r\n    const tokens: Token[] = [];\r\n    const length = source.length;\r\n    let index = 0;\r\n\r\n    const push = (token: Token) => {\r\n        tokens.push(token);\r\n    };\r\n\r\n    while (index < length) {\r\n        const char = source[index];\r\n        const start = index;\r\n\r\n        if (char === \"\\r\" || char === \"\\n\") {\r\n            if (char === \"\\r\" && source[index + 1] === \"\\n\") {\r\n                index += 2;\r\n                push({ type: \"newline\", value: \"\\r\\n\", start, end: index });\r\n            } else {\r\n                index += 1;\r\n                push({ type: \"newline\", value: \"\\n\", start, end: index });\r\n            }\r\n            continue;\r\n        }\r\n\r\n        if (char === \" \" || char === \"\\t\" || char === \"\\f\") {\r\n            index += 1;\r\n            continue;\r\n        }\r\n\r\n        if (char === \"<\" && index + 1 < length && source[index + 1] === \"#\") {\r\n            let scanIndex = index + 2;\r\n            while (scanIndex < length) {\r\n                if (\r\n                    scanIndex + 1 < length &&\r\n                    source[scanIndex] === \"#\" &&\r\n                    source[scanIndex + 1] === \">\"\r\n                ) {\r\n                    scanIndex += 2;\r\n                    break;\r\n                }\r\n                scanIndex += 1;\r\n            }\r\n            const end = scanIndex >= length ? length : scanIndex;\r\n            push({\r\n                type: \"block-comment\",\r\n                value: source.slice(start, end),\r\n                start,\r\n                end,\r\n            });\r\n            index = end;\r\n            continue;\r\n        }\r\n\r\n        if (char === \"#\") {\r\n            index += 1;\r\n            while (\r\n                index < length &&\r\n                source[index] !== \"\\r\" &&\r\n                source[index] !== \"\\n\"\r\n            ) {\r\n                index += 1;\r\n            }\r\n            push({\r\n                type: \"comment\",\r\n                value: source.slice(start + 1, index).trimEnd(),\r\n                start,\r\n                end: index,\r\n            });\r\n            continue;\r\n        }\r\n\r\n        if (char === \"[\") {\r\n            let lookahead = index + 1;\r\n            while (lookahead < length && WHITESPACE_PATTERN.test(source[lookahead])) {\r\n                lookahead += 1;\r\n            }\r\n            if (lookahead < length && IDENTIFIER_START_PATTERN.test(source[lookahead])) {\r\n                let depth = 1;\r\n                let scanIndex = index + 1;\r\n                while (scanIndex < length && depth > 0) {\r\n                    const current = source[scanIndex];\r\n                    if (current === \"'\" || current === '\"') {\r\n                        const quote = current;\r\n                        scanIndex += 1;\r\n                        while (scanIndex < length) {\r\n                            const currentChar = source[scanIndex];\r\n                            if (currentChar === \"`\") {\r\n                                // Only advance by 2 if there is a character after the backtick\r\n                                if (scanIndex + 1 < length) {\r\n                                    scanIndex += 2;\r\n                                } else {\r\n                                    // Backtick is the last character, advance by 1 and exit loop\r\n                                    scanIndex += 1;\r\n                                    break;\r\n                                }\r\n                                continue;\r\n                            }\r\n                            if (currentChar === quote) {\r\n                                scanIndex += 1;\r\n                                break;\r\n                            }\r\n                            scanIndex += 1;\r\n                        }\r\n                        continue;\r\n                    }\r\n                    if (current === \"[\") {\r\n                        depth += 1;\r\n                        scanIndex += 1;\r\n                        continue;\r\n                    }\r\n                    if (current === \"]\") {\r\n                        depth -= 1;\r\n                        scanIndex += 1;\r\n                        if (depth === 0) {\r\n                            break;\r\n                        }\r\n                        continue;\r\n                    }\r\n                    scanIndex += 1;\r\n                }\r\n                const attributeEnd = depth === 0 ? scanIndex : length;\r\n                push({\r\n                    type: \"attribute\",\r\n                    value: source.slice(start, attributeEnd),\r\n                    start,\r\n                    end: attributeEnd,\r\n                });\r\n                index = attributeEnd;\r\n                continue;\r\n            }\r\n        }\r\n\r\n        if (\r\n            char === \"@\" &&\r\n            (source[index + 1] === '\"' || source[index + 1] === \"'\")\r\n        ) {\r\n            const quoteChar = source[index + 1];\r\n            const quote = quoteChar === '\"' ? \"double\" : \"single\";\r\n            let scanIndex = index + 2;\r\n            let closing = -1;\r\n            while (scanIndex < length) {\r\n                if (\r\n                    scanIndex + 1 < length &&\r\n                    source[scanIndex] === quoteChar &&\r\n                    source[scanIndex + 1] === \"@\"\r\n                ) {\r\n                    const prevChar = source[scanIndex - 1];\r\n                    const prevPrev = source[scanIndex - 2];\r\n                    const atImmediateClosing = scanIndex === index + 2;\r\n                    const atUnixLineStart = prevChar === \"\\n\";\r\n                    const atWindowsLineStart =\r\n                        prevChar === \"\\n\" && prevPrev === \"\\r\";\r\n                    if (\r\n                        atImmediateClosing ||\r\n                        atUnixLineStart ||\r\n                        atWindowsLineStart\r\n                    ) {\r\n                        closing = scanIndex;\r\n                        break;\r\n                    }\r\n                }\r\n                scanIndex += 1;\r\n            }\r\n\r\n            let end = length;\r\n            /* c8 ignore next */\r\n            if (closing !== -1) {\r\n                end = closing + 2;\r\n            }\r\n\r\n            push({\r\n                type: \"heredoc\",\r\n                value: source.slice(index, end),\r\n                start,\r\n                end,\r\n                quote,\r\n            });\r\n            index = end;\r\n            continue;\r\n        }\r\n\r\n        if (char === \"'\" || char === '\"') {\r\n            const quote = char === '\"' ? \"double\" : \"single\";\r\n            index += 1;\r\n            let escaped = false;\r\n            while (index < length) {\r\n                const current = source[index];\r\n                if (escaped) {\r\n                    escaped = false;\r\n                } else if (current === \"`\") {\r\n                    escaped = true;\r\n                } else if (current === char) {\r\n                    index += 1;\r\n                    break;\r\n                }\r\n                index += 1;\r\n            }\r\n            push({\r\n                type: \"string\",\r\n                value: source.slice(start, index),\r\n                start,\r\n                end: index,\r\n                quote,\r\n            });\r\n            continue;\r\n        }\r\n\r\n        if (\r\n            char === \"@\" &&\r\n            (source[index + 1] === \"{\" || source[index + 1] === \"(\")\r\n        ) {\r\n            const value = `@${source[index + 1]}`;\r\n            index += 2;\r\n            push({ type: \"operator\", value, start, end: index });\r\n            continue;\r\n        }\r\n\r\n        if (char === \":\" && source[index + 1] === \":\") {\r\n            index += 2;\r\n            push({ type: \"operator\", value: \"::\", start, end: index });\r\n            continue;\r\n        }\r\n\r\n        if (PUNCTUATION.has(char)) {\r\n            index += 1;\r\n            push({ type: \"punctuation\", value: char, start, end: index });\r\n            continue;\r\n        }\r\n\r\n        if (char === \"|\" || char === \"=\") {\r\n            let value = char;\r\n            if (source[index + 1] === char) {\r\n                value += char;\r\n                index += 2;\r\n            } else {\r\n                index += 1;\r\n            }\r\n            push({ type: \"operator\", value, start, end: index });\r\n            continue;\r\n        }\r\n\r\n        // Pipeline chain operators: && and ||\r\n        if (char === \"&\" && source[index + 1] === \"&\") {\r\n            index += 2;\r\n            push({ type: \"operator\", value: \"&&\", start, end: index });\r\n            continue;\r\n        }\r\n\r\n        // Redirection operators: >, >>, <, 2>, 2>>, 3>, etc.\r\n        if (char === \">\" || char === \"<\") {\r\n            let value = char;\r\n            if (source[index + 1] === char) {\r\n                value += char;\r\n                index += 2;\r\n            } else {\r\n                index += 1;\r\n            }\r\n            push({ type: \"operator\", value, start, end: index });\r\n            continue;\r\n        }\r\n\r\n        // Stream redirection operators: 2>, 3>, 4>, 5>, 6>, *>\r\n        if (/[2-6*]/.test(char) && source[index + 1] === \">\") {\r\n            let value = char + \">\";\r\n            index += 2;\r\n            // Check for >> (append)\r\n            if (source[index] === \">\") {\r\n                value += \">\";\r\n                index += 1;\r\n            }\r\n            // Check for merging redirection: 2>&1, *>&2, etc.\r\n            if (source[index] === \"&\" && /[1-6]/.test(source[index + 1])) {\r\n                value += \"&\" + source[index + 1];\r\n                index += 2;\r\n            }\r\n            push({ type: \"operator\", value, start, end: index });\r\n            continue;\r\n        }\r\n\r\n        // Merging redirection for stream 1: 1>&2\r\n        if (char === \"1\" && source[index + 1] === \">\" && source[index + 2] === \"&\" && /[2-6]/.test(source[index + 3])) {\r\n            const value = \"1>&\" + source[index + 3];\r\n            index += 4;\r\n            push({ type: \"operator\", value, start, end: index });\r\n            continue;\r\n        }\r\n\r\n        if (char === \"$\") {\r\n            index += 1;\r\n\r\n            // Special variables: $$, $^, $?, $_\r\n            if (index < length) {\r\n                const nextChar = source[index];\r\n                if (nextChar === \"$\" || nextChar === \"^\" || nextChar === \"?\" || nextChar === \"_\") {\r\n                    index += 1;\r\n                    push({\r\n                        type: \"variable\",\r\n                        value: source.slice(start, index),\r\n                        start,\r\n                        end: index,\r\n                    });\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            while (index < length) {\r\n                const currentChar = source[index];\r\n                // PowerShell supports Unicode variable names\r\n                // Match Unicode letters, numbers, underscore, colon, and hyphen\r\n                if (UNICODE_VAR_CHAR_PATTERN.test(currentChar)) {\r\n                    index += 1;\r\n                    continue;\r\n                }\r\n                if (currentChar === \"{\") {\r\n                    index += 1;\r\n                    while (index < length && source[index] !== \"}\") {\r\n                        index += 1;\r\n                    }\r\n                    if (source[index] === \"}\") {\r\n                        index += 1;\r\n                    }\r\n                    continue;\r\n                }\r\n                break;\r\n            }\r\n            push({\r\n                type: \"variable\",\r\n                value: source.slice(start, index),\r\n                start,\r\n                end: index,\r\n            });\r\n            continue;\r\n        }\r\n\r\n        if (/[0-9]/.test(char)) {\r\n            index += 1;\r\n\r\n            // Check for hex number (0x...)\r\n            if (\r\n                char === \"0\" &&\r\n                index < length &&\r\n                (source[index] === \"x\" || source[index] === \"X\")\r\n            ) {\r\n                index += 1; // consume 'x' or 'X'\r\n                while (index < length && HEX_DIGIT_PATTERN.test(source[index])) {\r\n                    index += 1;\r\n                }\r\n                // Check for long suffix (L or l)\r\n                if (index < length && (source[index] === \"L\" || source[index] === \"l\")) {\r\n                    index += 1;\r\n                }\r\n                // Check for multiplier suffixes (KB, MB, GB, TB, PB)\r\n                if (index + 1 < length) {\r\n                    const suffix = source.slice(index, index + 2).toUpperCase();\r\n                    if ([\"KB\", \"MB\", \"GB\", \"TB\", \"PB\"].includes(suffix)) {\r\n                        index += 2;\r\n                    }\r\n                }\r\n                push({\r\n                    type: \"number\",\r\n                    value: source.slice(start, index),\r\n                    start,\r\n                    end: index,\r\n                });\r\n                continue;\r\n            }\r\n\r\n            // Check for binary number (0b...)\r\n            if (\r\n                char === \"0\" &&\r\n                index < length &&\r\n                (source[index] === \"b\" || source[index] === \"B\")\r\n            ) {\r\n                index += 1; // consume 'b' or 'B'\r\n                while (index < length && BINARY_DIGIT_PATTERN.test(source[index])) {\r\n                    index += 1;\r\n                }\r\n                push({\r\n                    type: \"number\",\r\n                    value: source.slice(start, index),\r\n                    start,\r\n                    end: index,\r\n                });\r\n                continue;\r\n            }\r\n\r\n            // Regular decimal number\r\n            while (index < length && DECIMAL_DIGIT_PATTERN.test(source[index])) {\r\n                index += 1;\r\n            }\r\n\r\n            // Check for decimal point\r\n            if (index + 1 < length && source[index] === \".\" && DECIMAL_DIGIT_PATTERN.test(source[index + 1])) {\r\n                index += 2;\r\n                while (index < length && DECIMAL_DIGIT_PATTERN.test(source[index])) {\r\n                    index += 1;\r\n                }\r\n            }\r\n\r\n            // Check for scientific notation (e or E)\r\n            if (index < length && (source[index] === \"e\" || source[index] === \"E\")) {\r\n                index += 1;\r\n                // Optional sign\r\n                if (index < length && (source[index] === \"+\" || source[index] === \"-\")) {\r\n                    index += 1;\r\n                }\r\n                // Exponent digits\r\n                while (index < length && DECIMAL_DIGIT_PATTERN.test(source[index])) {\r\n                    index += 1;\r\n                }\r\n            }\r\n\r\n            // Check for type suffixes (d/D for decimal, f/F for float, l/L for long)\r\n            if (index < length && NUMBER_SUFFIX_PATTERN.test(source[index])) {\r\n                index += 1;\r\n            }\r\n\r\n            // Check for multiplier suffixes (KB, MB, GB, TB, PB)\r\n            if (index + 1 < length) {\r\n                const suffix = source.slice(index, index + 2).toUpperCase();\r\n                if ([\"KB\", \"MB\", \"GB\", \"TB\", \"PB\"].includes(suffix)) {\r\n                    index += 2;\r\n                }\r\n            }\r\n\r\n            push({\r\n                type: \"number\",\r\n                value: source.slice(start, index),\r\n                start,\r\n                end: index,\r\n            });\r\n            continue;\r\n        }\r\n\r\n        // Stop parsing token: --%\r\n        if (char === \"-\" && source.slice(index, index + 3) === \"--%\") {\r\n            // Consume everything until end of line as the stop parsing argument\r\n            let endIndex = index + 3;\r\n            while (endIndex < length && source[endIndex] !== \"\\n\" && source[endIndex] !== \"\\r\") {\r\n                endIndex += 1;\r\n            }\r\n            push({\r\n                type: \"operator\",\r\n                value: source.slice(start, endIndex),\r\n                start,\r\n                end: endIndex,\r\n            });\r\n            index = endIndex;\r\n            continue;\r\n        }\r\n\r\n        if (\r\n            UNICODE_IDENTIFIER_START_PATTERN.test(char) ||\r\n            (char === \"-\" &&\r\n                index + 1 < length &&\r\n                UNICODE_IDENTIFIER_AFTER_DASH_PATTERN.test(source[index + 1]))\r\n        ) {\r\n            index += 1;\r\n            while (index < length && UNICODE_IDENTIFIER_CHAR_PATTERN.test(source[index])) {\r\n                index += 1;\r\n            }\r\n            const raw = source.slice(start, index);\r\n            const lower = raw.toLowerCase();\r\n            if (KEYWORDS.has(lower)) {\r\n                push({ type: \"keyword\", value: raw, start, end: index });\r\n            } else if (POWERSHELL_OPERATORS.has(lower)) {\r\n                push({ type: \"operator\", value: raw, start, end: index });\r\n            } else {\r\n                push({ type: \"identifier\", value: raw, start, end: index });\r\n            }\r\n            continue;\r\n        }\r\n\r\n        // fallback single character token\r\n        index += 1;\r\n        push({ type: \"unknown\", value: char, start, end: index });\r\n    }\r\n\r\n    return tokens;\r\n}\r\n\r\n/**\r\n * Normalizes a here-string by removing the opening and closing delimiters.\r\n *\r\n * PowerShell here-strings have the format:\r\n * @\"\r\n * content\r\n * \"@\r\n *\r\n * or\r\n *\r\n * @'\r\n * content\r\n * '@\r\n *\r\n * This function extracts just the content between the delimiters.\r\n * If the here-string is too short (malformed), returns it as-is.\r\n *\r\n * @param node - The here-string AST node\r\n * @returns The normalized content without delimiters\r\n */\r\nexport function normalizeHereString(node: HereStringNode): string {\r\n    const lines = node.value.split(/\\r?\\n/);\r\n    if (lines.length <= 2) {\r\n        return node.value;\r\n    }\r\n    return lines.slice(1, -1).join(\"\\n\");\r\n}\r\n","import type { ParserOptions } from \"prettier\";\n\nimport type {\n    ArrayLiteralNode,\n    BlankLineNode,\n    CommentNode,\n    ExpressionNode,\n    ExpressionPartNode,\n    FunctionDeclarationNode,\n    HashtableEntryNode,\n    HashtableNode,\n    HereStringNode,\n    ParenthesisNode,\n    PipelineNode,\n    ScriptBlockNode,\n    ScriptBodyNode,\n    ScriptNode,\n    SourceLocation,\n    TextNode,\n    TokenRole,\n} from \"./ast.js\";\nimport { resolveOptions } from \"./options.js\";\nimport type { Token } from \"./tokenizer.js\";\nimport { tokenize } from \"./tokenizer.js\";\n\nconst FALLBACK_OPERATOR_TOKENS = new Set([\n    \"+\",\n    \"-\",\n    \"*\",\n    \"/\",\n    \"%\",\n    \"&\",\n    \"|\",\n    \"^\",\n    \"!\",\n    \"?\",\n    \"++\",\n    \"--\",\n    \"+=\",\n    \"-=\",\n    \"*=\",\n    \"/=\",\n    \"%=\",\n    \"&=\",\n    \"|=\",\n    \"^=\",\n    \"??\",\n]);\n\nfunction extendNodeLocation(node: { loc: SourceLocation }, end: number): void {\n    if (end > node.loc.end) {\n        node.loc = { ...node.loc, end };\n    }\n}\n\nclass Parser {\n    private tokenIndex = 0;\n\n    constructor(\n        private readonly tokens: Token[],\n        private readonly source: string\n    ) {}\n\n    parseScript(terminators: Set<string> = new Set()): ScriptNode {\n        const body: ScriptBodyNode[] = [];\n        const start = this.tokens.length > 0 ? this.tokens[0].start : 0;\n\n        while (!this.isEOF()) {\n            const token = this.peek()!;\n\n            if (terminators.has(token.value) && token.type === \"punctuation\") {\n                break;\n            }\n\n            if (token.type === \"newline\") {\n                const blank = this.consumeBlankLines();\n                body.push(blank);\n                continue;\n            }\n\n            if (token.type === \"comment\" || token.type === \"block-comment\") {\n                const commentToken = this.advance();\n                const commentNode = this.createCommentNode(commentToken, false);\n                if (body.length > 0) {\n                    const previousNode = body[body.length - 1];\n                    let lookaheadOffset = 0;\n                    let nextToken: Token | undefined;\n                    while ((nextToken = this.peek(lookaheadOffset)) !== undefined) {\n                        if (nextToken.type === \"newline\") {\n                            lookaheadOffset += 1;\n                            continue;\n                        }\n                        break;\n                    }\n                    if (previousNode.type === \"Pipeline\") {\n                        const lastSegment =\n                            previousNode.segments[\n                                previousNode.segments.length - 1\n                            ];\n                        const lastPart =\n                            lastSegment?.parts[lastSegment.parts.length - 1];\n                        const belongsToBlock = Boolean(\n                            lastPart &&\n                                lastPart.type === \"ScriptBlock\" &&\n                                (commentNode.loc.start < lastPart.loc.end ||\n                                    (nextToken &&\n                                        nextToken.type === \"punctuation\" &&\n                                        nextToken.value === \"}\"))\n                        );\n                        if (\n                            belongsToBlock &&\n                            lastPart &&\n                            lastPart.type === \"ScriptBlock\" &&\n                            lastSegment\n                        ) {\n                            lastPart.body.push(commentNode);\n                            extendNodeLocation(lastPart, commentNode.loc.end);\n                            extendNodeLocation(\n                                lastSegment,\n                                commentNode.loc.end\n                            );\n                            extendNodeLocation(\n                                previousNode,\n                                commentNode.loc.end\n                            );\n                            continue;\n                        }\n                    }\n                }\n                body.push(commentNode);\n                continue;\n            }\n\n            if (this.isFunctionDeclaration()) {\n                body.push(this.parseFunction());\n                continue;\n            }\n\n            const statement = this.parseStatement();\n            if (statement) {\n                body.push(statement);\n            } else {\n                // avoid infinite loops\n                this.advance();\n            }\n        }\n\n        const end = body.length > 0 ? body[body.length - 1].loc.end : start;\n        return {\n            type: \"Script\",\n            body,\n            loc: { start, end },\n        } satisfies ScriptNode;\n    }\n\n    private parseFunction(): FunctionDeclarationNode {\n        const startToken = this.advance(); // function keyword\n        const headerTokens: Token[] = [startToken];\n\n        while (!this.isEOF()) {\n            const token = this.peek()!;\n            if (token.type === \"comment\") {\n                break;\n            }\n            if (token.type === \"punctuation\" && token.value === \"{\") {\n                break;\n            }\n            headerTokens.push(this.advance());\n        }\n\n        const headerExpression = buildExpressionFromTokens(\n            headerTokens,\n            this.source\n        );\n        const body = this.parseScriptBlock();\n        const end = body.loc.end;\n\n        return {\n            type: \"FunctionDeclaration\",\n            header: headerExpression,\n            body,\n            loc: { start: startToken.start, end },\n        } satisfies FunctionDeclarationNode;\n    }\n\n    private parseStatement(): PipelineNode | null {\n        const segments: Token[][] = [[]];\n        let trailingComment: CommentNode | undefined;\n\n        const structureStack: string[] = [];\n        let lineContinuation = false;\n\n        while (!this.isEOF()) {\n            const token = this.peek()!;\n\n            if (token.type === \"newline\") {\n                if (lineContinuation) {\n                    this.advance();\n                    lineContinuation = false;\n                    continue;\n                }\n                /* c8 ignore next */\n                if (structureStack.length > 0) {\n                    const newlineToken = this.advance();\n                    segments[segments.length - 1].push(newlineToken);\n                    continue;\n                }\n                if (\n                    structureStack.length === 0 &&\n                    this.isPipelineContinuationAfterNewline()\n                ) {\n                    this.advance();\n                    continue;\n                }\n                break;\n            }\n\n            if (\n                token.type === \"punctuation\" &&\n                token.value === \";\" &&\n                structureStack.length === 0\n            ) {\n                this.advance();\n                break;\n            }\n\n            if (\n                token.type === \"punctuation\" &&\n                token.value === \"}\" &&\n                structureStack.length === 0\n            ) {\n                break;\n            }\n\n            if (token.type === \"comment\") {\n                if (\n                    structureStack.length === 0 &&\n                    this.isInlineComment(token)\n                ) {\n                    trailingComment = this.createCommentNode(\n                        this.advance(),\n                        true\n                    );\n                }\n                if (structureStack.length === 0) {\n                    break;\n                }\n                // Inside a structure - include the comment as part of the statement\n                const currentSegment = segments[segments.length - 1];\n                currentSegment.push(this.advance());\n                continue;\n            }\n\n            if (token.type === \"block-comment\") {\n                if (structureStack.length === 0) {\n                    break;\n                }\n                // Inside a structure - include the block comment\n                const currentSegment = segments[segments.length - 1];\n                currentSegment.push(this.advance());\n                continue;\n            }\n\n            if (token.type === \"operator\" && token.value === \"|\") {\n                if (structureStack.length > 0) {\n                    const currentSegment = segments[segments.length - 1];\n                    currentSegment.push(this.advance());\n                    lineContinuation = false;\n                    continue;\n                }\n\n                this.advance();\n                segments.push([]);\n                lineContinuation = false;\n                continue;\n            }\n\n            /* c8 ignore next */\n            if (token.type === \"unknown\" && token.value === \"`\") {\n                this.advance();\n                lineContinuation = true;\n                continue;\n            }\n\n            const currentSegment = segments[segments.length - 1];\n            currentSegment.push(this.advance());\n            lineContinuation = false;\n\n            if (isOpeningToken(token)) {\n                structureStack.push(token.value);\n            } else if (isClosingToken(token)) {\n                structureStack.pop();\n            }\n        }\n\n        const filteredSegments = segments.filter(\n            (segment) => segment.length > 0\n        );\n        if (filteredSegments.length === 0) {\n            return null;\n        }\n\n        const expressionSegments = filteredSegments.map((segmentTokens) =>\n            buildExpressionFromTokens(segmentTokens, this.source)\n        );\n        const start = expressionSegments[0].loc.start;\n        const end = expressionSegments[expressionSegments.length - 1].loc.end;\n\n        const pipelineNode: PipelineNode = {\n            type: \"Pipeline\",\n            segments: expressionSegments,\n            loc: { start, end },\n        };\n\n        if (trailingComment) {\n            pipelineNode.trailingComment = trailingComment;\n        }\n\n        return pipelineNode;\n    }\n\n    private parseScriptBlock(): ScriptBlockNode {\n        const openToken = this.peek();\n        if (\n            !openToken ||\n            openToken.type !== \"punctuation\" ||\n            openToken.value !== \"{\"\n        ) {\n            return {\n                type: \"ScriptBlock\",\n                body: [],\n                loc: { start: openToken?.start ?? 0, end: openToken?.end ?? 0 },\n            } satisfies ScriptBlockNode;\n        }\n        this.advance();\n\n        const { contentTokens, closingToken } =\n            this.collectBalancedTokens(openToken);\n        const nestedParser = new Parser(contentTokens, this.source);\n        const script = nestedParser.parseScript(new Set());\n        const closingEnd = closingToken?.end ?? openToken.end;\n        const bodyEnd =\n            script.body.length > 0\n                ? script.body[script.body.length - 1].loc.end\n                : closingEnd;\n        const end = Math.max(closingEnd, bodyEnd);\n\n        return {\n            type: \"ScriptBlock\",\n            body: script.body,\n            loc: { start: openToken.start, end },\n        } satisfies ScriptBlockNode;\n    }\n\n    private collectBalancedTokens(startToken: Token): {\n        contentTokens: Token[];\n        closingToken?: Token;\n    } {\n        const contentTokens: Token[] = [];\n        const stack: string[] = [startToken.value];\n\n        while (!this.isEOF()) {\n            const token = this.advance();\n\n            if (isOpeningToken(token)) {\n                stack.push(token.value);\n                contentTokens.push(token);\n                continue;\n            }\n\n            if (isClosingToken(token)) {\n                if (stack.length <= 1) {\n                    return { contentTokens, closingToken: token };\n                }\n                stack.pop();\n                contentTokens.push(token);\n                continue;\n            }\n\n            contentTokens.push(token);\n        }\n\n        return { contentTokens };\n    }\n\n    private consumeBlankLines(): BlankLineNode {\n        let count = 0;\n        const start = this.peek()!.start;\n        let end = start;\n        while (!this.isEOF()) {\n            const token = this.peek();\n            if (!token || token.type !== \"newline\") {\n                break;\n            }\n            const current = this.advance();\n            count += 1;\n            end = current.end;\n        }\n        return {\n            type: \"BlankLine\",\n            count,\n            loc: { start, end },\n        } satisfies BlankLineNode;\n    }\n\n    private createCommentNode(token: Token, inline: boolean): CommentNode {\n        const style = token.type === \"block-comment\" ? \"block\" : \"line\";\n        const isInline =\n            style === \"line\" && inline && this.isInlineComment(token);\n\n        return {\n            type: \"Comment\",\n            value: token.value,\n            inline: isInline,\n            style,\n            loc: { start: token.start, end: token.end },\n        } satisfies CommentNode;\n    }\n\n    private isInlineComment(token: Token): boolean {\n        if (token.type !== \"comment\") {\n            return false;\n        }\n        // Empty source means no context, treat as not inline\n        if (this.source.length === 0) {\n            return false;\n        }\n        // Comment at position 0 is at the beginning, not inline\n        if (token.start === 0) {\n            return false;\n        }\n\n        let cursor = token.start - 1;\n        while (cursor >= 0) {\n            const char = this.source[cursor];\n            if (char === \"\\n\") {\n                return false;\n            }\n            if (char === \"\\r\") {\n                return false;\n            }\n            if (!/\\s/.test(char)) {\n                return true;\n            }\n            cursor -= 1;\n        }\n\n        return false;\n    }\n\n    /**\n     * Checks if there's a pipeline continuation (|) after newlines.\n     * This handles multi-line pipelines where the pipe operator appears\n     * on a subsequent line.\n     */\n    private isPipelineContinuationAfterNewline(): boolean {\n        let offset = 1;\n        let next: Token | undefined;\n        while ((next = this.peek(offset)) !== undefined) {\n            if (next.type === \"newline\") {\n                offset += 1;\n                continue;\n            }\n            if (next.type === \"comment\") {\n                return false;\n            }\n            if (next.type === \"operator\" && next.value === \"|\") {\n                return true;\n            }\n            return false;\n        }\n        return false;\n    }\n\n    private isFunctionDeclaration(): boolean {\n        const token = this.peek();\n        return Boolean(\n            token &&\n                token.type === \"keyword\" &&\n                token.value.toLowerCase() === \"function\"\n        );\n    }\n\n    private peek(offset = 0): Token | undefined {\n        return this.tokens[this.tokenIndex + offset];\n    }\n\n    private advance(): Token {\n        const token = this.tokens[this.tokenIndex];\n        this.tokenIndex += 1;\n        return token;\n    }\n\n    private isEOF(): boolean {\n        return this.tokenIndex >= this.tokens.length;\n    }\n}\n\nfunction isOpeningToken(token: Token): boolean {\n    if (token.type === \"operator\") {\n        return token.value === \"@{\" || token.value === \"@(\";\n    }\n    return (\n        token.type === \"punctuation\" &&\n        (token.value === \"{\" || token.value === \"(\" || token.value === \"[\")\n    );\n}\n\nfunction isClosingToken(token: Token): boolean {\n    return (\n        token.type === \"punctuation\" &&\n        (token.value === \"}\" || token.value === \")\" || token.value === \"]\")\n    );\n}\n\nfunction buildExpressionFromTokens(\n    tokens: Token[],\n    source: string = \"\"\n): ExpressionNode {\n    const firstToken = tokens.find((token) => token.type !== \"newline\");\n    const lastToken = [...tokens]\n        .reverse()\n        .find((token) => token.type !== \"newline\");\n    if (!firstToken || !lastToken) {\n        return {\n            type: \"Expression\",\n            parts: [],\n            loc: {\n                start: tokens[0]?.start ?? 0,\n                end: tokens[tokens.length - 1]?.end ?? 0,\n            },\n        } satisfies ExpressionNode;\n    }\n\n    const parts: ExpressionPartNode[] = [];\n    let index = 0;\n\n    while (index < tokens.length) {\n        const token = tokens[index];\n\n        if (token.type === \"newline\") {\n            index += 1;\n            continue;\n        }\n\n        if (token.type === \"operator\" && token.value === \"@{\") {\n            const { node, nextIndex } = parseHashtablePart(\n                tokens,\n                index,\n                source\n            );\n            parts.push(node);\n            index = nextIndex;\n            continue;\n        }\n\n        if (\n            (token.type === \"operator\" && token.value === \"@(\") ||\n            (token.type === \"punctuation\" && token.value === \"[\")\n        ) {\n            const { node, nextIndex } = parseArrayPart(tokens, index, source);\n            parts.push(node);\n            index = nextIndex;\n            continue;\n        }\n\n        if (token.type === \"punctuation\" && token.value === \"{\") {\n            const { node, nextIndex } = parseScriptBlockPart(\n                tokens,\n                index,\n                source\n            );\n            parts.push(node);\n            index = nextIndex;\n            continue;\n        }\n\n        if (token.type === \"punctuation\" && token.value === \"(\") {\n            const { node, nextIndex } = parseParenthesisPart(\n                tokens,\n                index,\n                source\n            );\n            parts.push(node);\n            index = nextIndex;\n            continue;\n        }\n\n        if (token.type === \"heredoc\") {\n            parts.push(createHereStringNode(token));\n            index += 1;\n            continue;\n        }\n\n        if (token.type === \"attribute\") {\n            parts.push(createTextNode(token));\n            index += 1;\n            continue;\n        }\n\n        parts.push(createTextNode(token));\n        index += 1;\n    }\n\n    const expressionEnd =\n        parts.length > 0 ? parts[parts.length - 1].loc.end : lastToken.end;\n\n    return {\n        type: \"Expression\",\n        parts,\n        loc: {\n            start: firstToken.start,\n            end: expressionEnd,\n        },\n    } satisfies ExpressionNode;\n}\n\nfunction parseHashtablePart(\n    tokens: Token[],\n    startIndex: number,\n    source: string = \"\"\n): { node: HashtableNode; nextIndex: number } {\n    const startToken = tokens[startIndex];\n    const { contentTokens, endIndex, closingToken } = collectStructureTokens(\n        tokens,\n        startIndex\n    );\n    const entries = splitHashtableEntries(contentTokens).map((entryTokens) =>\n        buildHashtableEntry(entryTokens, source)\n    );\n    const end =\n        closingToken?.end ??\n        contentTokens[contentTokens.length - 1]?.end ??\n        startToken.end;\n    return {\n        node: {\n            type: \"Hashtable\",\n            entries,\n            loc: { start: startToken.start, end },\n        },\n        nextIndex: endIndex,\n    };\n}\n\nfunction resolveStructureEnd(\n    startToken: Token,\n    closingToken: Token | undefined,\n    contentTokens: Token[]\n): number {\n    if (closingToken) {\n        return closingToken.end;\n    }\n    const lastContent =\n        contentTokens.length > 0\n            ? contentTokens[contentTokens.length - 1]\n            : undefined;\n    if (lastContent) {\n        return lastContent.end;\n    }\n    return startToken.end;\n}\n\nfunction parseArrayPart(\n    tokens: Token[],\n    startIndex: number,\n    source: string = \"\"\n): { node: ArrayLiteralNode; nextIndex: number } {\n    const startToken = tokens[startIndex];\n    const { contentTokens, endIndex, closingToken } = collectStructureTokens(\n        tokens,\n        startIndex\n    );\n    const elements = splitArrayElements(contentTokens).map((elementTokens) =>\n        buildExpressionFromTokens(elementTokens, source)\n    );\n    /* c8 ignore next */\n    const kind = startToken.value === \"@(\" ? \"implicit\" : \"explicit\";\n    const end = resolveStructureEnd(startToken, closingToken, contentTokens);\n    return {\n        node: {\n            type: \"ArrayLiteral\",\n            elements,\n            kind,\n            loc: { start: startToken.start, end },\n        },\n        nextIndex: endIndex,\n    } satisfies { node: ArrayLiteralNode; nextIndex: number };\n}\n\nfunction parseParenthesisPart(\n    tokens: Token[],\n    startIndex: number,\n    source: string = \"\"\n): { node: ParenthesisNode; nextIndex: number } {\n    const startToken = tokens[startIndex];\n    const { contentTokens, endIndex, closingToken } = collectStructureTokens(\n        tokens,\n        startIndex\n    );\n    const elements = splitArrayElements(contentTokens).map((elementTokens) =>\n        buildExpressionFromTokens(elementTokens, source)\n    );\n    const hasComma = hasTopLevelComma(contentTokens);\n    const hasNewline = contentTokens.some((token) => token.type === \"newline\");\n    const end = resolveStructureEnd(startToken, closingToken, contentTokens);\n    return {\n        node: {\n            type: \"Parenthesis\",\n            elements,\n            hasComma,\n            hasNewline,\n            loc: { start: startToken.start, end },\n        },\n        nextIndex: endIndex,\n    };\n}\n\nfunction parseScriptBlockPart(\n    tokens: Token[],\n    startIndex: number,\n    source: string = \"\"\n): { node: ScriptBlockNode; nextIndex: number } {\n    const startToken = tokens[startIndex];\n    const { contentTokens, endIndex, closingToken } = collectStructureTokens(\n        tokens,\n        startIndex\n    );\n    const nestedParser = new Parser(contentTokens, source);\n    const script = nestedParser.parseScript();\n    const closingEnd = resolveStructureEnd(\n        startToken,\n        closingToken,\n        contentTokens\n    );\n    const bodyEnd =\n        script.body.length > 0\n            ? script.body[script.body.length - 1].loc.end\n            : closingEnd;\n    const end = Math.max(closingEnd, bodyEnd);\n    return {\n        node: {\n            type: \"ScriptBlock\",\n            body: script.body,\n            loc: { start: startToken.start, end },\n        },\n        nextIndex: endIndex,\n    };\n}\n\nfunction createHereStringNode(token: Token): HereStringNode {\n    const quote = token.quote ?? \"double\";\n    return {\n        type: \"HereString\",\n        quote,\n        value: token.value,\n        loc: { start: token.start, end: token.end },\n    } satisfies HereStringNode;\n}\n\nfunction createTextNode(token: Token): TextNode {\n    const tokenTypeToRole: Record<string, TokenRole> = {\n        identifier: \"word\",\n        keyword: \"keyword\",\n        number: \"number\",\n        variable: \"variable\",\n        string: \"string\",\n        operator: \"operator\",\n        punctuation: \"punctuation\",\n    };\n    let role: TokenRole = tokenTypeToRole[token.type] ?? \"unknown\";\n\n    if (\n        (role === \"unknown\" || role === \"word\") &&\n        FALLBACK_OPERATOR_TOKENS.has(token.value)\n    ) {\n        role = \"operator\";\n    }\n\n    return {\n        type: \"Text\",\n        value: token.value,\n        role,\n        loc: { start: token.start, end: token.end },\n    } satisfies TextNode;\n}\n\nfunction collectStructureTokens(\n    tokens: Token[],\n    startIndex: number\n): { contentTokens: Token[]; endIndex: number; closingToken?: Token } {\n    const contentTokens: Token[] = [];\n    const stack: string[] = [tokens[startIndex].value];\n    let index = startIndex + 1;\n\n    while (index < tokens.length) {\n        const token = tokens[index];\n\n        if (isOpeningToken(token)) {\n            stack.push(token.value);\n            contentTokens.push(token);\n            index += 1;\n            continue;\n        }\n\n        if (isClosingToken(token)) {\n            if (stack.length === 1) {\n                return {\n                    contentTokens,\n                    endIndex: index + 1,\n                    closingToken: token,\n                };\n            }\n            stack.pop();\n            contentTokens.push(token);\n            index += 1;\n            continue;\n        }\n\n        contentTokens.push(token);\n        index += 1;\n    }\n\n    return { contentTokens, endIndex: tokens.length };\n}\n\nfunction parseStatementForTest(tokens: Token[]): PipelineNode | null {\n    const parser = new Parser(tokens, \"\");\n    const internal = parser as unknown as {\n        parseStatement(): PipelineNode | null;\n    };\n    return internal.parseStatement();\n}\n\nfunction splitHashtableEntries(tokens: Token[]): Token[][] {\n    const entries: Token[][] = [];\n    let current: Token[] = [];\n    const stack: string[] = [];\n    let hasEquals = false;\n\n    for (const token of tokens) {\n        // Track if we've seen an = in this entry\n        if (token.type === \"operator\" && token.value === \"=\" && stack.length === 0) {\n            hasEquals = true;\n        }\n\n        if (token.type === \"newline\" && stack.length === 0) {\n            // Only split on newline if we've completed an assignment (seen = and value)\n            // Skip the newline immediately after = (hasEquals but current ends with =)\n            const lastNonNewline = current.filter(t => t.type !== \"newline\").slice(-1)[0];\n            const isRightAfterEquals = lastNonNewline && lastNonNewline.type === \"operator\" && lastNonNewline.value === \"=\";\n\n            if (hasEquals && !isRightAfterEquals && current.length > 0) {\n                entries.push(current);\n                current = [];\n                hasEquals = false;\n            }\n            continue;\n        }\n\n        if (\n            token.type === \"punctuation\" &&\n            token.value === \";\" &&\n            stack.length === 0\n        ) {\n            if (current.length > 0) {\n                entries.push(current);\n                current = [];\n                hasEquals = false;\n            }\n            continue;\n        }\n\n        if (isOpeningToken(token)) {\n            stack.push(token.value);\n            current.push(token);\n            continue;\n        }\n\n        if (isClosingToken(token)) {\n            stack.pop();\n            current.push(token);\n            continue;\n        }\n\n        current.push(token);\n    }\n\n    if (current.length > 0) {\n        entries.push(current);\n    }\n\n    return entries;\n}\n\nfunction buildHashtableEntry(\n    tokens: Token[],\n    source: string = \"\"\n): HashtableEntryNode {\n    const equalsIndex = findTopLevelEquals(tokens);\n    const keyTokens =\n        equalsIndex === -1 ? tokens : tokens.slice(0, equalsIndex);\n    const valueTokens = equalsIndex === -1 ? [] : tokens.slice(equalsIndex + 1);\n    const keyExpression = buildExpressionFromTokens(keyTokens, source);\n    const valueExpression =\n        valueTokens.length > 0\n            ? buildExpressionFromTokens(valueTokens, source)\n            : buildExpressionFromTokens([], source);\n    const key = extractKeyText(keyTokens);\n    const start = keyTokens[0]?.start ?? valueTokens[0]?.start ?? 0;\n    const end =\n        (valueTokens[valueTokens.length - 1] ?? keyTokens[keyTokens.length - 1])\n            ?.end ?? start;\n\n    return {\n        type: \"HashtableEntry\",\n        key,\n        rawKey: keyExpression,\n        value: valueExpression,\n        loc: { start, end },\n    } satisfies HashtableEntryNode;\n}\n\nfunction findTopLevelEquals(tokens: Token[]): number {\n    const stack: string[] = [];\n    for (let index = 0; index < tokens.length; index += 1) {\n        const token = tokens[index];\n        if (isOpeningToken(token)) {\n            stack.push(token.value);\n            continue;\n        }\n        if (isClosingToken(token)) {\n            stack.pop();\n            continue;\n        }\n        if (\n            stack.length === 0 &&\n            token.type === \"operator\" &&\n            token.value === \"=\"\n        ) {\n            return index;\n        }\n    }\n    return -1;\n}\n\nfunction extractKeyText(tokens: Token[]): string {\n    const text = tokens\n        .filter((token) => token.type !== \"newline\")\n        .map((token) => token.value)\n        .join(\" \")\n        .trim();\n    if (text.startsWith('\"') && text.endsWith('\"')) {\n        return text.slice(1, -1);\n    }\n    if (text.startsWith(\"'\") && text.endsWith(\"'\")) {\n        return text.slice(1, -1);\n    }\n    return text;\n}\n\nfunction splitArrayElements(tokens: Token[]): Token[][] {\n    const elements: Token[][] = [];\n    let current: Token[] = [];\n    const stack: string[] = [];\n\n    for (const token of tokens) {\n        if (token.type === \"newline\" && stack.length === 0) {\n            if (current.length > 0) {\n                elements.push(current);\n                current = [];\n            }\n            continue;\n        }\n\n        if (\n            token.type === \"punctuation\" &&\n            token.value === \",\" &&\n            stack.length === 0\n        ) {\n            if (current.length > 0) {\n                elements.push(current);\n            }\n            current = [];\n            continue;\n        }\n\n        if (isOpeningToken(token)) {\n            stack.push(token.value);\n            current.push(token);\n            continue;\n        }\n\n        if (isClosingToken(token)) {\n            stack.pop();\n            current.push(token);\n            continue;\n        }\n\n        current.push(token);\n    }\n\n    if (current.length > 0) {\n        elements.push(current);\n    }\n\n    return elements;\n}\n\nfunction hasTopLevelComma(tokens: Token[]): boolean {\n    const stack: string[] = [];\n    for (const token of tokens) {\n        if (isOpeningToken(token)) {\n            stack.push(token.value);\n            continue;\n        }\n        if (isClosingToken(token)) {\n            stack.pop();\n            continue;\n        }\n        if (\n            stack.length === 0 &&\n            token.type === \"punctuation\" &&\n            token.value === \",\"\n        ) {\n            return true;\n        }\n    }\n    return false;\n}\n\n/**\n * Parses PowerShell source code into an Abstract Syntax Tree (AST).\n *\n * This is the main entry point for parsing. It tokenizes the source,\n * creates a parser instance, and builds the AST representing the script structure.\n *\n * The parser is designed to be resilient and will attempt to parse even\n * malformed code to provide the best formatting experience possible.\n *\n * @param source - The PowerShell source code to parse\n * @param options - Parser options (currently used for resolving configuration)\n * @returns A ScriptNode representing the root of the AST\n */\nexport function parsePowerShell(\n    source: string,\n    options: ParserOptions\n): ScriptNode {\n    resolveOptions(options);\n    const tokens = tokenize(source);\n    const parser = new Parser(tokens, source);\n    return parser.parseScript();\n}\n\n/**\n * Parses PowerShell source with custom terminator tokens.\n *\n * This is used internally for parsing sub-sections of scripts where\n * certain tokens should stop parsing (e.g., closing braces, specific keywords).\n *\n * @param source - The PowerShell source code to parse\n * @param terminators - Set of token values that should stop parsing\n * @returns A ScriptNode representing the parsed section\n */\nexport function parseScriptWithTerminators(\n    source: string,\n    terminators: Set<string>\n): ScriptNode {\n    const tokens = tokenize(source);\n    const parser = new Parser(tokens, source);\n    return parser.parseScript(terminators);\n}\nexport const __parserTestUtils: {\n    isOpeningToken: typeof isOpeningToken;\n    isClosingToken: typeof isClosingToken;\n    collectStructureTokens: typeof collectStructureTokens;\n    splitHashtableEntries: typeof splitHashtableEntries;\n    findTopLevelEquals: typeof findTopLevelEquals;\n    extractKeyText: typeof extractKeyText;\n    splitArrayElements: typeof splitArrayElements;\n    hasTopLevelComma: typeof hasTopLevelComma;\n    parseScriptWithTerminators: typeof parseScriptWithTerminators;\n    buildExpressionFromTokens: typeof buildExpressionFromTokens;\n    createHereStringNode: typeof createHereStringNode;\n    createTextNode: typeof createTextNode;\n    buildHashtableEntry: typeof buildHashtableEntry;\n    resolveStructureEnd: typeof resolveStructureEnd;\n    parseStatementForTest: typeof parseStatementForTest;\n} = {\n    isOpeningToken,\n    isClosingToken,\n    collectStructureTokens,\n    splitHashtableEntries,\n    findTopLevelEquals,\n    extractKeyText,\n    splitArrayElements,\n    hasTopLevelComma,\n    parseScriptWithTerminators,\n    buildExpressionFromTokens,\n    createHereStringNode,\n    createTextNode,\n    buildHashtableEntry,\n    resolveStructureEnd,\n    parseStatementForTest,\n};\n\nexport const locStart = (node: { loc: { start: number } }): number =>\n    node.loc.start;\nexport const locEnd = (node: { loc: { end: number } }): number => node.loc.end;\n","import type { AstPath, Doc, ParserOptions, Printer } from \"prettier\";\r\nimport { doc } from \"prettier\";\r\n\r\nimport {\r\n    type ArrayLiteralNode,\r\n    type CommentNode,\r\n    type ExpressionNode,\r\n    type ExpressionPartNode,\r\n    type FunctionDeclarationNode,\r\n    type HashtableEntryNode,\r\n    type HashtableNode,\r\n    type HereStringNode,\r\n    type ParenthesisNode,\r\n    type PipelineNode,\r\n    type ScriptBlockNode,\r\n    type ScriptBodyNode,\r\n    type ScriptNode,\r\n    type TextNode,\r\n} from \"./ast.js\";\r\nimport { resolveOptions, type ResolvedOptions } from \"./options.js\";\r\n\r\nconst {\r\n    group,\r\n    indent,\r\n    line,\r\n    softline,\r\n    hardline,\r\n    join,\r\n    ifBreak,\r\n    lineSuffix,\r\n    dedentToRoot,\r\n    align,\r\n} = doc.builders;\r\n\r\n/**\r\n * The Prettier printer for PowerShell.\r\n *\r\n * This implements Prettier's Printer interface to convert PowerShell AST nodes\r\n * into formatted output using Prettier's document builders.\r\n *\r\n * The printer handles:\r\n * - Indentation and spacing\r\n * - Line wrapping and breaking\r\n * - Operator formatting\r\n * - Comment preservation\r\n * - Hashtable alignment\r\n * - Pipeline formatting\r\n * - And much more!\r\n */\r\nexport const powerShellPrinter: Printer<ScriptNode> = {\r\n    print(path: AstPath, options: ParserOptions) {\r\n        const node = path.getValue() as\r\n            | ScriptNode\r\n            | ScriptBodyNode\r\n            | ExpressionPartNode\r\n            | undefined;\r\n        if (!node) {\r\n            return \"\";\r\n        }\r\n        const resolved = resolveOptions(options);\r\n        return printNode(node, resolved);\r\n    },\r\n};\r\n\r\n/**\r\n * Main routing function that dispatches AST nodes to their specific print functions.\r\n *\r\n * @param node - The AST node to print\r\n * @param options - Resolved printer options\r\n * @returns A Prettier Doc representing the formatted output\r\n */\r\nfunction printNode(\r\n    node:\r\n        | ScriptNode\r\n        | ScriptBodyNode\r\n        | ExpressionNode\r\n        | ExpressionPartNode\r\n        | HashtableEntryNode,\r\n    options: ResolvedOptions\r\n): Doc {\r\n    switch (node.type) {\r\n        case \"Script\":\r\n            return printScript(node, options);\r\n        case \"ScriptBlock\":\r\n            return printScriptBlock(node, options);\r\n        case \"FunctionDeclaration\":\r\n            return printFunction(node, options);\r\n        case \"Pipeline\":\r\n            return printPipeline(node, options);\r\n        case \"Expression\":\r\n            return printExpression(node, options);\r\n        case \"Text\":\r\n            return printText(node, options);\r\n        case \"Comment\":\r\n            return printComment(node);\r\n        case \"BlankLine\":\r\n            return Array.from({ length: node.count }, () => hardline);\r\n        case \"ArrayLiteral\":\r\n            return printArray(node, options);\r\n        case \"Hashtable\":\r\n            return printHashtable(node, options);\r\n        case \"HashtableEntry\":\r\n            return printHashtableEntry(node, options);\r\n        case \"HereString\":\r\n            return printHereString(node);\r\n        case \"Parenthesis\":\r\n            return printParenthesis(node, options);\r\n        default:\r\n            return \"\";\r\n    }\r\n}\r\n\r\nfunction concatDocs(docs: Doc[]): Doc {\r\n    if (docs.length === 0) {\r\n        return \"\";\r\n    }\r\n    let acc: Doc = docs[0];\r\n    for (let index = 1; index < docs.length; index += 1) {\r\n        acc = [acc, docs[index]] as Doc;\r\n    }\r\n    return acc;\r\n}\r\n\r\nfunction indentStatement(docToIndent: Doc, options: ResolvedOptions): Doc {\r\n    const indentUnit =\r\n        options.indentStyle === \"tabs\" ? \"\\t\" : \" \".repeat(options.indentSize);\r\n    return [indentUnit, align(indentUnit.length, docToIndent)] as Doc;\r\n}\r\n\r\nfunction printScript(node: ScriptNode, options: ResolvedOptions): Doc {\r\n    const bodyDoc = printStatementList(node.body, options, false);\r\n    if (!bodyDoc) {\r\n        return \"\";\r\n    }\r\n    return [bodyDoc, hardline];\r\n}\r\n\r\nfunction printStatementList(\r\n    body: ScriptBodyNode[],\r\n    options: ResolvedOptions,\r\n    indentStatements: boolean\r\n): Doc {\r\n    const docs: Doc[] = [];\r\n    let previous: ScriptBodyNode | null = null;\r\n    let pendingBlankLines = 0;\r\n\r\n    for (const entry of body) {\r\n        if (entry.type === \"BlankLine\") {\r\n            pendingBlankLines = Math.max(pendingBlankLines, entry.count);\r\n            continue;\r\n        }\r\n\r\n        if (previous) {\r\n            const blankLines = determineBlankLines(\r\n                previous,\r\n                entry,\r\n                pendingBlankLines,\r\n                options\r\n            );\r\n            for (let index = 0; index < blankLines; index += 1) {\r\n                docs.push(hardline);\r\n            }\r\n        }\r\n\r\n        const printed = printNode(entry, options);\r\n        if (\r\n            entry.type === \"Comment\" &&\r\n            previous &&\r\n            entry.loc.start < previous.loc.end &&\r\n            docs.length > 0\r\n        ) {\r\n            const commentDoc = indentStatements\r\n                ? indentStatement(printed, options)\r\n                : printed;\r\n            const lastIndex = docs.length - 1;\r\n            const priorDoc = docs[lastIndex];\r\n            docs[lastIndex] = priorDoc\r\n                ? concatDocs([\r\n                      priorDoc,\r\n                      hardline,\r\n                      commentDoc,\r\n                  ])\r\n                : commentDoc;\r\n            previous = entry;\r\n            pendingBlankLines = 0;\r\n            continue;\r\n        }\r\n\r\n        docs.push(\r\n            indentStatements ? indentStatement(printed, options) : printed\r\n        );\r\n        previous = entry;\r\n        pendingBlankLines = 0;\r\n    }\r\n\r\n    return concatDocs(docs);\r\n}\r\n\r\nfunction determineBlankLines(\r\n    previous: ScriptBodyNode,\r\n    current: ScriptBodyNode,\r\n    pendingBlankLines: number,\r\n    options: ResolvedOptions\r\n): number {\r\n    let base = pendingBlankLines > 0 ? pendingBlankLines : 1;\r\n    const desiredFunctionSpacing = options.blankLinesBetweenFunctions + 1;\r\n\r\n    if (\r\n        (previous.type === \"FunctionDeclaration\" &&\r\n            current.type === \"FunctionDeclaration\") ||\r\n        (previous.type === \"FunctionDeclaration\" &&\r\n            current.type !== \"BlankLine\") ||\r\n        (current.type === \"FunctionDeclaration\" &&\r\n            previous.type !== \"BlankLine\")\r\n    ) {\r\n        base = Math.max(base, desiredFunctionSpacing);\r\n    }\r\n\r\n    if (options.blankLineAfterParam && isParamStatement(previous)) {\r\n        base = Math.max(base, 2);\r\n    }\r\n\r\n    return base;\r\n}\r\n\r\nfunction printScriptBlock(\r\n    node: ScriptBlockNode,\r\n    options: ResolvedOptions\r\n): Doc {\r\n    if (node.body.length === 0) {\r\n        return \"{}\";\r\n    }\r\n\r\n    const bodyDoc = printStatementList(node.body, options, true);\r\n    return group([\r\n        \"{\",\r\n        hardline,\r\n        bodyDoc,\r\n        hardline,\r\n        \"}\",\r\n    ]);\r\n}\r\n\r\nfunction printFunction(\r\n    node: FunctionDeclarationNode,\r\n    options: ResolvedOptions\r\n): Doc {\r\n    const headerDoc = printExpression(node.header, options);\r\n    const bodyDoc = printScriptBlock(node.body, options);\r\n    if (options.braceStyle === \"allman\") {\r\n        return group([\r\n            headerDoc,\r\n            hardline,\r\n            bodyDoc,\r\n        ]);\r\n    }\r\n    return group([\r\n        headerDoc,\r\n        \" \",\r\n        bodyDoc,\r\n    ]);\r\n}\r\n\r\nfunction printPipeline(node: PipelineNode, options: ResolvedOptions): Doc {\r\n    const segmentDocs = node.segments.map((segment) =>\r\n        printExpression(segment, options)\r\n    );\r\n    if (segmentDocs.length === 0) {\r\n        return \"\";\r\n    }\r\n\r\n    let pipelineDoc: Doc = segmentDocs[0];\r\n\r\n    if (segmentDocs.length > 1) {\r\n        // For long pipelines, always break to improve readability\r\n        const shouldAlwaysBreak = segmentDocs.length > 3;\r\n\r\n        const restDocs = segmentDocs\r\n            .slice(1)\r\n            .map((segmentDoc) => [line, [\"| \", segmentDoc]]);\r\n\r\n        if (shouldAlwaysBreak) {\r\n            // Force line breaks for long pipelines\r\n            pipelineDoc = [\r\n                segmentDocs[0],\r\n                indent(restDocs.flatMap((docItem) => docItem)),\r\n            ];\r\n        } else {\r\n            pipelineDoc = group([\r\n                segmentDocs[0],\r\n                indent(restDocs.flatMap((docItem) => docItem)),\r\n            ]);\r\n        }\r\n    }\r\n\r\n    if (node.trailingComment) {\r\n        if (node.trailingComment.inline) {\r\n            pipelineDoc = [\r\n                pipelineDoc,\r\n                lineSuffix([\" #\", node.trailingComment.value]),\r\n            ];\r\n        } else {\r\n            pipelineDoc = [\r\n                pipelineDoc,\r\n                hardline,\r\n                printComment(node.trailingComment),\r\n            ];\r\n        }\r\n    }\r\n\r\n    return pipelineDoc;\r\n}\r\n\r\n/**\r\n * Heuristic to detect if text appears to be comment prose rather than code.\r\n * Uses a minimum length threshold to avoid false positives\r\n * with short variable names or keywords that might not have typical syntax markers.\r\n */\r\nfunction looksLikeCommentText(text: string): boolean {\r\n    const trimmed = text.trim();\r\n\r\n    // Too short to determine reliably\r\n    if (trimmed.length <= MINIMUM_COMMENT_LENGTH) {\r\n        return false;\r\n    }\r\n\r\n    // Definitely code if it starts with typical PowerShell syntax\r\n    if (\r\n        trimmed.startsWith(\"$\") ||\r\n        trimmed.startsWith(\"[\") ||\r\n        trimmed.startsWith(\"(\") ||\r\n        trimmed.startsWith(\"{\") ||\r\n        trimmed.startsWith(\"@\")\r\n    ) {\r\n        return false;\r\n    }\r\n\r\n    // Likely code if it contains assignment or typical operators\r\n    if (\r\n        trimmed.includes(\"=\") ||\r\n        trimmed.includes(\"->\") ||\r\n        trimmed.includes(\"::\") ||\r\n        trimmed.match(/\\b(function|param|if|foreach|while)\\b/i)\r\n    ) {\r\n        return false;\r\n    }\r\n\r\n    // If it contains spaces and looks like natural language, it's likely a comment\r\n    const hasSpaces = trimmed.includes(\" \");\r\n    const wordCount = trimmed.split(/\\s+/).length;\r\n    return hasSpaces && wordCount >= 3;\r\n}\r\n\r\nfunction printExpression(node: ExpressionNode, options: ResolvedOptions): Doc {\r\n    const docs: Doc[] = [];\r\n\r\n    const filteredParts = node.parts.filter((part) => !shouldSkipPart(part));\r\n    const normalizedParts: ExpressionPartNode[] = [];\r\n\r\n    for (let index = 0; index < filteredParts.length; index += 1) {\r\n        const current = filteredParts[index];\r\n        if (current.type === \"Text\" && current.role === \"operator\") {\r\n            const next = filteredParts[index + 1];\r\n            if (next && next.type === \"Text\" && next.role === \"operator\") {\r\n                const combinedValue = current.value + next.value;\r\n                if (CONCATENATED_OPERATOR_PAIRS.has(combinedValue)) {\r\n                    normalizedParts.push({\r\n                        ...current,\r\n                        value: combinedValue,\r\n                        loc: { start: current.loc.start, end: next.loc.end },\r\n                    });\r\n                    index += 1;\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n        normalizedParts.push(current);\r\n    }\r\n\r\n    let previous: ExpressionPartNode | null = null;\r\n\r\n    for (let index = 0; index < normalizedParts.length; index += 1) {\r\n        const part = normalizedParts[index];\r\n\r\n        if (part.type === \"Parenthesis\" && isParamKeyword(previous)) {\r\n            docs.push(printParamParenthesis(part, options));\r\n            previous = part;\r\n            continue;\r\n        }\r\n\r\n        // Check if this is comment text (not starting with #, but appears to be prose)\r\n        if (\r\n            part.type === \"Text\" &&\r\n            part.role === \"unknown\" &&\r\n            previous &&\r\n            !part.value.trim().startsWith(\"#\") &&\r\n            looksLikeCommentText(part.value)\r\n        ) {\r\n            // This looks like comment text - treat it as an inline comment\r\n            docs.push(lineSuffix([\" # \", part.value.trim()]));\r\n            previous = part;\r\n            continue;\r\n        }\r\n\r\n        if (previous) {\r\n            // Special case: word followed by parenthesis could be method call or cmdlet\r\n            // Check if the word comes after . or :: (method call - no space)\r\n            if (\r\n                part.type === \"Parenthesis\" &&\r\n                previous.type === \"Text\" &&\r\n                previous.role === \"word\" &&\r\n                index >= 2\r\n            ) {\r\n                const beforeWord = normalizedParts[index - 2];\r\n                if (\r\n                    beforeWord &&\r\n                    beforeWord.type === \"Text\" &&\r\n                    (beforeWord.value === \".\" || beforeWord.value === \"::\")\r\n                ) {\r\n                    // This is a method call - no space before (\r\n                    docs.push(printNode(part, options));\r\n                    previous = part;\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            const separator = gapBetween(previous, part);\r\n            if (separator) {\r\n                docs.push(separator);\r\n            }\r\n        }\r\n\r\n        docs.push(printNode(part, options));\r\n        previous = part;\r\n    }\r\n\r\n    return docs.length === 0 ? \"\" : group(docs);\r\n}\r\n\r\nfunction gapBetween(\r\n    previous: ExpressionPartNode,\r\n    current: ExpressionPartNode\r\n): Doc | null {\r\n    const prevSymbol = getSymbol(previous);\r\n    const currentSymbol = getSymbol(current);\r\n\r\n    if (\r\n        current.type === \"ArrayLiteral\" &&\r\n        current.kind === \"explicit\" &&\r\n        Boolean(previous)\r\n    ) {\r\n        return null;\r\n    }\r\n\r\n    if (\r\n        current.type === \"Text\" &&\r\n        current.role === \"operator\" &&\r\n        (current.value === \"++\" || current.value === \"--\")\r\n    ) {\r\n        return null;\r\n    }\r\n\r\n    if (\r\n        previous.type === \"Text\" &&\r\n        previous.role === \"operator\" &&\r\n        current.type === \"Text\" &&\r\n        current.role === \"operator\"\r\n    ) {\r\n        const combined = previous.value + current.value;\r\n        if (CONCATENATED_OPERATOR_PAIRS.has(combined)) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    if (current.type === \"Parenthesis\") {\r\n        if (previous && previous.type === \"Text\") {\r\n            if (previous.value.toLowerCase() === \"param\") {\r\n                return null;\r\n            }\r\n            if (previous.role === \"keyword\") {\r\n                return \" \";\r\n            }\r\n            // Operators need space before parenthesis\r\n            if (previous.role === \"operator\") {\r\n                return \" \";\r\n            }\r\n            // Cmdlets and functions (words) need space before parenthesis\r\n            // Method calls are handled in printExpression\r\n            if (previous.role === \"word\") {\r\n                return \" \";\r\n            }\r\n            // PowerShell logical operators need space before parenthesis\r\n            const prevLower = previous.value.toLowerCase();\r\n            if (\r\n                prevLower.startsWith(\"-\") &&\r\n                (prevLower === \"-not\" ||\r\n                    prevLower === \"-and\" ||\r\n                    prevLower === \"-or\" ||\r\n                    prevLower === \"-xor\")\r\n            ) {\r\n                return \" \";\r\n            }\r\n            return null;\r\n        }\r\n        return \" \";\r\n    }\r\n\r\n    if (previous.type === \"Parenthesis\") {\r\n        if (currentSymbol && NO_SPACE_BEFORE.has(currentSymbol)) {\r\n            return null;\r\n        }\r\n        return \" \";\r\n    }\r\n\r\n    if (!prevSymbol && !currentSymbol) {\r\n        return \" \";\r\n    }\r\n\r\n    if (!prevSymbol) {\r\n        if (currentSymbol && NO_SPACE_BEFORE.has(currentSymbol)) {\r\n            return null;\r\n        }\r\n        return \" \";\r\n    }\r\n\r\n    if (NO_SPACE_AFTER.has(prevSymbol)) {\r\n        return null;\r\n    }\r\n\r\n    if (currentSymbol && NO_SPACE_BEFORE.has(currentSymbol)) {\r\n        return null;\r\n    }\r\n\r\n    if (\r\n        prevSymbol &&\r\n        currentSymbol &&\r\n        SYMBOL_NO_GAP.has(`${prevSymbol}:${currentSymbol}`)\r\n    ) {\r\n        return null;\r\n    }\r\n\r\n    if (prevSymbol && currentSymbol) {\r\n        const pair = `${prevSymbol}${currentSymbol}`;\r\n        if (CONCATENATED_OPERATOR_PAIRS.has(pair)) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /* c8 ignore next */\r\n    if (prevSymbol === \"=\" || currentSymbol === \"=\") {\r\n        return \" \";\r\n    }\r\n\r\n    if (\r\n        current.type === \"ScriptBlock\" ||\r\n        current.type === \"Hashtable\" ||\r\n        current.type === \"ArrayLiteral\"\r\n    ) {\r\n        return \" \";\r\n    }\r\n\r\n    return \" \";\r\n}\r\n\r\nfunction isParamStatement(node: ScriptBodyNode | null): boolean {\r\n    if (!node || node.type !== \"Pipeline\") {\r\n        return false;\r\n    }\r\n    if (node.segments.length === 0) {\r\n        return false;\r\n    }\r\n    const firstSegment = node.segments[0];\r\n    if (firstSegment.parts.length === 0) {\r\n        return false;\r\n    }\r\n    const firstPart = firstSegment.parts.find((part) => part.type === \"Text\");\r\n    if (!firstPart || firstPart.type !== \"Text\") {\r\n        return false;\r\n    }\r\n    return firstPart.value.toLowerCase() === \"param\";\r\n}\r\n\r\nconst NO_SPACE_BEFORE = new Set([\r\n    \")\",\r\n    \"]\",\r\n    \"}\",\r\n    \",\",\r\n    \";\",\r\n    \".\",\r\n    \"::\",\r\n    \":\",\r\n    \">\",\r\n    \"<\",\r\n]);\r\nconst NO_SPACE_AFTER = new Set([\r\n    \"(\",\r\n    \"[\",\r\n    \"{\",\r\n    \".\",\r\n    \"::\",\r\n    \":\",\r\n    \"@\",\r\n    \">\",\r\n    \"<\",\r\n    \">>\",\r\n    \"2>\",\r\n    \"2>>\",\r\n    \"3>\",\r\n    \"3>>\",\r\n    \"4>\",\r\n    \"4>>\",\r\n    \"5>\",\r\n    \"5>>\",\r\n    \"6>\",\r\n    \"6>>\",\r\n    \"*>\",\r\n    \"*>>\",\r\n    \"2>&1\",\r\n    \"3>&1\",\r\n    \"4>&1\",\r\n    \"5>&1\",\r\n    \"6>&1\",\r\n    \"*>&1\",\r\n    \"1>&2\",\r\n    \"2>&2\",\r\n    \"3>&2\",\r\n    \"4>&2\",\r\n    \"5>&2\",\r\n    \"6>&2\",\r\n    \"*>&2\",\r\n]);\r\n/**\r\n * Minimum character length for text to be considered comment prose.\r\n * Used to avoid false positives with short variable names or keywords.\r\n */\r\nconst MINIMUM_COMMENT_LENGTH = 10;\r\nconst SYMBOL_NO_GAP = new Set([\r\n    \".:word\",\r\n    \"::word\",\r\n    \"word:(\",\r\n    \"word:[\",\r\n]);\r\nconst CONCATENATED_OPERATOR_PAIRS = new Set([\r\n    \"++\",\r\n    \"--\",\r\n    \"+=\",\r\n    \"-=\",\r\n    \"*=\",\r\n    \"/=\",\r\n    \"%=\",\r\n    \"&=\",\r\n    \"|=\",\r\n    \"^=\",\r\n    \"??\",\r\n]);\r\n\r\nfunction getSymbol(node: ExpressionPartNode | null): string | null {\r\n    if (!node) {\r\n        return null;\r\n    }\r\n    if (\r\n        node.type === \"Text\" &&\r\n        (node.role === \"punctuation\" || node.role === \"operator\")\r\n    ) {\r\n        return node.value;\r\n    }\r\n    // Handle special characters that may be role=\"unknown\"\r\n    if (node.type === \"Text\" && node.role === \"unknown\") {\r\n        const val = node.value.trim();\r\n        if (val === \"@\" || val === \"::\" || val === \":\") {\r\n            return val;\r\n        }\r\n    }\r\n    if (node.type === \"Parenthesis\") {\r\n        return \"(\";\r\n    }\r\n    return null;\r\n}\r\n\r\nfunction isParamKeyword(node: ExpressionPartNode | null): boolean {\r\n    return Boolean(\r\n        node && node.type === \"Text\" && node.value.toLowerCase() === \"param\"\r\n    );\r\n}\r\n\r\nconst KEYWORD_CASE_TRANSFORMS: Record<string, (value: string) => string> = {\r\n    preserve: (value) => value,\r\n    lower: (value) => value.toLowerCase(),\r\n    upper: (value) => value.toUpperCase(),\r\n    pascal: (value) =>\r\n        value.length === 0\r\n            ? value\r\n            : value[0].toUpperCase() + value.slice(1).toLowerCase(),\r\n};\r\n\r\nconst CMDLET_ALIAS_MAP: Record<string, string> = {\r\n    gi: \"Get-Item\",\r\n    gci: \"Get-ChildItem\",\r\n    ls: \"Get-ChildItem\",\r\n    dir: \"Get-ChildItem\",\r\n    ld: \"Get-ChildItem\",\r\n    la: \"Get-ChildItem\",\r\n    gcm: \"Get-Command\",\r\n    gm: \"Get-Member\",\r\n    gps: \"Get-Process\",\r\n    ps: \"Get-Process\",\r\n    gwmi: \"Get-WmiObject\",\r\n    gsv: \"Get-Service\",\r\n    cat: \"Get-Content\",\r\n    gc: \"Get-Content\",\r\n    echo: \"Write-Output\",\r\n    write: \"Write-Output\",\r\n    \"%\": \"ForEach-Object\",\r\n    foreach: \"ForEach-Object\",\r\n    \"?\": \"Where-Object\",\r\n    where: \"Where-Object\",\r\n};\r\n\r\nconst DISALLOWED_CMDLET_REWRITE = new Map([[\"write-host\", \"Write-Output\"]]);\r\n\r\nfunction printText(node: TextNode, options: ResolvedOptions): Doc {\r\n    if (node.role === \"string\") {\r\n        return normalizeStringLiteral(node.value, options);\r\n    }\r\n\r\n    let value = node.value;\r\n\r\n    if (node.role === \"keyword\") {\r\n        const transform =\r\n            KEYWORD_CASE_TRANSFORMS[options.keywordCase] ??\r\n            KEYWORD_CASE_TRANSFORMS.preserve;\r\n        value = transform(value);\r\n    }\r\n\r\n    if (\r\n        options.rewriteAliases &&\r\n        (node.role === \"word\" ||\r\n            node.role === \"operator\" ||\r\n            node.role === \"unknown\")\r\n    ) {\r\n        const aliasKey = value.toLowerCase();\r\n        if (Object.prototype.hasOwnProperty.call(CMDLET_ALIAS_MAP, aliasKey)) {\r\n            value = CMDLET_ALIAS_MAP[aliasKey]!;\r\n        }\r\n    }\r\n\r\n    if (node.role === \"word\" && options.rewriteWriteHost) {\r\n        const replacement = DISALLOWED_CMDLET_REWRITE.get(value.toLowerCase());\r\n        if (replacement) {\r\n            value = replacement;\r\n        }\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\nfunction printComment(node: CommentNode): Doc {\r\n    if (node.style === \"block\") {\r\n        return node.value;\r\n    }\r\n    return [\"#\", node.value];\r\n}\r\n\r\nfunction printArray(node: ArrayLiteralNode, options: ResolvedOptions): Doc {\r\n    const open = node.kind === \"implicit\" ? \"@(\" : \"[\";\r\n    const close = node.kind === \"implicit\" ? \")\" : \"]\";\r\n    if (node.elements.length === 0) {\r\n        return [open, close];\r\n    }\r\n    const groupId = Symbol(\"array\");\r\n    const elementDocs = node.elements.map((element) =>\r\n        printExpression(element, options)\r\n    );\r\n    const shouldBreak = elementDocs.length > 1;\r\n    const separator: Doc = [\",\", line];\r\n    // PowerShell does NOT support trailing commas in arrays, so never add them\r\n\r\n    return group(\r\n        [\r\n            open,\r\n            indent([\r\n                shouldBreak ? line : softline,\r\n                join(separator, elementDocs),\r\n            ]),\r\n            shouldBreak ? line : softline,\r\n            close,\r\n        ],\r\n        { id: groupId }\r\n    );\r\n}\r\n\r\nfunction printHashtable(node: HashtableNode, options: ResolvedOptions): Doc {\r\n    const entries = options.sortHashtableKeys\r\n        ? [...node.entries].sort((a, b) =>\r\n              a.key.localeCompare(b.key, undefined, { sensitivity: \"base\" })\r\n          )\r\n        : node.entries;\r\n\r\n    if (entries.length === 0) {\r\n        return \"@{}\";\r\n    }\r\n\r\n    const groupId = Symbol(\"hashtable\");\r\n\r\n    const entryDocs = entries.map((entry, index) => {\r\n        const entryDoc = printHashtableEntry(entry, options);\r\n        const isLast = index === entries.length - 1;\r\n        const separator = isLast\r\n            ? trailingCommaDoc(options, groupId, true, \";\")\r\n            : ifBreak(\"\", \";\", { groupId });\r\n        return [entryDoc, separator];\r\n    });\r\n\r\n    return group(\r\n        [\r\n            \"@{\",\r\n            indent([line, join(line, entryDocs)]),\r\n            line,\r\n            \"}\",\r\n        ],\r\n        {\r\n            id: groupId,\r\n        }\r\n    );\r\n}\r\n\r\nfunction printHashtableEntry(\r\n    node: HashtableEntryNode,\r\n    options: ResolvedOptions\r\n): Doc {\r\n    const keyDoc = printExpression(node.rawKey, options);\r\n    const valueDoc = printExpression(node.value, options);\r\n\r\n    // Check if the value expression starts with a control flow keyword\r\n    // (if, switch, foreach, etc.) - these should stay on the same line as '='\r\n    const firstPart = node.value.parts[0];\r\n    const startsWithKeyword =\r\n        firstPart &&\r\n        firstPart.type === \"Text\" &&\r\n        firstPart.role === \"keyword\" &&\r\n        /^(if|switch|foreach|while|for)$/i.test(firstPart.value);\r\n\r\n    if (startsWithKeyword) {\r\n        // Keep keyword expressions on the same line as the '=' sign\r\n        return group([\r\n            keyDoc,\r\n            \" = \",\r\n            valueDoc,\r\n        ]);\r\n    }\r\n\r\n    return group([\r\n        keyDoc,\r\n        \" =\",\r\n        indent([line, valueDoc]),\r\n    ]);\r\n}\r\n\r\nfunction printHereString(node: HereStringNode): Doc {\r\n    return dedentToRoot(node.value);\r\n}\r\n\r\nfunction printParamParenthesis(\r\n    node: ParenthesisNode,\r\n    options: ResolvedOptions\r\n): Doc {\r\n    if (node.elements.length === 0) {\r\n        return \"()\";\r\n    }\r\n\r\n    if (node.elements.length <= 1 && !node.hasNewline) {\r\n        return printParenthesis(node, options);\r\n    }\r\n\r\n    const groupId = Symbol(\"param\");\r\n    const elementDocs: Doc[] = [];\r\n    let pendingAttributes: Doc[] = [];\r\n\r\n    const flushAttributes = (nextDoc?: Doc) => {\r\n        if (pendingAttributes.length === 0) {\r\n            if (nextDoc) {\r\n                elementDocs.push(nextDoc);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const attributeDoc =\r\n            pendingAttributes.length === 1\r\n                ? pendingAttributes[0]\r\n                : join(hardline, pendingAttributes);\r\n\r\n        if (nextDoc) {\r\n            elementDocs.push(\r\n                group([\r\n                    attributeDoc,\r\n                    hardline,\r\n                    nextDoc,\r\n                ])\r\n            );\r\n        } else {\r\n            elementDocs.push(attributeDoc);\r\n        }\r\n        pendingAttributes = [];\r\n    };\r\n\r\n    for (let index = 0; index < node.elements.length; index += 1) {\r\n        const element = node.elements[index];\r\n\r\n        // Skip comment-only expressions - they'll be handled as trailing comments\r\n        if (isCommentExpression(element)) {\r\n            continue;\r\n        }\r\n\r\n        if (isAttributeExpression(element)) {\r\n            pendingAttributes.push(printExpression(element, options));\r\n            continue;\r\n        }\r\n\r\n        let printed = printExpression(element, options);\r\n\r\n        // Check if the next element is a comment - if so, attach it inline\r\n        const nextElement = node.elements[index + 1];\r\n        if (nextElement && isCommentExpression(nextElement)) {\r\n            const commentText = extractCommentText(nextElement);\r\n            if (commentText) {\r\n                printed = [printed, lineSuffix([\" \", commentText])];\r\n                index += 1; // Skip the comment element since we've consumed it\r\n            }\r\n        }\r\n\r\n        flushAttributes(printed);\r\n    }\r\n\r\n    flushAttributes();\r\n    const separator: Doc = [\",\", hardline];\r\n\r\n    return group(\r\n        [\r\n            \"(\",\r\n            indent([hardline, join(separator, elementDocs)]),\r\n            hardline,\r\n            \")\",\r\n        ],\r\n        {\r\n            id: groupId,\r\n        }\r\n    );\r\n}\r\n\r\nfunction isAttributeExpression(node: ExpressionNode): boolean {\r\n    if (node.parts.length === 0) {\r\n        return false;\r\n    }\r\n\r\n    return node.parts.every((part) => {\r\n        if (part.type !== \"Text\") {\r\n            return false;\r\n        }\r\n        const trimmed = part.value.trim();\r\n        return trimmed.startsWith(\"[\") && trimmed.endsWith(\"]\");\r\n    });\r\n}\r\n\r\nfunction isCommentExpression(node: ExpressionNode): boolean {\r\n    if (node.parts.length !== 1) {\r\n        return false;\r\n    }\r\n\r\n    const part = node.parts[0];\r\n    if (part.type !== \"Text\") {\r\n        return false;\r\n    }\r\n\r\n    // Check if it's likely a comment based on context:\r\n    // 1. Starts with # or <# (original inline comment)\r\n    // 2. Appears to be comment text (no $ or [ at start, longer text)\r\n    const trimmed = part.value.trim();\r\n    if (trimmed.startsWith(\"#\") || trimmed.startsWith(\"<#\")) {\r\n        return true;\r\n    }\r\n\r\n    return looksLikeCommentText(trimmed);\r\n}\r\n\r\nfunction extractCommentText(node: ExpressionNode): string | null {\r\n    if (!isCommentExpression(node)) {\r\n        return null;\r\n    }\r\n\r\n    const part = node.parts[0];\r\n    if (part.type !== \"Text\") {\r\n        return null;\r\n    }\r\n\r\n    const trimmed = part.value.trim();\r\n    // If it already starts with #, return as is\r\n    if (trimmed.startsWith(\"#\")) {\r\n        return trimmed;\r\n    }\r\n    // Otherwise, prepend # to make it a comment\r\n    return `# ${trimmed}`;\r\n}\r\n\r\nfunction printParenthesis(\r\n    node: ParenthesisNode,\r\n    options: ResolvedOptions\r\n): Doc {\r\n    if (node.elements.length === 0) {\r\n        return \"()\";\r\n    }\r\n    const groupId = Symbol(\"parenthesis\");\r\n    const elementDocs = node.elements.map((element) =>\r\n        printExpression(element, options)\r\n    );\r\n    if (elementDocs.length === 1 && !node.hasNewline) {\r\n        return group(\r\n            [\r\n                \"(\",\r\n                indent([softline, elementDocs[0]]),\r\n                softline,\r\n                \")\",\r\n            ],\r\n            {\r\n                id: groupId,\r\n            }\r\n        );\r\n    }\r\n\r\n    const hasComma = node.hasComma;\r\n    const forceMultiline =\r\n        node.hasNewline || (!node.hasComma && elementDocs.length > 1);\r\n    const separator: Doc = hasComma\r\n        ? [\",\", forceMultiline ? hardline : line]\r\n        : hardline;\r\n    const leadingLine = hasComma\r\n        ? forceMultiline\r\n            ? hardline\r\n            : line\r\n        : hardline;\r\n    const trailingLine = hasComma\r\n        ? forceMultiline\r\n            ? hardline\r\n            : line\r\n        : hardline;\r\n\r\n    return group(\r\n        [\r\n            \"(\",\r\n            indent([leadingLine, join(separator, elementDocs)]),\r\n            trailingLine,\r\n            \")\",\r\n        ],\r\n        {\r\n            id: groupId,\r\n        }\r\n    );\r\n}\r\n\r\nfunction trailingCommaDoc(\r\n    options: ResolvedOptions,\r\n    groupId: symbol,\r\n    hasElements: boolean,\r\n    delimiter: \",\" | \";\"\r\n): Doc {\r\n    if (!hasElements) {\r\n        return \"\";\r\n    }\r\n    switch (options.trailingComma) {\r\n        case \"all\":\r\n            return delimiter;\r\n        case \"multiline\":\r\n            return ifBreak(delimiter, \"\", { groupId });\r\n        case \"none\":\r\n        default:\r\n            return \"\";\r\n    }\r\n}\r\n\r\nexport function createPrinter(): Printer<ScriptNode> {\r\n    return powerShellPrinter;\r\n}\r\n\r\nexport const __printerTestUtils: {\r\n    gapBetween: typeof gapBetween;\r\n    getSymbol: typeof getSymbol;\r\n    shouldSkipPart: typeof shouldSkipPart;\r\n    normalizeStringLiteral: typeof normalizeStringLiteral;\r\n    printParamParenthesis: typeof printParamParenthesis;\r\n    printPipeline: typeof printPipeline;\r\n    trailingCommaDoc: typeof trailingCommaDoc;\r\n    isParamStatement: typeof isParamStatement;\r\n    printNode: typeof printNode;\r\n    printScript: typeof printScript;\r\n    concatDocs: typeof concatDocs;\r\n    indentStatement: typeof indentStatement;\r\n    printStatementList: typeof printStatementList;\r\n} = {\r\n    gapBetween,\r\n    getSymbol,\r\n    shouldSkipPart,\r\n    normalizeStringLiteral,\r\n    printParamParenthesis,\r\n    printPipeline,\r\n    trailingCommaDoc,\r\n    isParamStatement,\r\n    printNode,\r\n    printScript,\r\n    concatDocs,\r\n    indentStatement,\r\n    printStatementList,\r\n};\r\n\r\nfunction normalizeStringLiteral(\r\n    value: string,\r\n    options: ResolvedOptions\r\n): string {\r\n    if (!options.preferSingleQuote) {\r\n        return value;\r\n    }\r\n\r\n    if (!value.startsWith('\"') || !value.endsWith('\"')) {\r\n        return value;\r\n    }\r\n\r\n    const inner = value.slice(1, -1);\r\n\r\n    // Skip normalization for regex-like pattern strings to avoid altering embedded quoting\r\n    // Heuristics: starts with (? or contains unescaped character classes or anchors typical of patterns.\r\n    if (\r\n        /^\\(\\?[imxsU]/.test(inner) ||\r\n        /\\[[^\\]]+\\]/.test(inner) ||\r\n        /\\bWrite-(Warning|Error|Host|Output)\\b/.test(inner)\r\n    ) {\r\n        return value;\r\n    }\r\n\r\n    if (inner.includes(\"'\")) {\r\n        return value;\r\n    }\r\n\r\n    if (/[`$\"\\n]/.test(inner)) {\r\n        return value;\r\n    }\r\n\r\n    return `'${inner}'`;\r\n}\r\n\r\nfunction shouldSkipPart(part: ExpressionPartNode): boolean {\r\n    if (part.type === \"Text\") {\r\n        const trimmed = part.value.trim();\r\n        if (trimmed === \"`\") {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n","import type { Plugin, SupportLanguage } from \"prettier\";\n\nimport { pluginOptions, defaultOptions } from \"./options.js\";\nimport { parsePowerShell, locEnd, locStart } from \"./parser.js\";\nimport { powerShellPrinter } from \"./printer.js\";\n\nconst languages: SupportLanguage[] = [\n    {\n        name: \"PowerShell\",\n        parsers: [\"powershell\"],\n        extensions: [\n            \".ps1\",\n            \".psm1\",\n            \".psd1\",\n        ],\n        tmScope: \"source.powershell\",\n        aceMode: \"powershell\",\n        linguistLanguageId: 131,\n        vscodeLanguageIds: [\"powershell\"],\n    },\n] as const;\n\nconst parsers: Plugin[\"parsers\"] = {\n    powershell: {\n        parse: parsePowerShell,\n        astFormat: \"powershell-ast\",\n        locStart,\n        locEnd,\n        hasPragma() {\n            return false;\n        },\n    },\n} as const;\n\nconst printers: Plugin[\"printers\"] = {\n    \"powershell-ast\": powerShellPrinter,\n};\n\nconst plugin: Plugin = {\n    languages,\n    parsers,\n    printers,\n    options: pluginOptions,\n    defaultOptions,\n};\n\nexport default plugin;\n"]}