{"version":3,"sources":["../src/options.ts","../src/tokenizer.ts","../src/parser.ts","../src/printer.ts","../src/index.ts"],"names":["doc","index_default"],"mappings":";;;;;AAsBO,IAAM,aAAA,GAAgC;AAAA,EAC3C,qBAAA,EAAuB;AAAA,IACrB,QAAA,EAAU,YAAA;AAAA,IACV,IAAA,EAAM,QAAA;AAAA,IACN,OAAA,EAAS,QAAA;AAAA,IACT,WAAA,EAAa,8CAAA;AAAA,IACb,OAAA,EAAS;AAAA,MACP,EAAE,KAAA,EAAO,QAAA,EAAU,WAAA,EAAa,6BAAA,EAA8B;AAAA,MAC9D,EAAE,KAAA,EAAO,MAAA,EAAQ,WAAA,EAAa,2BAAA;AAA4B;AAC5D,GACF;AAAA,EACA,oBAAA,EAAsB;AAAA,IACpB,QAAA,EAAU,YAAA;AAAA,IACV,IAAA,EAAM,KAAA;AAAA,IACN,OAAA,EAAS,CAAA;AAAA,IACT,WAAA,EAAa,kDAAA;AAAA,IACb,OAAO,EAAE,KAAA,EAAO,GAAG,GAAA,EAAK,CAAA,EAAG,MAAM,CAAA;AAAE,GACrC;AAAA,EACA,uBAAA,EAAyB;AAAA,IACvB,QAAA,EAAU,YAAA;AAAA,IACV,IAAA,EAAM,QAAA;AAAA,IACN,OAAA,EAAS,WAAA;AAAA,IACT,WAAA,EAAa,2DAAA;AAAA,IACb,OAAA,EAAS;AAAA,MACP,EAAE,KAAA,EAAO,MAAA,EAAQ,WAAA,EAAa,0CAAA,EAA2C;AAAA,MACzE;AAAA,QACE,KAAA,EAAO,WAAA;AAAA,QACP,WAAA,EAAa;AAAA,OACf;AAAA,MACA,EAAE,KAAA,EAAO,KAAA,EAAO,WAAA,EAAa,oDAAA;AAAqD;AACpF,GACF;AAAA,EACA,2BAAA,EAA6B;AAAA,IAC3B,QAAA,EAAU,YAAA;AAAA,IACV,IAAA,EAAM,SAAA;AAAA,IACN,OAAA,EAAS,KAAA;AAAA,IACT,WAAA,EAAa;AAAA,GACf;AAAA,EACA,oCAAA,EAAsC;AAAA,IACpC,QAAA,EAAU,YAAA;AAAA,IACV,IAAA,EAAM,KAAA;AAAA,IACN,OAAA,EAAS,CAAA;AAAA,IACT,WAAA,EAAa,gEAAA;AAAA,IACb,OAAO,EAAE,KAAA,EAAO,GAAG,GAAA,EAAK,CAAA,EAAG,MAAM,CAAA;AAAE,GACrC;AAAA,EACA,6BAAA,EAA+B;AAAA,IAC7B,QAAA,EAAU,YAAA;AAAA,IACV,IAAA,EAAM,SAAA;AAAA,IACN,OAAA,EAAS,IAAA;AAAA,IACT,WAAA,EAAa;AAAA,GACf;AAAA,EACA,oBAAA,EAAsB;AAAA,IACpB,QAAA,EAAU,YAAA;AAAA,IACV,IAAA,EAAM,QAAA;AAAA,IACN,OAAA,EAAS,MAAA;AAAA,IACT,WAAA,EAAa,sEAAA;AAAA,IACb,OAAA,EAAS;AAAA,MACP;AAAA,QACE,KAAA,EAAO,MAAA;AAAA,QACP,WAAA,EAAa;AAAA,OACf;AAAA,MACA,EAAE,KAAA,EAAO,QAAA,EAAU,WAAA,EAAa,4DAAA;AAAwD;AAC1F,GACF;AAAA,EACA,mBAAA,EAAqB;AAAA,IACnB,QAAA,EAAU,YAAA;AAAA,IACV,IAAA,EAAM,KAAA;AAAA,IACN,OAAA,EAAS,GAAA;AAAA,IACT,WAAA,EAAa,wDAAA;AAAA,IACb,OAAO,EAAE,KAAA,EAAO,IAAI,GAAA,EAAK,GAAA,EAAK,MAAM,CAAA;AAAE,GACxC;AAAA,EACA,2BAAA,EAA6B;AAAA,IAC3B,QAAA,EAAU,YAAA;AAAA,IACV,IAAA,EAAM,SAAA;AAAA,IACN,OAAA,EAAS,KAAA;AAAA,IACT,WAAA,EAAa;AAAA,GACf;AAAA,EACA,qBAAA,EAAuB;AAAA,IACrB,QAAA,EAAU,YAAA;AAAA,IACV,IAAA,EAAM,QAAA;AAAA,IACN,OAAA,EAAS,UAAA;AAAA,IACT,WAAA,EAAa,8CAAA;AAAA,IACb,OAAA,EAAS;AAAA,MACP,EAAE,KAAA,EAAO,UAAA,EAAY,WAAA,EAAa,iCAAA,EAAkC;AAAA,MACpE,EAAE,KAAA,EAAO,OAAA,EAAS,WAAA,EAAa,iCAAA,EAAkC;AAAA,MACjE,EAAE,KAAA,EAAO,OAAA,EAAS,WAAA,EAAa,iCAAA,EAAkC;AAAA,MACjE,EAAE,KAAA,EAAO,QAAA,EAAU,WAAA,EAAa,mCAAA;AAAoC;AACtE,GACF;AAAA,EACA,wBAAA,EAA0B;AAAA,IACxB,QAAA,EAAU,YAAA;AAAA,IACV,IAAA,EAAM,SAAA;AAAA,IACN,OAAA,EAAS,KAAA;AAAA,IACT,WAAA,EAAa;AAAA,GACf;AAAA,EACA,0BAAA,EAA4B;AAAA,IAC1B,QAAA,EAAU,YAAA;AAAA,IACV,IAAA,EAAM,SAAA;AAAA,IACN,OAAA,EAAS,KAAA;AAAA,IACT,WAAA,EAAa;AAAA;AAEjB,CAAA;AAEO,IAAM,cAAA,GAAiB;AAAA,EAC5B,QAAA,EAAU;AACZ,CAAA;AAiBO,SAAS,eAAe,OAAA,EAAyC;AACtE,EAAA,MAAM,WAAA,GAAe,QAAQ,qBAAA,IAA2D,QAAA;AACxF,EAAA,MAAM,oBAAoB,OAAA,CAAQ,oBAAA;AAClC,EAAA,MAAM,wBAAA,GAA2B,OAAO,iBAAiB,CAAA;AACzD,EAAA,MAAM,kBAAA,GAAqB,MAAA,CAAO,OAAA,CAAQ,QAAQ,CAAA;AAClD,EAAA,MAAM,UAAA,GAAa,OAAO,QAAA,CAAS,wBAAwB,KAAK,wBAAA,GAA2B,CAAA,GACvF,KAAK,KAAA,CAAM,wBAAwB,IACnC,MAAA,CAAO,QAAA,CAAS,kBAAkB,CAAA,IAAK,kBAAA,GAAqB,IAC1D,IAAA,CAAK,KAAA,CAAM,kBAAkB,CAAA,GAC7B,CAAA;AAEN,EAAA,IAAI,gBAAgB,MAAA,EAAQ;AAC1B,IAAA,OAAA,CAAQ,OAAA,GAAU,IAAA;AAAA,EACpB,CAAA,MAAO;AACL,IAAA,OAAA,CAAQ,OAAA,GAAU,KAAA;AAAA,EACpB;AACA,EAAA,OAAA,CAAQ,QAAA,GAAW,UAAA;AAEnB,EAAA,MAAM,aAAA,GACH,QAAQ,uBAAA,IAA+D,WAAA;AAC1E,EAAA,MAAM,iBAAA,GAAoB,OAAA,CAAQ,OAAA,CAAQ,2BAA2B,CAAA;AACrE,EAAA,MAAM,aAAA,GAAgB,MAAA,CAAO,OAAA,CAAQ,oCAAA,IAAwC,CAAC,CAAA;AAC9E,EAAA,MAAM,oBAAA,GAAuB,MAAA,CAAO,QAAA,CAAS,aAAa,IAAI,aAAA,GAAgB,CAAA;AAC9E,EAAA,MAAM,0BAAA,GAA6B,IAAA,CAAK,GAAA,CAAI,CAAA,EAAG,IAAA,CAAK,GAAA,CAAI,CAAA,EAAG,IAAA,CAAK,KAAA,CAAM,oBAAoB,CAAC,CAAC,CAAA;AAC5F,EAAA,IAAI,mBAAA,GAAsB,IAAA;AAE1B,EAAA,IAAI,OAAA,CAAQ,kCAAkC,KAAA,EAAO;AACnD,IAAA,mBAAA,GAAsB,KAAA;AAAA,EACxB;AACA,EAAA,MAAM,UAAA,GAAc,QAAQ,oBAAA,IAAyD,MAAA;AACrF,EAAA,MAAM,SAAA,GAAY,IAAA,CAAK,GAAA,CAAI,EAAA,EAAI,IAAA,CAAK,GAAA,CAAI,GAAA,EAAK,MAAA,CAAO,OAAA,CAAQ,mBAAA,IAAuB,GAAG,CAAC,CAAC,CAAA;AACxF,EAAA,MAAM,iBAAA,GAAoB,QAAQ,2BAAA,KAAgC,IAAA;AAClE,EAAA,MAAM,WAAA,GACH,QAAQ,qBAAA,IAA2D,UAAA;AACtE,EAAA,MAAM,cAAA,GAAiB,QAAQ,wBAAA,KAA6B,IAAA;AAC5D,EAAA,MAAM,gBAAA,GAAmB,QAAQ,0BAAA,KAA+B,IAAA;AAEhE,EAAA,IAAI,CAAC,OAAA,CAAQ,UAAA,IAAc,OAAA,CAAQ,aAAa,SAAA,EAAW;AACzD,IAAA,OAAA,CAAQ,UAAA,GAAa,SAAA;AAAA,EACvB;AAEA,EAAA,OAAO;AAAA,IACL,WAAA;AAAA,IACA,UAAA;AAAA,IACA,aAAA;AAAA,IACA,iBAAA;AAAA,IACA,0BAAA;AAAA,IACA,mBAAA;AAAA,IACA,UAAA;AAAA,IACA,SAAA;AAAA,IACA,iBAAA;AAAA,IACA,WAAA;AAAA,IACA,cAAA;AAAA,IACA;AAAA,GACF;AACF;;;AC9KA,IAAM,QAAA,uBAAe,GAAA,CAAI;AAAA,EACvB,UAAA;AAAA,EACA,IAAA;AAAA,EACA,QAAA;AAAA,EACA,MAAA;AAAA,EACA,KAAA;AAAA,EACA,SAAA;AAAA,EACA,OAAA;AAAA,EACA,QAAA;AAAA,EACA,KAAA;AAAA,EACA,OAAA;AAAA,EACA,SAAA;AAAA,EACA,OAAA;AAAA,EACA;AACF,CAAC,CAAA;AAED,IAAM,WAAA,mBAAc,IAAI,GAAA,CAAI,CAAC,KAAK,GAAA,EAAK,GAAA,EAAK,GAAA,EAAK,GAAA,EAAK,GAAA,EAAK,GAAA,EAAK,GAAA,EAAK,GAAA,EAAK,GAAG,CAAC,CAAA;AAEvE,SAAS,SAAS,MAAA,EAAyB;AAChD,EAAA,MAAM,SAAkB,EAAC;AACzB,EAAA,MAAM,SAAS,MAAA,CAAO,MAAA;AACtB,EAAA,IAAI,KAAA,GAAQ,CAAA;AAEZ,EAAA,MAAM,IAAA,GAAO,CAAC,KAAA,KAAiB;AAC7B,IAAA,MAAA,CAAO,KAAK,KAAK,CAAA;AAAA,EACnB,CAAA;AAEA,EAAA,OAAO,QAAQ,MAAA,EAAQ;AACrB,IAAA,MAAM,IAAA,GAAO,OAAO,KAAK,CAAA;AACzB,IAAA,MAAM,KAAA,GAAQ,KAAA;AAEd,IAAA,IAAI,IAAA,KAAS,IAAA,IAAQ,IAAA,KAAS,IAAA,EAAM;AAClC,MAAA,IAAI,SAAS,IAAA,IAAQ,MAAA,CAAO,KAAA,GAAQ,CAAC,MAAM,IAAA,EAAM;AAC/C,QAAA,KAAA,IAAS,CAAA;AACT,QAAA,IAAA,CAAK,EAAE,MAAM,SAAA,EAAW,KAAA,EAAO,QAAQ,KAAA,EAAO,GAAA,EAAK,OAAO,CAAA;AAAA,MAC5D,CAAA,MAAO;AACL,QAAA,KAAA,IAAS,CAAA;AACT,QAAA,IAAA,CAAK,EAAE,MAAM,SAAA,EAAW,KAAA,EAAO,MAAM,KAAA,EAAO,GAAA,EAAK,OAAO,CAAA;AAAA,MAC1D;AACA,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,IAAA,KAAS,GAAA,IAAO,IAAA,KAAS,GAAA,IAAQ,SAAS,IAAA,EAAM;AAClD,MAAA,KAAA,IAAS,CAAA;AACT,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,IAAA,KAAS,OAAO,KAAA,GAAQ,CAAA,GAAI,UAAU,MAAA,CAAO,KAAA,GAAQ,CAAC,CAAA,KAAM,GAAA,EAAK;AACnE,MAAA,IAAI,cAAc,KAAA,GAAQ,CAAA;AAC1B,MAAA,OAAO,WAAA,GAAc,SAAS,CAAA,EAAG;AAC/B,QAAA,IAAI,MAAA,CAAO,WAAW,CAAA,KAAM,GAAA,IAAO,OAAO,WAAA,GAAc,CAAC,MAAM,GAAA,EAAK;AAClE,UAAA,WAAA,IAAe,CAAA;AACf,UAAA;AAAA,QACF;AACA,QAAA,WAAA,IAAe,CAAA;AAAA,MACjB;AACA,MAAA,MAAM,GAAA,GAAM,WAAA,IAAe,MAAA,GAAS,MAAA,GAAS,WAAA;AAC7C,MAAA,IAAA,CAAK,EAAE,IAAA,EAAM,eAAA,EAAiB,KAAA,EAAO,MAAA,CAAO,KAAA,CAAM,KAAA,EAAO,GAAG,CAAA,EAAG,KAAA,EAAO,GAAA,EAAK,CAAA;AAC3E,MAAA,KAAA,GAAQ,GAAA;AACR,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,SAAS,GAAA,EAAK;AAChB,MAAA,KAAA,IAAS,CAAA;AACT,MAAA,OAAO,KAAA,GAAQ,UAAU,MAAA,CAAO,KAAK,MAAM,IAAA,IAAQ,MAAA,CAAO,KAAK,CAAA,KAAM,IAAA,EAAM;AACzE,QAAA,KAAA,IAAS,CAAA;AAAA,MACX;AACA,MAAA,IAAA,CAAK,EAAE,IAAA,EAAM,SAAA,EAAW,KAAA,EAAO,OAAO,KAAA,CAAM,KAAA,GAAQ,CAAA,EAAG,KAAK,EAAE,OAAA,EAAQ,EAAG,KAAA,EAAO,GAAA,EAAK,OAAO,CAAA;AAC5F,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,SAAS,GAAA,EAAK;AAChB,MAAA,IAAI,YAAY,KAAA,GAAQ,CAAA;AACxB,MAAA,OAAO,YAAY,MAAA,IAAU,IAAA,CAAK,KAAK,MAAA,CAAO,SAAS,CAAC,CAAA,EAAG;AACzD,QAAA,SAAA,IAAa,CAAA;AAAA,MACf;AACA,MAAA,IAAI,YAAY,MAAA,IAAU,WAAA,CAAY,KAAK,MAAA,CAAO,SAAS,CAAC,CAAA,EAAG;AAC7D,QAAA,IAAI,KAAA,GAAQ,CAAA;AACZ,QAAA,IAAI,cAAc,KAAA,GAAQ,CAAA;AAC1B,QAAA,OAAO,WAAA,GAAc,MAAA,IAAU,KAAA,GAAQ,CAAA,EAAG;AACxC,UAAA,MAAM,OAAA,GAAU,OAAO,WAAW,CAAA;AAClC,UAAA,IAAI,OAAA,KAAY,GAAA,IAAQ,OAAA,KAAY,GAAA,EAAK;AACvC,YAAA,MAAM,KAAA,GAAQ,OAAA;AACd,YAAA,WAAA,IAAe,CAAA;AACf,YAAA,OAAO,cAAc,MAAA,EAAQ;AAC3B,cAAA,MAAM,EAAA,GAAK,OAAO,WAAW,CAAA;AAC7B,cAAA,IAAI,OAAO,GAAA,EAAK;AACd,gBAAA,WAAA,IAAe,CAAA;AACf,gBAAA;AAAA,cACF;AACA,cAAA,IAAI,OAAO,KAAA,EAAO;AAChB,gBAAA,WAAA,IAAe,CAAA;AACf,gBAAA;AAAA,cACF;AACA,cAAA,WAAA,IAAe,CAAA;AAAA,YACjB;AACA,YAAA;AAAA,UACF;AACA,UAAA,IAAI,YAAY,GAAA,EAAK;AACnB,YAAA,KAAA,IAAS,CAAA;AACT,YAAA,WAAA,IAAe,CAAA;AACf,YAAA;AAAA,UACF;AACA,UAAA,IAAI,YAAY,GAAA,EAAK;AACnB,YAAA,KAAA,IAAS,CAAA;AACT,YAAA,WAAA,IAAe,CAAA;AACf,YAAA,IAAI,UAAU,CAAA,EAAG;AACf,cAAA;AAAA,YACF;AACA,YAAA;AAAA,UACF;AACA,UAAA,WAAA,IAAe,CAAA;AAAA,QACjB;AACA,QAAA,MAAM,YAAA,GAAe,KAAA,KAAU,CAAA,GAAI,WAAA,GAAc,MAAA;AACjD,QAAA,IAAA,CAAK,EAAE,IAAA,EAAM,WAAA,EAAa,KAAA,EAAO,MAAA,CAAO,KAAA,CAAM,KAAA,EAAO,YAAY,CAAA,EAAG,KAAA,EAAO,GAAA,EAAK,YAAA,EAAc,CAAA;AAC9F,QAAA,KAAA,GAAQ,YAAA;AACR,QAAA;AAAA,MACF;AAAA,IACF;AAEA,IAAA,IAAI,IAAA,KAAS,GAAA,KAAQ,MAAA,CAAO,KAAA,GAAQ,CAAC,CAAA,KAAM,GAAA,IAAO,MAAA,CAAO,KAAA,GAAQ,CAAC,CAAA,KAAM,GAAA,CAAA,EAAM;AAC5E,MAAA,MAAM,SAAA,GAAY,MAAA,CAAO,KAAA,GAAQ,CAAC,CAAA;AAClC,MAAA,MAAM,KAAA,GAAQ,SAAA,KAAc,GAAA,GAAM,QAAA,GAAW,QAAA;AAC7C,MAAA,IAAI,cAAc,KAAA,GAAQ,CAAA;AAC1B,MAAA,IAAI,OAAA,GAAU,EAAA;AACd,MAAA,OAAO,WAAA,GAAc,SAAS,CAAA,EAAG;AAC/B,QAAA,IAAI,MAAA,CAAO,WAAW,CAAA,KAAM,SAAA,IAAa,OAAO,WAAA,GAAc,CAAC,MAAM,GAAA,EAAK;AACxE,UAAA,MAAM,QAAA,GAAW,MAAA,CAAO,WAAA,GAAc,CAAC,CAAA;AACvC,UAAA,MAAM,QAAA,GAAW,MAAA,CAAO,WAAA,GAAc,CAAC,CAAA;AACvC,UAAA,MAAM,kBAAA,GAAqB,gBAAgB,KAAA,GAAQ,CAAA;AACnD,UAAA,MAAM,kBAAkB,QAAA,KAAa,IAAA;AACrC,UAAA,MAAM,kBAAA,GAAqB,QAAA,KAAa,IAAA,IAAQ,QAAA,KAAa,IAAA;AAC7D,UAAA,IAAI,kBAAA,IAAsB,mBAAmB,kBAAA,EAAoB;AAC/D,YAAA,OAAA,GAAU,WAAA;AACV,YAAA;AAAA,UACF;AAAA,QACF;AACA,QAAA,WAAA,IAAe,CAAA;AAAA,MACjB;AAEA,MAAA,IAAI,GAAA,GAAM,MAAA;AAEV,MAAA,IAAI,YAAY,EAAA,EAAI;AAClB,QAAA,GAAA,GAAM,OAAA,GAAU,CAAA;AAAA,MAClB;AAEA,MAAA,IAAA,CAAK;AAAA,QACH,IAAA,EAAM,SAAA;AAAA,QACN,KAAA,EAAO,MAAA,CAAO,KAAA,CAAM,KAAA,EAAO,GAAG,CAAA;AAAA,QAC9B,KAAA;AAAA,QACA,GAAA;AAAA,QACA;AAAA,OACD,CAAA;AACD,MAAA,KAAA,GAAQ,GAAA;AACR,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,IAAA,KAAS,GAAA,IAAO,IAAA,KAAS,GAAA,EAAK;AAChC,MAAA,MAAM,KAAA,GAAQ,IAAA,KAAS,GAAA,GAAM,QAAA,GAAW,QAAA;AACxC,MAAA,KAAA,IAAS,CAAA;AACT,MAAA,IAAI,OAAA,GAAU,KAAA;AACd,MAAA,OAAO,QAAQ,MAAA,EAAQ;AACrB,QAAA,MAAM,OAAA,GAAU,OAAO,KAAK,CAAA;AAC5B,QAAA,IAAI,OAAA,EAAS;AACX,UAAA,OAAA,GAAU,KAAA;AAAA,QACZ,CAAA,MAAA,IAAW,YAAY,GAAA,EAAK;AAC1B,UAAA,OAAA,GAAU,IAAA;AAAA,QACZ,CAAA,MAAA,IAAW,YAAY,IAAA,EAAM;AAC3B,UAAA,KAAA,IAAS,CAAA;AACT,UAAA;AAAA,QACF;AACA,QAAA,KAAA,IAAS,CAAA;AAAA,MACX;AACA,MAAA,IAAA,CAAK;AAAA,QACH,IAAA,EAAM,QAAA;AAAA,QACN,KAAA,EAAO,MAAA,CAAO,KAAA,CAAM,KAAA,EAAO,KAAK,CAAA;AAAA,QAChC,KAAA;AAAA,QACA,GAAA,EAAK,KAAA;AAAA,QACL;AAAA,OACD,CAAA;AACD,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,IAAA,KAAS,GAAA,KAAQ,MAAA,CAAO,KAAA,GAAQ,CAAC,CAAA,KAAM,GAAA,IAAO,MAAA,CAAO,KAAA,GAAQ,CAAC,CAAA,KAAM,GAAA,CAAA,EAAM;AAC5E,MAAA,MAAM,KAAA,GAAQ,CAAA,CAAA,EAAI,MAAA,CAAO,KAAA,GAAQ,CAAC,CAAC,CAAA,CAAA;AACnC,MAAA,KAAA,IAAS,CAAA;AACT,MAAA,IAAA,CAAK,EAAE,IAAA,EAAM,UAAA,EAAY,OAAO,KAAA,EAAO,GAAA,EAAK,OAAO,CAAA;AACnD,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,SAAS,GAAA,IAAO,MAAA,CAAO,KAAA,GAAQ,CAAC,MAAM,GAAA,EAAK;AAC7C,MAAA,KAAA,IAAS,CAAA;AACT,MAAA,IAAA,CAAK,EAAE,MAAM,UAAA,EAAY,KAAA,EAAO,MAAM,KAAA,EAAO,GAAA,EAAK,OAAO,CAAA;AACzD,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,WAAA,CAAY,GAAA,CAAI,IAAI,CAAA,EAAG;AACzB,MAAA,KAAA,IAAS,CAAA;AACT,MAAA,IAAA,CAAK,EAAE,MAAM,aAAA,EAAe,KAAA,EAAO,MAAM,KAAA,EAAO,GAAA,EAAK,OAAO,CAAA;AAC5D,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,IAAA,KAAS,GAAA,IAAO,IAAA,KAAS,GAAA,EAAK;AAChC,MAAA,IAAI,KAAA,GAAQ,IAAA;AACZ,MAAA,IAAI,MAAA,CAAO,KAAA,GAAQ,CAAC,CAAA,KAAM,IAAA,EAAM;AAC9B,QAAA,KAAA,IAAS,IAAA;AACT,QAAA,KAAA,IAAS,CAAA;AAAA,MACX,CAAA,MAAO;AACL,QAAA,KAAA,IAAS,CAAA;AAAA,MACX;AACA,MAAA,IAAA,CAAK,EAAE,IAAA,EAAM,UAAA,EAAY,OAAO,KAAA,EAAO,GAAA,EAAK,OAAO,CAAA;AACnD,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,IAAA,KAAS,GAAA,IAAO,IAAA,KAAS,GAAA,EAAK;AAChC,MAAA,IAAI,KAAA,GAAQ,IAAA;AACZ,MAAA,IAAI,MAAA,CAAO,KAAA,GAAQ,CAAC,CAAA,KAAM,IAAA,EAAM;AAC9B,QAAA,KAAA,IAAS,IAAA;AACT,QAAA,KAAA,IAAS,CAAA;AAAA,MACX,CAAA,MAAO;AACL,QAAA,KAAA,IAAS,CAAA;AAAA,MACX;AACA,MAAA,IAAA,CAAK,EAAE,IAAA,EAAM,UAAA,EAAY,OAAO,KAAA,EAAO,GAAA,EAAK,OAAO,CAAA;AACnD,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,SAAS,GAAA,EAAK;AAChB,MAAA,KAAA,IAAS,CAAA;AACT,MAAA,OAAO,QAAQ,MAAA,EAAQ;AACrB,QAAA,MAAM,CAAA,GAAI,OAAO,KAAK,CAAA;AACtB,QAAA,IAAI,kBAAA,CAAmB,IAAA,CAAK,CAAC,CAAA,EAAG;AAC9B,UAAA,KAAA,IAAS,CAAA;AACT,UAAA;AAAA,QACF;AACA,QAAA,IAAI,MAAM,GAAA,EAAK;AACb,UAAA,KAAA,IAAS,CAAA;AACT,UAAA,OAAO,KAAA,GAAQ,MAAA,IAAU,MAAA,CAAO,KAAK,MAAM,GAAA,EAAK;AAC9C,YAAA,KAAA,IAAS,CAAA;AAAA,UACX;AACA,UAAA,IAAI,MAAA,CAAO,KAAK,CAAA,KAAM,GAAA,EAAK;AACzB,YAAA,KAAA,IAAS,CAAA;AAAA,UACX;AACA,UAAA;AAAA,QACF;AACA,QAAA;AAAA,MACF;AACA,MAAA,IAAA,CAAK,EAAE,IAAA,EAAM,UAAA,EAAY,KAAA,EAAO,MAAA,CAAO,KAAA,CAAM,KAAA,EAAO,KAAK,CAAA,EAAG,KAAA,EAAO,GAAA,EAAK,KAAA,EAAO,CAAA;AAC/E,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,OAAA,CAAQ,IAAA,CAAK,IAAI,CAAA,EAAG;AACtB,MAAA,KAAA,IAAS,CAAA;AACT,MAAA,OAAO,QAAQ,MAAA,IAAU,OAAA,CAAQ,KAAK,MAAA,CAAO,KAAK,CAAC,CAAA,EAAG;AACpD,QAAA,KAAA,IAAS,CAAA;AAAA,MACX;AACA,MAAA,IAAI,MAAA,CAAO,KAAK,CAAA,KAAM,GAAA,IAAO,OAAA,CAAQ,KAAK,MAAA,CAAO,KAAA,GAAQ,CAAC,CAAC,CAAA,EAAG;AAC5D,QAAA,KAAA,IAAS,CAAA;AACT,QAAA,OAAO,QAAQ,MAAA,IAAU,OAAA,CAAQ,KAAK,MAAA,CAAO,KAAK,CAAC,CAAA,EAAG;AACpD,UAAA,KAAA,IAAS,CAAA;AAAA,QACX;AAAA,MACF;AACA,MAAA,IAAA,CAAK,EAAE,IAAA,EAAM,QAAA,EAAU,KAAA,EAAO,MAAA,CAAO,KAAA,CAAM,KAAA,EAAO,KAAK,CAAA,EAAG,KAAA,EAAO,GAAA,EAAK,KAAA,EAAO,CAAA;AAC7E,MAAA;AAAA,IACF;AAEA,IAAA,IACE,WAAA,CAAY,IAAA,CAAK,IAAI,CAAA,IACpB,SAAS,GAAA,IAAO,KAAA,GAAQ,CAAA,GAAI,MAAA,IAAU,YAAY,IAAA,CAAK,MAAA,CAAO,KAAA,GAAQ,CAAC,CAAC,CAAA,EACzE;AACA,MAAA,KAAA,IAAS,CAAA;AACT,MAAA,OAAO,QAAQ,MAAA,IAAU,eAAA,CAAgB,KAAK,MAAA,CAAO,KAAK,CAAC,CAAA,EAAG;AAC5D,QAAA,KAAA,IAAS,CAAA;AAAA,MACX;AACA,MAAA,MAAM,GAAA,GAAM,MAAA,CAAO,KAAA,CAAM,KAAA,EAAO,KAAK,CAAA;AACrC,MAAA,MAAM,KAAA,GAAQ,IAAI,WAAA,EAAY;AAC9B,MAAA,IAAI,QAAA,CAAS,GAAA,CAAI,KAAK,CAAA,EAAG;AACvB,QAAA,IAAA,CAAK,EAAE,MAAM,SAAA,EAAW,KAAA,EAAO,KAAK,KAAA,EAAO,GAAA,EAAK,OAAO,CAAA;AAAA,MACzD,CAAA,MAAO;AACL,QAAA,IAAA,CAAK,EAAE,MAAM,YAAA,EAAc,KAAA,EAAO,KAAK,KAAA,EAAO,GAAA,EAAK,OAAO,CAAA;AAAA,MAC5D;AACA,MAAA;AAAA,IACF;AAGA,IAAA,KAAA,IAAS,CAAA;AACT,IAAA,IAAA,CAAK,EAAE,MAAM,SAAA,EAAW,KAAA,EAAO,MAAM,KAAA,EAAO,GAAA,EAAK,OAAO,CAAA;AAAA,EAC1D;AAEA,EAAA,OAAO,MAAA;AACT;;;ACnSA,IAAM,MAAA,GAAN,MAAM,OAAA,CAAO;AAAA,EAGX,WAAA,CACmB,QACA,MAAA,EACjB;AAFiB,IAAA,IAAA,CAAA,MAAA,GAAA,MAAA;AACA,IAAA,IAAA,CAAA,MAAA,GAAA,MAAA;AAJnB,IAAA,IAAA,CAAQ,KAAA,GAAQ,CAAA;AAAA,EAKb;AAAA,EAEH,WAAA,CAAY,WAAA,mBAA2B,IAAI,GAAA,EAAI,EAAe;AAC5D,IAAA,MAAM,OAAyB,EAAC;AAChC,IAAA,MAAM,KAAA,GAAQ,KAAK,MAAA,CAAO,MAAA,GAAS,IAAI,IAAA,CAAK,MAAA,CAAO,CAAC,CAAA,CAAE,KAAA,GAAQ,CAAA;AAE9D,IAAA,OAAO,CAAC,IAAA,CAAK,KAAA,EAAM,EAAG;AACpB,MAAA,MAAM,KAAA,GAAQ,KAAK,IAAA,EAAK;AAExB,MAAA,IAAI,YAAY,GAAA,CAAI,KAAA,CAAM,KAAK,CAAA,IAAK,KAAA,CAAM,SAAS,aAAA,EAAe;AAChE,QAAA;AAAA,MACF;AAEA,MAAA,IAAI,KAAA,CAAM,SAAS,SAAA,EAAW;AAC5B,QAAA,MAAM,KAAA,GAAQ,KAAK,iBAAA,EAAkB;AACrC,QAAA,IAAA,CAAK,KAAK,KAAK,CAAA;AACf,QAAA;AAAA,MACF;AAEA,MAAA,IAAI,KAAA,CAAM,IAAA,KAAS,SAAA,IAAa,KAAA,CAAM,SAAS,eAAA,EAAiB;AAC9D,QAAA,MAAM,YAAA,GAAe,KAAK,OAAA,EAAQ;AAClC,QAAA,MAAM,WAAA,GAAc,IAAA,CAAK,iBAAA,CAAkB,YAAA,EAAc,KAAK,CAAA;AAC9D,QAAA,IAAI,IAAA,CAAK,SAAS,CAAA,EAAG;AACnB,UAAA,MAAM,YAAA,GAAe,IAAA,CAAK,IAAA,CAAK,MAAA,GAAS,CAAC,CAAA;AACzC,UAAA,IAAI,SAAA,GAAY,CAAA;AAChB,UAAA,IAAI,SAAA;AACJ,UAAA,OAAO,IAAA,EAAM;AACX,YAAA,SAAA,GAAY,IAAA,CAAK,KAAK,SAAS,CAAA;AAC/B,YAAA,IAAI,CAAC,SAAA,EAAW;AACd,cAAA;AAAA,YACF;AACA,YAAA,IAAI,SAAA,CAAU,SAAS,SAAA,EAAW;AAChC,cAAA,SAAA,IAAa,CAAA;AACb,cAAA;AAAA,YACF;AACA,YAAA;AAAA,UACF;AACA,UAAA,IAAI,YAAA,CAAa,SAAS,UAAA,EAAY;AACpC,YAAA,MAAM,cAAc,YAAA,CAAa,QAAA,CAAS,YAAA,CAAa,QAAA,CAAS,SAAS,CAAC,CAAA;AAC1E,YAAA,MAAM,WAAW,WAAA,EAAa,KAAA,CAAM,WAAA,CAAY,KAAA,CAAM,SAAS,CAAC,CAAA;AAChE,YAAA,MAAM,cAAA,GAAiB,OAAA;AAAA,cACrB,QAAA,IACA,QAAA,CAAS,IAAA,KAAS,aAAA,KACjB,YAAY,GAAA,CAAI,KAAA,GAAQ,QAAA,CAAS,GAAA,CAAI,OACnC,SAAA,IAAa,SAAA,CAAU,IAAA,KAAS,aAAA,IAAiB,UAAU,KAAA,KAAU,GAAA;AAAA,aAC1E;AACA,YAAA,IAAI,cAAA,IAAkB,QAAA,IAAY,QAAA,CAAS,IAAA,KAAS,aAAA,EAAe;AACjE,cAAA,QAAA,CAAS,IAAA,GAAO,CAAC,GAAG,QAAA,CAAS,MAAM,WAAW,CAAA;AAC9C,cAAA;AAAA,YACF;AAAA,UACF;AACA,UAAA,IACE,YAAA,CAAa,IAAA,KAAS,aAAA,KACrB,WAAA,CAAY,IAAI,KAAA,GAAQ,YAAA,CAAa,GAAA,CAAI,GAAA,IACvC,aAAa,SAAA,CAAU,IAAA,KAAS,aAAA,IAAiB,SAAA,CAAU,UAAU,GAAA,CAAA,EACxE;AACA,YAAA,YAAA,CAAa,IAAA,GAAO,CAAC,GAAG,YAAA,CAAa,MAAM,WAAW,CAAA;AACtD,YAAA;AAAA,UACF;AAAA,QACF;AACA,QAAA,IAAA,CAAK,KAAK,WAAW,CAAA;AACrB,QAAA;AAAA,MACF;AAEA,MAAA,IAAI,IAAA,CAAK,uBAAsB,EAAG;AAChC,QAAA,IAAA,CAAK,IAAA,CAAK,IAAA,CAAK,aAAA,EAAe,CAAA;AAC9B,QAAA;AAAA,MACF;AAEA,MAAA,MAAM,SAAA,GAAY,KAAK,cAAA,EAAe;AACtC,MAAA,IAAI,SAAA,EAAW;AACb,QAAA,IAAA,CAAK,KAAK,SAAS,CAAA;AAAA,MACrB,CAAA,MAAO;AAEL,QAAA,IAAA,CAAK,OAAA,EAAQ;AAAA,MACf;AAAA,IACF;AAEA,IAAA,MAAM,GAAA,GAAM,IAAA,CAAK,MAAA,GAAS,CAAA,GAAI,IAAA,CAAK,KAAK,MAAA,GAAS,CAAC,CAAA,CAAE,GAAA,CAAI,GAAA,GAAM,KAAA;AAC9D,IAAA,OAAO;AAAA,MACL,IAAA,EAAM,QAAA;AAAA,MACN,IAAA;AAAA,MACA,GAAA,EAAK,EAAE,KAAA,EAAO,GAAA;AAAI,KACpB;AAAA,EACF;AAAA,EAEQ,aAAA,GAAyC;AAC/C,IAAA,MAAM,UAAA,GAAa,KAAK,OAAA,EAAQ;AAChC,IAAA,MAAM,YAAA,GAAwB,CAAC,UAAU,CAAA;AAEzC,IAAA,OAAO,CAAC,IAAA,CAAK,KAAA,EAAM,EAAG;AACpB,MAAA,MAAM,KAAA,GAAQ,KAAK,IAAA,EAAK;AACxB,MAAA,IAAI,KAAA,CAAM,SAAS,SAAA,EAAW;AAC5B,QAAA;AAAA,MACF;AACA,MAAA,IAAI,KAAA,CAAM,IAAA,KAAS,aAAA,IAAiB,KAAA,CAAM,UAAU,GAAA,EAAK;AACvD,QAAA;AAAA,MACF;AACA,MAAA,YAAA,CAAa,IAAA,CAAK,IAAA,CAAK,OAAA,EAAS,CAAA;AAAA,IAClC;AAEA,IAAA,MAAM,gBAAA,GAAmB,yBAAA,CAA0B,YAAA,EAAc,IAAA,CAAK,MAAM,CAAA;AAC5E,IAAA,MAAM,IAAA,GAAO,KAAK,gBAAA,EAAiB;AACnC,IAAA,MAAM,GAAA,GAAM,KAAK,GAAA,CAAI,GAAA;AAErB,IAAA,OAAO;AAAA,MACL,IAAA,EAAM,qBAAA;AAAA,MACN,MAAA,EAAQ,gBAAA;AAAA,MACR,IAAA;AAAA,MACA,GAAA,EAAK,EAAE,KAAA,EAAO,UAAA,CAAW,OAAO,GAAA;AAAI,KACtC;AAAA,EACF;AAAA,EAEQ,cAAA,GAAsC;AAC5C,IAAA,MAAM,QAAA,GAAsB,CAAC,EAAE,CAAA;AAC/B,IAAA,IAAI,eAAA;AAEJ,IAAA,MAAM,iBAA2B,EAAC;AAClC,IAAA,IAAI,gBAAA,GAAmB,KAAA;AAEvB,IAAA,OAAO,CAAC,IAAA,CAAK,KAAA,EAAM,EAAG;AACpB,MAAA,MAAM,KAAA,GAAQ,KAAK,IAAA,EAAK;AAExB,MAAA,IAAI,KAAA,CAAM,SAAS,SAAA,EAAW;AAC5B,QAAA,IAAI,gBAAA,EAAkB;AACpB,UAAA,IAAA,CAAK,OAAA,EAAQ;AACb,UAAA,gBAAA,GAAmB,KAAA;AACnB,UAAA;AAAA,QACF;AAEA,QAAA,IAAI,cAAA,CAAe,SAAS,CAAA,EAAG;AAC7B,UAAA,MAAM,YAAA,GAAe,KAAK,OAAA,EAAQ;AAClC,UAAA,QAAA,CAAS,QAAA,CAAS,MAAA,GAAS,CAAC,CAAA,CAAE,KAAK,YAAY,CAAA;AAC/C,UAAA;AAAA,QACF;AACA,QAAA,IAAI,cAAA,CAAe,MAAA,KAAW,CAAA,IAAK,IAAA,CAAK,oCAAmC,EAAG;AAC5E,UAAA,IAAA,CAAK,OAAA,EAAQ;AACb,UAAA;AAAA,QACF;AACA,QAAA;AAAA,MACF;AAEA,MAAA,IAAI,KAAA,CAAM,SAAS,aAAA,IAAiB,KAAA,CAAM,UAAU,GAAA,IAAO,cAAA,CAAe,WAAW,CAAA,EAAG;AACtF,QAAA,IAAA,CAAK,OAAA,EAAQ;AACb,QAAA;AAAA,MACF;AAEA,MAAA,IAAI,KAAA,CAAM,SAAS,aAAA,IAAiB,KAAA,CAAM,UAAU,GAAA,IAAO,cAAA,CAAe,WAAW,CAAA,EAAG;AACtF,QAAA;AAAA,MACF;AAEA,MAAA,IAAI,KAAA,CAAM,SAAS,SAAA,EAAW;AAC5B,QAAA,IAAI,IAAA,CAAK,eAAA,CAAgB,KAAK,CAAA,EAAG;AAC/B,UAAA,eAAA,GAAkB,IAAA,CAAK,iBAAA,CAAkB,IAAA,CAAK,OAAA,IAAW,IAAI,CAAA;AAAA,QAC/D;AACA,QAAA;AAAA,MACF;AAEA,MAAA,IAAI,KAAA,CAAM,SAAS,eAAA,EAAiB;AAClC,QAAA;AAAA,MACF;AAEA,MAAA,IAAI,KAAA,CAAM,IAAA,KAAS,UAAA,IAAc,KAAA,CAAM,UAAU,GAAA,EAAK;AACpD,QAAA,IAAA,CAAK,OAAA,EAAQ;AACb,QAAA,QAAA,CAAS,IAAA,CAAK,EAAE,CAAA;AAChB,QAAA,gBAAA,GAAmB,KAAA;AACnB,QAAA;AAAA,MACF;AAGA,MAAA,IAAI,KAAA,CAAM,IAAA,KAAS,SAAA,IAAa,KAAA,CAAM,UAAU,GAAA,EAAK;AACnD,QAAA,IAAA,CAAK,OAAA,EAAQ;AACb,QAAA,gBAAA,GAAmB,IAAA;AACnB,QAAA;AAAA,MACF;AAEA,MAAA,MAAM,cAAA,GAAiB,QAAA,CAAS,QAAA,CAAS,MAAA,GAAS,CAAC,CAAA;AACnD,MAAA,cAAA,CAAe,IAAA,CAAK,IAAA,CAAK,OAAA,EAAS,CAAA;AAClC,MAAA,gBAAA,GAAmB,KAAA;AAEnB,MAAA,IAAI,cAAA,CAAe,KAAK,CAAA,EAAG;AACzB,QAAA,cAAA,CAAe,IAAA,CAAK,MAAM,KAAK,CAAA;AAAA,MACjC,CAAA,MAAA,IAAW,cAAA,CAAe,KAAK,CAAA,EAAG;AAChC,QAAA,cAAA,CAAe,GAAA,EAAI;AAAA,MACrB;AAAA,IACF;AAEA,IAAA,MAAM,mBAAmB,QAAA,CAAS,MAAA,CAAO,CAAC,OAAA,KAAY,OAAA,CAAQ,SAAS,CAAC,CAAA;AACxE,IAAA,IAAI,gBAAA,CAAiB,WAAW,CAAA,EAAG;AACjC,MAAA,OAAO,IAAA;AAAA,IACT;AAEA,IAAA,MAAM,qBAAqB,gBAAA,CAAiB,GAAA;AAAA,MAAI,CAAC,aAAA,KAC/C,yBAAA,CAA0B,aAAA,EAAe,KAAK,MAAM;AAAA,KACtD;AACE,IAAA,MAAM,KAAA,GAAQ,kBAAA,CAAmB,CAAC,CAAA,CAAE,GAAA,CAAI,KAAA;AAC1C,IAAA,MAAM,MAAM,kBAAA,CAAmB,kBAAA,CAAmB,MAAA,GAAS,CAAC,EAAE,GAAA,CAAI,GAAA;AAElE,IAAA,MAAM,YAAA,GAA6B;AAAA,MACjC,IAAA,EAAM,UAAA;AAAA,MACN,QAAA,EAAU,kBAAA;AAAA,MACR,GAAA,EAAK,EAAE,KAAA,EAAO,GAAA;AAAI,KACtB;AAEA,IAAA,IAAI,eAAA,EAAiB;AACnB,MAAA,YAAA,CAAa,eAAA,GAAkB,eAAA;AAAA,IACjC;AAEA,IAAA,OAAO,YAAA;AAAA,EACT;AAAA,EAEQ,gBAAA,GAAoC;AAC1C,IAAA,MAAM,SAAA,GAAY,KAAK,IAAA,EAAK;AAC5B,IAAA,IAAI,CAAC,SAAA,IAAa,SAAA,CAAU,SAAS,aAAA,IAAiB,SAAA,CAAU,UAAU,GAAA,EAAK;AAC7E,MAAA,OAAO;AAAA,QACL,IAAA,EAAM,aAAA;AAAA,QACN,MAAM,EAAC;AAAA,QACP,GAAA,EAAK,EAAE,KAAA,EAAO,SAAA,EAAW,SAAS,CAAA,EAAG,GAAA,EAAK,SAAA,EAAW,GAAA,IAAO,CAAA;AAAE,OAChE;AAAA,IACF;AACA,IAAA,IAAA,CAAK,OAAA,EAAQ;AAEb,IAAA,MAAM,EAAE,aAAA,EAAe,YAAA,EAAa,GAAI,IAAA,CAAK,sBAAsB,SAAS,CAAA;AAC5E,IAAA,MAAM,YAAA,GAAe,IAAI,OAAA,CAAO,aAAA,EAAe,KAAK,MAAM,CAAA;AAC1D,IAAA,MAAM,MAAA,GAAS,YAAA,CAAa,WAAA,iBAAY,IAAI,KAAK,CAAA;AACjD,IAAA,MAAM,GAAA,GAAM,YAAA,EAAc,GAAA,IAAO,SAAA,CAAU,GAAA;AAE3C,IAAA,OAAO;AAAA,MACL,IAAA,EAAM,aAAA;AAAA,MACN,MAAM,MAAA,CAAO,IAAA;AAAA,MACb,GAAA,EAAK,EAAE,KAAA,EAAO,SAAA,CAAU,OAAO,GAAA;AAAI,KACrC;AAAA,EACF;AAAA,EAEQ,sBAAsB,UAAA,EAG5B;AACA,IAAA,MAAM,gBAAyB,EAAC;AAChC,IAAA,MAAM,KAAA,GAAkB,CAAC,UAAA,CAAW,KAAK,CAAA;AAEzC,IAAA,OAAO,CAAC,IAAA,CAAK,KAAA,EAAM,EAAG;AACpB,MAAA,MAAM,KAAA,GAAQ,KAAK,OAAA,EAAQ;AAE3B,MAAA,IAAI,cAAA,CAAe,KAAK,CAAA,EAAG;AACzB,QAAA,KAAA,CAAM,IAAA,CAAK,MAAM,KAAK,CAAA;AACtB,QAAA,aAAA,CAAc,KAAK,KAAK,CAAA;AACxB,QAAA;AAAA,MACF;AAEA,MAAA,IAAI,cAAA,CAAe,KAAK,CAAA,EAAG;AACzB,QAAA,IAAI,KAAA,CAAM,UAAU,CAAA,EAAG;AACrB,UAAA,OAAO,EAAE,aAAA,EAAe,YAAA,EAAc,KAAA,EAAM;AAAA,QAC9C;AACA,QAAA,KAAA,CAAM,GAAA,EAAI;AACV,QAAA,aAAA,CAAc,KAAK,KAAK,CAAA;AACxB,QAAA;AAAA,MACF;AAEA,MAAA,aAAA,CAAc,KAAK,KAAK,CAAA;AAAA,IAC1B;AAEA,IAAA,OAAO,EAAE,aAAA,EAAc;AAAA,EACzB;AAAA,EAEQ,iBAAA,GAAmC;AACzC,IAAA,IAAI,KAAA,GAAQ,CAAA;AACZ,IAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,IAAA,EAAK,CAAG,KAAA;AAC3B,IAAA,IAAI,GAAA,GAAM,KAAA;AACV,IAAA,OAAO,CAAC,IAAA,CAAK,KAAA,EAAM,EAAG;AACpB,MAAA,MAAM,KAAA,GAAQ,KAAK,IAAA,EAAK;AACxB,MAAA,IAAI,CAAC,KAAA,IAAS,KAAA,CAAM,IAAA,KAAS,SAAA,EAAW;AACtC,QAAA;AAAA,MACF;AACA,MAAA,MAAM,OAAA,GAAU,KAAK,OAAA,EAAQ;AAC7B,MAAA,KAAA,IAAS,CAAA;AACT,MAAA,GAAA,GAAM,OAAA,CAAQ,GAAA;AAAA,IAChB;AACA,IAAA,OAAO;AAAA,MACL,IAAA,EAAM,WAAA;AAAA,MACN,KAAA;AAAA,MACA,GAAA,EAAK,EAAE,KAAA,EAAO,GAAA;AAAI,KACpB;AAAA,EACF;AAAA,EAEQ,iBAAA,CAAkB,OAAc,MAAA,EAA8B;AACpE,IAAA,MAAM,KAAA,GAAQ,KAAA,CAAM,IAAA,KAAS,eAAA,GAAkB,OAAA,GAAU,MAAA;AACzD,IAAA,MAAM,WAAW,KAAA,KAAU,MAAA,IAAU,MAAA,IAAU,IAAA,CAAK,gBAAgB,KAAK,CAAA;AAEzE,IAAA,OAAO;AAAA,MACL,IAAA,EAAM,SAAA;AAAA,MACN,OAAO,KAAA,CAAM,KAAA;AAAA,MACb,MAAA,EAAQ,QAAA;AAAA,MACR,KAAA;AAAA,MACA,KAAK,EAAE,KAAA,EAAO,MAAM,KAAA,EAAO,GAAA,EAAK,MAAM,GAAA;AAAI,KAC5C;AAAA,EACF;AAAA,EAEQ,gBAAgB,KAAA,EAAuB;AAC7C,IAAA,IAAI,KAAA,CAAM,SAAS,SAAA,EAAW;AAC5B,MAAA,OAAO,KAAA;AAAA,IACT;AACA,IAAA,IAAI,KAAK,MAAA,CAAO,MAAA,KAAW,CAAA,IAAK,KAAA,CAAM,UAAU,CAAA,EAAG;AACjD,MAAA,OAAO,IAAA;AAAA,IACT;AAEA,IAAA,IAAI,MAAA,GAAS,MAAM,KAAA,GAAQ,CAAA;AAC3B,IAAA,OAAO,UAAU,CAAA,EAAG;AAClB,MAAA,MAAM,IAAA,GAAO,IAAA,CAAK,MAAA,CAAO,MAAM,CAAA;AAC/B,MAAA,IAAI,SAAS,IAAA,EAAM;AACjB,QAAA,OAAO,KAAA;AAAA,MACT;AACA,MAAA,IAAI,SAAS,IAAA,EAAM;AACjB,QAAA,OAAO,KAAA;AAAA,MACT;AACA,MAAA,IAAI,CAAC,IAAA,CAAK,IAAA,CAAK,IAAI,CAAA,EAAG;AACpB,QAAA,OAAO,IAAA;AAAA,MACT;AACA,MAAA,MAAA,IAAU,CAAA;AAAA,IACZ;AAEA,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEQ,kCAAA,GAA8C;AACpD,IAAA,IAAI,MAAA,GAAS,CAAA;AACb,IAAA,OAAO,IAAA,EAAM;AACX,MAAA,MAAM,IAAA,GAAO,IAAA,CAAK,IAAA,CAAK,MAAM,CAAA;AAC7B,MAAA,IAAI,CAAC,IAAA,EAAM;AACT,QAAA,OAAO,KAAA;AAAA,MACT;AACA,MAAA,IAAI,IAAA,CAAK,SAAS,SAAA,EAAW;AAC3B,QAAA,MAAA,IAAU,CAAA;AACV,QAAA;AAAA,MACF;AACA,MAAA,IAAI,IAAA,CAAK,SAAS,SAAA,EAAW;AAC3B,QAAA,OAAO,KAAA;AAAA,MACT;AACA,MAAA,IAAI,IAAA,CAAK,IAAA,KAAS,UAAA,IAAc,IAAA,CAAK,UAAU,GAAA,EAAK;AAClD,QAAA,OAAO,IAAA;AAAA,MACT;AACA,MAAA,OAAO,KAAA;AAAA,IACT;AAAA,EACF;AAAA,EAEQ,qBAAA,GAAiC;AACvC,IAAA,MAAM,KAAA,GAAQ,KAAK,IAAA,EAAK;AACxB,IAAA,OAAO,OAAA,CAAQ,SAAS,KAAA,CAAM,IAAA,KAAS,aAAa,KAAA,CAAM,KAAA,CAAM,WAAA,EAAY,KAAM,UAAU,CAAA;AAAA,EAC9F;AAAA,EAEQ,IAAA,CAAK,SAAS,CAAA,EAAsB;AAC1C,IAAA,OAAO,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,KAAA,GAAQ,MAAM,CAAA;AAAA,EACxC;AAAA,EAEQ,OAAA,GAAiB;AACvB,IAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,KAAK,CAAA;AACpC,IAAA,IAAA,CAAK,KAAA,IAAS,CAAA;AACd,IAAA,OAAO,KAAA;AAAA,EACT;AAAA,EAEQ,KAAA,GAAiB;AACvB,IAAA,OAAO,IAAA,CAAK,KAAA,IAAS,IAAA,CAAK,MAAA,CAAO,MAAA;AAAA,EACnC;AACF,CAAA;AAEA,SAAS,eAAe,KAAA,EAAuB;AAC7C,EAAA,IAAI,KAAA,CAAM,SAAS,UAAA,EAAY;AAC7B,IAAA,OAAO,KAAA,CAAM,KAAA,KAAU,IAAA,IAAQ,KAAA,CAAM,KAAA,KAAU,IAAA;AAAA,EACjD;AACA,EAAA,OACE,KAAA,CAAM,IAAA,KAAS,aAAA,KACd,KAAA,CAAM,KAAA,KAAU,OAAO,KAAA,CAAM,KAAA,KAAU,GAAA,IAAO,KAAA,CAAM,KAAA,KAAU,GAAA,CAAA;AAEnE;AAEA,SAAS,eAAe,KAAA,EAAuB;AAC7C,EAAA,OACE,KAAA,CAAM,IAAA,KAAS,aAAA,KACd,KAAA,CAAM,KAAA,KAAU,OAAO,KAAA,CAAM,KAAA,KAAU,GAAA,IAAO,KAAA,CAAM,KAAA,KAAU,GAAA,CAAA;AAEnE;AAEA,SAAS,yBAAA,CAA0B,MAAA,EAAiB,MAAA,GAAiB,EAAA,EAAoB;AACvF,EAAA,MAAM,aAAa,MAAA,CAAO,IAAA,CAAK,CAAC,KAAA,KAAU,KAAA,CAAM,SAAS,SAAS,CAAA;AAClE,EAAA,MAAM,SAAA,GAAY,CAAC,GAAG,MAAM,CAAA,CAAE,OAAA,EAAQ,CAAE,IAAA,CAAK,CAAC,KAAA,KAAU,KAAA,CAAM,IAAA,KAAS,SAAS,CAAA;AAChF,EAAA,IAAI,CAAC,UAAA,IAAc,CAAC,SAAA,EAAW;AAC7B,IAAA,OAAO;AAAA,MACL,IAAA,EAAM,YAAA;AAAA,MACN,OAAO,EAAC;AAAA,MACR,GAAA,EAAK,EAAE,KAAA,EAAO,MAAA,CAAO,CAAC,CAAA,EAAG,KAAA,IAAS,CAAA,EAAG,GAAA,EAAK,OAAO,MAAA,CAAO,MAAA,GAAS,CAAC,CAAA,EAAG,OAAO,CAAA;AAAE,KAChF;AAAA,EACF;AAEA,EAAA,MAAM,QAA8B,EAAC;AACrC,EAAA,IAAI,KAAA,GAAQ,CAAA;AAEZ,EAAA,OAAO,KAAA,GAAQ,OAAO,MAAA,EAAQ;AAC5B,IAAA,MAAM,KAAA,GAAQ,OAAO,KAAK,CAAA;AAE1B,IAAA,IAAI,KAAA,CAAM,SAAS,SAAA,EAAW;AAC5B,MAAA,KAAA,IAAS,CAAA;AACT,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,KAAA,CAAM,IAAA,KAAS,UAAA,IAAc,KAAA,CAAM,UAAU,IAAA,EAAM;AACrD,MAAA,MAAM,EAAE,IAAA,EAAM,SAAA,KAAc,kBAAA,CAAmB,MAAA,EAAQ,OAAO,MAAM,CAAA;AACpE,MAAA,KAAA,CAAM,KAAK,IAAI,CAAA;AACf,MAAA,KAAA,GAAQ,SAAA;AACR,MAAA;AAAA,IACF;AAEA,IAAA,IACG,KAAA,CAAM,IAAA,KAAS,UAAA,IAAc,KAAA,CAAM,KAAA,KAAU,IAAA,IAC7C,KAAA,CAAM,IAAA,KAAS,aAAA,IAAiB,KAAA,CAAM,KAAA,KAAU,GAAA,EACjD;AACA,MAAA,MAAM,EAAE,IAAA,EAAM,SAAA,KAAc,cAAA,CAAe,MAAA,EAAQ,OAAO,MAAM,CAAA;AAChE,MAAA,KAAA,CAAM,KAAK,IAAI,CAAA;AACf,MAAA,KAAA,GAAQ,SAAA;AACR,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,KAAA,CAAM,IAAA,KAAS,aAAA,IAAiB,KAAA,CAAM,UAAU,GAAA,EAAK;AACvD,MAAA,MAAM,EAAE,IAAA,EAAM,SAAA,KAAc,oBAAA,CAAqB,MAAA,EAAQ,OAAO,MAAM,CAAA;AACtE,MAAA,KAAA,CAAM,KAAK,IAAI,CAAA;AACf,MAAA,KAAA,GAAQ,SAAA;AACR,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,KAAA,CAAM,IAAA,KAAS,aAAA,IAAiB,KAAA,CAAM,UAAU,GAAA,EAAK;AACvD,MAAA,MAAM,EAAE,IAAA,EAAM,SAAA,KAAc,oBAAA,CAAqB,MAAA,EAAQ,OAAO,MAAM,CAAA;AACtE,MAAA,KAAA,CAAM,KAAK,IAAI,CAAA;AACf,MAAA,KAAA,GAAQ,SAAA;AACR,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,KAAA,CAAM,SAAS,SAAA,EAAW;AAC5B,MAAA,KAAA,CAAM,IAAA,CAAK,oBAAA,CAAqB,KAAK,CAAC,CAAA;AACtC,MAAA,KAAA,IAAS,CAAA;AACT,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,KAAA,CAAM,SAAS,WAAA,EAAa;AAC9B,MAAA,KAAA,CAAM,IAAA,CAAK,cAAA,CAAe,KAAK,CAAC,CAAA;AAChC,MAAA,KAAA,IAAS,CAAA;AACT,MAAA;AAAA,IACF;AAEA,IAAA,KAAA,CAAM,IAAA,CAAK,cAAA,CAAe,KAAK,CAAC,CAAA;AAChC,IAAA,KAAA,IAAS,CAAA;AAAA,EACX;AAEA,EAAA,OAAO;AAAA,IACL,IAAA,EAAM,YAAA;AAAA,IACN,KAAA;AAAA,IACA,GAAA,EAAK;AAAA,MACH,OAAO,UAAA,CAAW,KAAA;AAAA,MAClB,KAAK,SAAA,CAAU;AAAA;AACjB,GACF;AACF;AAEA,SAAS,kBAAA,CACP,MAAA,EACA,UAAA,EACA,MAAA,GAAiB,EAAA,EAC2B;AAC5C,EAAA,MAAM,UAAA,GAAa,OAAO,UAAU,CAAA;AACpC,EAAA,MAAM,EAAE,aAAA,EAAe,QAAA,EAAU,cAAa,GAAI,sBAAA,CAAuB,QAAQ,UAAU,CAAA;AAC3F,EAAA,MAAM,OAAA,GAAU,qBAAA,CAAsB,aAAa,CAAA,CAAE,GAAA;AAAA,IAAI,CAAC,WAAA,KACxD,mBAAA,CAAoB,WAAA,EAAa,MAAM;AAAA,GACzC;AACA,EAAA,MAAM,GAAA,GAAM,cAAc,GAAA,IAAO,aAAA,CAAc,cAAc,MAAA,GAAS,CAAC,CAAA,EAAG,GAAA,IAAO,UAAA,CAAW,GAAA;AAC5F,EAAA,OAAO;AAAA,IACL,IAAA,EAAM;AAAA,MACJ,IAAA,EAAM,WAAA;AAAA,MACN,OAAA;AAAA,MACA,GAAA,EAAK,EAAE,KAAA,EAAO,UAAA,CAAW,OAAO,GAAA;AAAI,KACtC;AAAA,IACA,SAAA,EAAW;AAAA,GACb;AACF;AAEA,SAAS,mBAAA,CACP,UAAA,EACA,YAAA,EACA,aAAA,EACQ;AACR,EAAA,IAAI,YAAA,EAAc;AAChB,IAAA,OAAO,YAAA,CAAa,GAAA;AAAA,EACtB;AACA,EAAA,MAAM,WAAA,GAAc,aAAA,CAAc,aAAA,CAAc,MAAA,GAAS,CAAC,CAAA;AAC1D,EAAA,IAAI,WAAA,EAAa;AACf,IAAA,OAAO,WAAA,CAAY,GAAA;AAAA,EACrB;AACA,EAAA,OAAO,UAAA,CAAW,GAAA;AACpB;AAEA,SAAS,cAAA,CACP,MAAA,EACA,UAAA,EACA,MAAA,GAAiB,EAAA,EAC8B;AAC/C,EAAA,MAAM,UAAA,GAAa,OAAO,UAAU,CAAA;AACpC,EAAA,MAAM,EAAE,aAAA,EAAe,QAAA,EAAU,cAAa,GAAI,sBAAA,CAAuB,QAAQ,UAAU,CAAA;AAC3F,EAAA,MAAM,QAAA,GAAW,kBAAA,CAAmB,aAAa,CAAA,CAAE,GAAA;AAAA,IAAI,CAAC,aAAA,KACtD,yBAAA,CAA0B,aAAA,EAAe,MAAM;AAAA,GACjD;AAEA,EAAA,MAAM,IAAA,GAAO,UAAA,CAAW,KAAA,KAAU,IAAA,GAAO,UAAA,GAAa,UAAA;AACtD,EAAA,MAAM,GAAA,GAAM,mBAAA,CAAoB,UAAA,EAAY,YAAA,EAAc,aAAa,CAAA;AACvE,EAAA,OAAO;AAAA,IACL,IAAA,EAAM;AAAA,MACJ,IAAA,EAAM,cAAA;AAAA,MACN,QAAA;AAAA,MACA,IAAA;AAAA,MACA,GAAA,EAAK,EAAE,KAAA,EAAO,UAAA,CAAW,OAAO,GAAA;AAAI,KACtC;AAAA,IACA,SAAA,EAAW;AAAA,GACb;AACF;AAEA,SAAS,oBAAA,CACP,MAAA,EACA,UAAA,EACA,MAAA,GAAiB,EAAA,EAC6B;AAC9C,EAAA,MAAM,UAAA,GAAa,OAAO,UAAU,CAAA;AACpC,EAAA,MAAM,EAAE,aAAA,EAAe,QAAA,EAAU,cAAa,GAAI,sBAAA,CAAuB,QAAQ,UAAU,CAAA;AAC3F,EAAA,MAAM,QAAA,GAAW,kBAAA,CAAmB,aAAa,CAAA,CAAE,GAAA;AAAA,IAAI,CAAC,aAAA,KACtD,yBAAA,CAA0B,aAAA,EAAe,MAAM;AAAA,GACjD;AACA,EAAA,MAAM,QAAA,GAAW,iBAAiB,aAAa,CAAA;AAC/C,EAAA,MAAM,aAAa,aAAA,CAAc,IAAA,CAAK,CAAC,KAAA,KAAU,KAAA,CAAM,SAAS,SAAS,CAAA;AACzE,EAAA,MAAM,GAAA,GAAM,mBAAA,CAAoB,UAAA,EAAY,YAAA,EAAc,aAAa,CAAA;AACvE,EAAA,OAAO;AAAA,IACL,IAAA,EAAM;AAAA,MACJ,IAAA,EAAM,aAAA;AAAA,MACN,QAAA;AAAA,MACA,QAAA;AAAA,MACA,UAAA;AAAA,MACA,GAAA,EAAK,EAAE,KAAA,EAAO,UAAA,CAAW,OAAO,GAAA;AAAI,KACtC;AAAA,IACA,SAAA,EAAW;AAAA,GACb;AACF;AAEA,SAAS,oBAAA,CACP,MAAA,EACA,UAAA,EACA,MAAA,GAAiB,EAAA,EAC6B;AAC9C,EAAA,MAAM,UAAA,GAAa,OAAO,UAAU,CAAA;AACpC,EAAA,MAAM,EAAE,aAAA,EAAe,QAAA,EAAU,cAAa,GAAI,sBAAA,CAAuB,QAAQ,UAAU,CAAA;AAC3F,EAAA,MAAM,YAAA,GAAe,IAAI,MAAA,CAAO,aAAA,EAAe,MAAM,CAAA;AACrD,EAAA,MAAM,MAAA,GAAS,aAAa,WAAA,EAAY;AACxC,EAAA,MAAM,GAAA,GAAM,mBAAA,CAAoB,UAAA,EAAY,YAAA,EAAc,aAAa,CAAA;AACvE,EAAA,OAAO;AAAA,IACL,IAAA,EAAM;AAAA,MACJ,IAAA,EAAM,aAAA;AAAA,MACN,MAAM,MAAA,CAAO,IAAA;AAAA,MACb,GAAA,EAAK,EAAE,KAAA,EAAO,UAAA,CAAW,OAAO,GAAA;AAAI,KACtC;AAAA,IACA,SAAA,EAAW;AAAA,GACb;AACF;AAEA,SAAS,qBAAqB,KAAA,EAA8B;AAC1D,EAAA,MAAM,KAAA,GAAQ,MAAM,KAAA,IAAS,QAAA;AAC7B,EAAA,OAAO;AAAA,IACL,IAAA,EAAM,YAAA;AAAA,IACN,KAAA;AAAA,IACA,OAAO,KAAA,CAAM,KAAA;AAAA,IACb,KAAK,EAAE,KAAA,EAAO,MAAM,KAAA,EAAO,GAAA,EAAK,MAAM,GAAA;AAAI,GAC5C;AACF;AAEA,SAAS,eAAe,KAAA,EAAwB;AAC9C,EAAA,MAAM,IAAA,GACJ,KAAA,CAAM,IAAA,KAAS,YAAA,GACX,MAAA,GACA,KAAA,CAAM,IAAA,KAAS,SAAA,GACb,SAAA,GACA,KAAA,CAAM,IAAA,KAAS,QAAA,GACb,QAAA,GACA,KAAA,CAAM,IAAA,KAAS,UAAA,GACb,UAAA,GACA,KAAA,CAAM,IAAA,KAAS,QAAA,GACb,QAAA,GACA,KAAA,CAAM,IAAA,KAAS,UAAA,GACb,UAAA,GACA,KAAA,CAAM,IAAA,KAAS,aAAA,GACb,aAAA,GACA,SAAA;AAElB,EAAA,OAAO;AAAA,IACL,IAAA,EAAM,MAAA;AAAA,IACN,OAAO,KAAA,CAAM,KAAA;AAAA,IACb,IAAA;AAAA,IACA,KAAK,EAAE,KAAA,EAAO,MAAM,KAAA,EAAO,GAAA,EAAK,MAAM,GAAA;AAAI,GAC5C;AACF;AAEA,SAAS,sBAAA,CACP,QACA,UAAA,EACoE;AACpE,EAAA,MAAM,gBAAyB,EAAC;AAChC,EAAA,MAAM,KAAA,GAAkB,CAAC,MAAA,CAAO,UAAU,EAAE,KAAK,CAAA;AACjD,EAAA,IAAI,QAAQ,UAAA,GAAa,CAAA;AAEzB,EAAA,OAAO,KAAA,GAAQ,OAAO,MAAA,EAAQ;AAC5B,IAAA,MAAM,KAAA,GAAQ,OAAO,KAAK,CAAA;AAE1B,IAAA,IAAI,cAAA,CAAe,KAAK,CAAA,EAAG;AACzB,MAAA,KAAA,CAAM,IAAA,CAAK,MAAM,KAAK,CAAA;AACtB,MAAA,aAAA,CAAc,KAAK,KAAK,CAAA;AACxB,MAAA,KAAA,IAAS,CAAA;AACT,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,cAAA,CAAe,KAAK,CAAA,EAAG;AACzB,MAAA,IAAI,KAAA,CAAM,WAAW,CAAA,EAAG;AACtB,QAAA,OAAO,EAAE,aAAA,EAAe,QAAA,EAAU,KAAA,GAAQ,CAAA,EAAG,cAAc,KAAA,EAAM;AAAA,MACnE;AACA,MAAA,KAAA,CAAM,GAAA,EAAI;AACV,MAAA,aAAA,CAAc,KAAK,KAAK,CAAA;AACxB,MAAA,KAAA,IAAS,CAAA;AACT,MAAA;AAAA,IACF;AAEA,IAAA,aAAA,CAAc,KAAK,KAAK,CAAA;AACxB,IAAA,KAAA,IAAS,CAAA;AAAA,EACX;AAEA,EAAA,OAAO,EAAE,aAAA,EAAe,QAAA,EAAU,MAAA,CAAO,MAAA,EAAO;AAClD;AAQA,SAAS,sBAAsB,MAAA,EAA4B;AACzD,EAAA,MAAM,UAAqB,EAAC;AAC5B,EAAA,IAAI,UAAmB,EAAC;AACxB,EAAA,MAAM,QAAkB,EAAC;AAEzB,EAAA,KAAA,MAAW,SAAS,MAAA,EAAQ;AAC1B,IAAA,IAAI,KAAA,CAAM,IAAA,KAAS,SAAA,IAAa,KAAA,CAAM,WAAW,CAAA,EAAG;AAClD,MAAA,IAAI,OAAA,CAAQ,SAAS,CAAA,EAAG;AACtB,QAAA,OAAA,CAAQ,KAAK,OAAO,CAAA;AACpB,QAAA,OAAA,GAAU,EAAC;AAAA,MACb;AACA,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,KAAA,CAAM,SAAS,aAAA,IAAiB,KAAA,CAAM,UAAU,GAAA,IAAO,KAAA,CAAM,WAAW,CAAA,EAAG;AAC7E,MAAA,IAAI,OAAA,CAAQ,SAAS,CAAA,EAAG;AACtB,QAAA,OAAA,CAAQ,KAAK,OAAO,CAAA;AACpB,QAAA,OAAA,GAAU,EAAC;AAAA,MACb;AACA,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,cAAA,CAAe,KAAK,CAAA,EAAG;AACzB,MAAA,KAAA,CAAM,IAAA,CAAK,MAAM,KAAK,CAAA;AACtB,MAAA,OAAA,CAAQ,KAAK,KAAK,CAAA;AAClB,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,cAAA,CAAe,KAAK,CAAA,EAAG;AACzB,MAAA,KAAA,CAAM,GAAA,EAAI;AACV,MAAA,OAAA,CAAQ,KAAK,KAAK,CAAA;AAClB,MAAA;AAAA,IACF;AAEA,IAAA,OAAA,CAAQ,KAAK,KAAK,CAAA;AAAA,EACpB;AAEA,EAAA,IAAI,OAAA,CAAQ,SAAS,CAAA,EAAG;AACtB,IAAA,OAAA,CAAQ,KAAK,OAAO,CAAA;AAAA,EACtB;AAEA,EAAA,OAAO,OAAA;AACT;AAEA,SAAS,mBAAA,CAAoB,MAAA,EAAiB,MAAA,GAAiB,EAAA,EAAwB;AACrF,EAAA,MAAM,WAAA,GAAc,mBAAmB,MAAM,CAAA;AAC7C,EAAA,MAAM,YAAY,WAAA,KAAgB,EAAA,GAAK,SAAS,MAAA,CAAO,KAAA,CAAM,GAAG,WAAW,CAAA;AAC3E,EAAA,MAAM,WAAA,GAAc,gBAAgB,EAAA,GAAK,KAAK,MAAA,CAAO,KAAA,CAAM,cAAc,CAAC,CAAA;AAC1E,EAAA,MAAM,aAAA,GAAgB,yBAAA,CAA0B,SAAA,EAAW,MAAM,CAAA;AACjE,EAAA,MAAM,eAAA,GACJ,WAAA,CAAY,MAAA,GAAS,CAAA,GACjB,yBAAA,CAA0B,WAAA,EAAa,MAAM,CAAA,GAC7C,yBAAA,CAA0B,EAAC,EAAG,MAAM,CAAA;AAC1C,EAAA,MAAM,GAAA,GAAM,eAAe,SAAS,CAAA;AACpC,EAAA,MAAM,KAAA,GAAQ,UAAU,CAAC,CAAA,EAAG,SAAS,WAAA,CAAY,CAAC,GAAG,KAAA,IAAS,CAAA;AAC9D,EAAA,MAAM,GAAA,GAAA,CACH,WAAA,CAAY,WAAA,CAAY,MAAA,GAAS,CAAC,CAAA,IAAK,SAAA,CAAU,SAAA,CAAU,MAAA,GAAS,CAAC,CAAA,GAAI,GAAA,IAAO,KAAA;AAEnF,EAAA,OAAO;AAAA,IACL,IAAA,EAAM,gBAAA;AAAA,IACN,GAAA;AAAA,IACA,MAAA,EAAQ,aAAA;AAAA,IACR,KAAA,EAAO,eAAA;AAAA,IACP,GAAA,EAAK,EAAE,KAAA,EAAO,GAAA;AAAI,GACpB;AACF;AAEA,SAAS,mBAAmB,MAAA,EAAyB;AACnD,EAAA,MAAM,QAAkB,EAAC;AACzB,EAAA,KAAA,IAAS,QAAQ,CAAA,EAAG,KAAA,GAAQ,MAAA,CAAO,MAAA,EAAQ,SAAS,CAAA,EAAG;AACrD,IAAA,MAAM,KAAA,GAAQ,OAAO,KAAK,CAAA;AAC1B,IAAA,IAAI,cAAA,CAAe,KAAK,CAAA,EAAG;AACzB,MAAA,KAAA,CAAM,IAAA,CAAK,MAAM,KAAK,CAAA;AACtB,MAAA;AAAA,IACF;AACA,IAAA,IAAI,cAAA,CAAe,KAAK,CAAA,EAAG;AACzB,MAAA,KAAA,CAAM,GAAA,EAAI;AACV,MAAA;AAAA,IACF;AACA,IAAA,IAAI,KAAA,CAAM,WAAW,CAAA,IAAK,KAAA,CAAM,SAAS,UAAA,IAAc,KAAA,CAAM,UAAU,GAAA,EAAK;AAC1E,MAAA,OAAO,KAAA;AAAA,IACT;AAAA,EACF;AACA,EAAA,OAAO,EAAA;AACT;AAEA,SAAS,eAAe,MAAA,EAAyB;AAC/C,EAAA,MAAM,OAAO,MAAA,CACV,MAAA,CAAO,CAAC,KAAA,KAAU,KAAA,CAAM,SAAS,SAAS,CAAA,CAC1C,GAAA,CAAI,CAAC,UAAU,KAAA,CAAM,KAAK,EAC1B,IAAA,CAAK,GAAG,EACR,IAAA,EAAK;AACR,EAAA,IAAI,KAAK,UAAA,CAAW,GAAG,KAAK,IAAA,CAAK,QAAA,CAAS,GAAG,CAAA,EAAG;AAC9C,IAAA,OAAO,IAAA,CAAK,KAAA,CAAM,CAAA,EAAG,EAAE,CAAA;AAAA,EACzB;AACA,EAAA,IAAI,KAAK,UAAA,CAAW,GAAG,KAAK,IAAA,CAAK,QAAA,CAAS,GAAG,CAAA,EAAG;AAC9C,IAAA,OAAO,IAAA,CAAK,KAAA,CAAM,CAAA,EAAG,EAAE,CAAA;AAAA,EACzB;AACA,EAAA,OAAO,IAAA;AACT;AAEA,SAAS,mBAAmB,MAAA,EAA4B;AACtD,EAAA,MAAM,WAAsB,EAAC;AAC7B,EAAA,IAAI,UAAmB,EAAC;AACxB,EAAA,MAAM,QAAkB,EAAC;AAEzB,EAAA,KAAA,MAAW,SAAS,MAAA,EAAQ;AAC1B,IAAA,IAAI,KAAA,CAAM,IAAA,KAAS,SAAA,IAAa,KAAA,CAAM,WAAW,CAAA,EAAG;AAClD,MAAA,IAAI,OAAA,CAAQ,SAAS,CAAA,EAAG;AACtB,QAAA,QAAA,CAAS,KAAK,OAAO,CAAA;AACrB,QAAA,OAAA,GAAU,EAAC;AAAA,MACb;AACA,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,KAAA,CAAM,SAAS,aAAA,IAAiB,KAAA,CAAM,UAAU,GAAA,IAAO,KAAA,CAAM,WAAW,CAAA,EAAG;AAC7E,MAAA,QAAA,CAAS,KAAK,OAAO,CAAA;AACrB,MAAA,OAAA,GAAU,EAAC;AACX,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,cAAA,CAAe,KAAK,CAAA,EAAG;AACzB,MAAA,KAAA,CAAM,IAAA,CAAK,MAAM,KAAK,CAAA;AACtB,MAAA,OAAA,CAAQ,KAAK,KAAK,CAAA;AAClB,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,cAAA,CAAe,KAAK,CAAA,EAAG;AACzB,MAAA,KAAA,CAAM,GAAA,EAAI;AACV,MAAA,OAAA,CAAQ,KAAK,KAAK,CAAA;AAClB,MAAA;AAAA,IACF;AAEA,IAAA,OAAA,CAAQ,KAAK,KAAK,CAAA;AAAA,EACpB;AAEA,EAAA,IAAI,OAAA,CAAQ,SAAS,CAAA,EAAG;AACtB,IAAA,QAAA,CAAS,KAAK,OAAO,CAAA;AAAA,EACvB;AAEA,EAAA,OAAO,QAAA;AACT;AAEA,SAAS,iBAAiB,MAAA,EAA0B;AAClD,EAAA,MAAM,QAAkB,EAAC;AACzB,EAAA,KAAA,MAAW,SAAS,MAAA,EAAQ;AAC1B,IAAA,IAAI,cAAA,CAAe,KAAK,CAAA,EAAG;AACzB,MAAA,KAAA,CAAM,IAAA,CAAK,MAAM,KAAK,CAAA;AACtB,MAAA;AAAA,IACF;AACA,IAAA,IAAI,cAAA,CAAe,KAAK,CAAA,EAAG;AACzB,MAAA,KAAA,CAAM,GAAA,EAAI;AACV,MAAA;AAAA,IACF;AACA,IAAA,IAAI,KAAA,CAAM,WAAW,CAAA,IAAK,KAAA,CAAM,SAAS,aAAA,IAAiB,KAAA,CAAM,UAAU,GAAA,EAAK;AAC7E,MAAA,OAAO,IAAA;AAAA,IACT;AAAA,EACF;AACA,EAAA,OAAO,KAAA;AACT;AAEO,SAAS,eAAA,CAAgB,QAAgB,OAAA,EAAoC;AAClF,EAAA,cAAA,CAAe,OAAO,CAAA;AACtB,EAAA,MAAM,MAAA,GAAS,SAAS,MAAM,CAAA;AAC9B,EAAA,MAAM,MAAA,GAAS,IAAI,MAAA,CAAO,MAAA,EAAQ,MAAM,CAAA;AACxC,EAAA,OAAO,OAAO,WAAA,EAAY;AAC5B;AAyCO,IAAM,QAAA,GAAW,CAAC,IAAA,KAA6C,IAAA,CAAK,GAAA,CAAI,KAAA;AACxE,IAAM,MAAA,GAAS,CAAC,IAAA,KAA2C,IAAA,CAAK,GAAA,CAAI,GAAA;;;AC31B3E,IAAM,EAAE,KAAA,EAAO,MAAA,EAAQ,IAAA,EAAM,QAAA,EAAU,QAAA,EAAU,IAAA,EAAM,OAAA,EAAS,UAAA,EAAY,YAAA,EAAc,KAAA,EAAM,GAC9FA,YAAA,CAAI,QAAA;AAEC,IAAM,iBAAA,GAAyC;AAAA,EACpD,KAAA,CAAM,MAAe,OAAA,EAAwB;AAC3C,IAAA,MAAM,IAAA,GAAO,KAAK,QAAA,EAAS;AAC3B,IAAA,IAAI,CAAC,IAAA,EAAM;AACT,MAAA,OAAO,EAAA;AAAA,IACT;AACA,IAAA,MAAM,QAAA,GAAW,eAAe,OAAO,CAAA;AACvC,IAAA,OAAO,SAAA,CAAU,MAAM,QAAQ,CAAA;AAAA,EACjC;AACF,CAAA;AAEA,SAAS,SAAA,CACP,MACA,OAAA,EACK;AACL,EAAA,QAAQ,KAAK,IAAA;AAAM,IACjB,KAAK,QAAA;AACH,MAAA,OAAO,WAAA,CAAY,MAAM,OAAO,CAAA;AAAA,IAClC,KAAK,aAAA;AACH,MAAA,OAAO,gBAAA,CAAiB,MAAM,OAAO,CAAA;AAAA,IACvC,KAAK,qBAAA;AACH,MAAA,OAAO,aAAA,CAAc,MAAM,OAAO,CAAA;AAAA,IACpC,KAAK,UAAA;AACH,MAAA,OAAO,aAAA,CAAc,MAAM,OAAO,CAAA;AAAA,IACpC,KAAK,YAAA;AACH,MAAA,OAAO,eAAA,CAAgB,MAAM,OAAO,CAAA;AAAA,IACtC,KAAK,MAAA;AACH,MAAA,OAAO,SAAA,CAAU,MAAM,OAAO,CAAA;AAAA,IAChC,KAAK,SAAA;AACH,MAAA,OAAO,aAAa,IAAI,CAAA;AAAA,IAC1B,KAAK,WAAA;AACH,MAAA,OAAO,KAAA,CAAM,KAAK,EAAE,MAAA,EAAQ,KAAK,KAAA,EAAM,EAAG,MAAM,QAAQ,CAAA;AAAA,IAC1D,KAAK,cAAA;AACH,MAAA,OAAO,UAAA,CAAW,MAAM,OAAO,CAAA;AAAA,IACjC,KAAK,WAAA;AACH,MAAA,OAAO,cAAA,CAAe,MAAM,OAAO,CAAA;AAAA,IACrC,KAAK,gBAAA;AACH,MAAA,OAAO,mBAAA,CAAoB,MAAM,OAAO,CAAA;AAAA,IAC1C,KAAK,YAAA;AACH,MAAA,OAAO,gBAAgB,IAAI,CAAA;AAAA,IAC7B,KAAK,aAAA;AACH,MAAA,OAAO,gBAAA,CAAiB,MAAM,OAAO,CAAA;AAAA,IACvC;AACE,MAAA,OAAO,EAAA;AAAA;AAEb;AAEA,SAAS,WAAW,IAAA,EAAkB;AACpC,EAAA,IAAI,IAAA,CAAK,WAAW,CAAA,EAAG;AACrB,IAAA,OAAO,EAAA;AAAA,EACT;AACA,EAAA,IAAI,GAAA,GAAW,KAAK,CAAC,CAAA;AACrB,EAAA,KAAA,IAAS,QAAQ,CAAA,EAAG,KAAA,GAAQ,IAAA,CAAK,MAAA,EAAQ,SAAS,CAAA,EAAG;AACnD,IAAA,GAAA,GAAM,CAAC,GAAA,EAAK,IAAA,CAAK,KAAK,CAAC,CAAA;AAAA,EACzB;AACA,EAAA,OAAO,GAAA;AACT;AAEA,SAAS,eAAA,CAAgB,aAAkB,OAAA,EAA+B;AACxE,EAAA,MAAM,UAAA,GAAa,QAAQ,WAAA,KAAgB,MAAA,GAAS,MAAO,GAAA,CAAI,MAAA,CAAO,QAAQ,UAAU,CAAA;AACxF,EAAA,OAAO,CAAC,UAAA,EAAY,KAAA,CAAM,UAAA,CAAW,MAAA,EAAQ,WAAW,CAAC,CAAA;AAC3D;AAEA,SAAS,WAAA,CAAY,MAAkB,OAAA,EAA+B;AACpE,EAAA,MAAM,OAAA,GAAU,kBAAA,CAAmB,IAAA,CAAK,IAAA,EAAM,SAAS,KAAK,CAAA;AAC5D,EAAA,IAAI,CAAC,OAAA,EAAS;AACZ,IAAA,OAAO,EAAA;AAAA,EACT;AACA,EAAA,OAAO,CAAC,SAAS,QAAQ,CAAA;AAC3B;AAEA,SAAS,kBAAA,CACP,IAAA,EACA,OAAA,EACA,gBAAA,EACK;AACL,EAAA,MAAM,OAAc,EAAC;AACrB,EAAA,IAAI,QAAA,GAAkC,IAAA;AACtC,EAAA,IAAI,iBAAA,GAAoB,CAAA;AAExB,EAAA,KAAA,MAAW,SAAS,IAAA,EAAM;AACxB,IAAA,IAAI,KAAA,CAAM,SAAS,WAAA,EAAa;AAC9B,MAAA,iBAAA,IAAqB,KAAA,CAAM,KAAA;AAC3B,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,QAAA,EAAU;AACZ,MAAA,MAAM,UAAA,GAAa,mBAAA,CAAoB,QAAA,EAAU,KAAA,EAAO,mBAAmB,OAAO,CAAA;AAClF,MAAA,KAAA,IAAS,KAAA,GAAQ,CAAA,EAAG,KAAA,GAAQ,UAAA,EAAY,SAAS,CAAA,EAAG;AAClD,QAAA,IAAA,CAAK,KAAK,QAAQ,CAAA;AAAA,MACpB;AAAA,IACF;AAEA,IAAA,MAAM,OAAA,GAAU,SAAA,CAAU,KAAA,EAAO,OAAO,CAAA;AACxC,IAAA,IACE,KAAA,CAAM,IAAA,KAAS,SAAA,IACf,QAAA,IACA,KAAA,CAAM,GAAA,CAAI,KAAA,GAAQ,QAAA,CAAS,GAAA,CAAI,GAAA,IAC/B,IAAA,CAAK,MAAA,GAAS,CAAA,EACd;AACA,MAAA,MAAM,UAAA,GAAa,gBAAA,GAAmB,eAAA,CAAgB,OAAA,EAAS,OAAO,CAAA,GAAI,OAAA;AAC1E,MAAA,MAAM,SAAA,GAAY,KAAK,MAAA,GAAS,CAAA;AAChC,MAAA,MAAM,QAAA,GAAW,WAAW,CAAC,IAAA,CAAK,SAAS,CAAA,EAAI,QAAA,EAAU,UAAU,CAAC,CAAA;AACpE,MAAA,IAAA,CAAK,SAAS,CAAA,GAAI,QAAA;AAClB,MAAA,QAAA,GAAW,KAAA;AACX,MAAA,iBAAA,GAAoB,CAAA;AACpB,MAAA;AAAA,IACF;AAEA,IAAA,IAAA,CAAK,KAAK,gBAAA,GAAmB,eAAA,CAAgB,OAAA,EAAS,OAAO,IAAI,OAAO,CAAA;AACxE,IAAA,QAAA,GAAW,KAAA;AACX,IAAA,iBAAA,GAAoB,CAAA;AAAA,EACtB;AAEA,EAAA,OAAO,WAAW,IAAI,CAAA;AACxB;AAEA,SAAS,mBAAA,CACP,QAAA,EACA,OAAA,EACA,iBAAA,EACA,OAAA,EACQ;AACR,EAAA,IAAI,IAAA,GAAO,iBAAA,GAAoB,CAAA,GAAI,iBAAA,GAAoB,CAAA;AACvD,EAAA,MAAM,sBAAA,GAAyB,QAAQ,0BAAA,GAA6B,CAAA;AAEpE,EAAA,IACG,SAAS,IAAA,KAAS,qBAAA,IAAyB,OAAA,CAAQ,IAAA,KAAS,yBAC5D,QAAA,CAAS,IAAA,KAAS,qBAAA,IAAyB,OAAA,CAAQ,SAAS,WAAA,IAC5D,OAAA,CAAQ,SAAS,qBAAA,IAAyB,QAAA,CAAS,SAAS,WAAA,EAC7D;AACA,IAAA,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,IAAA,EAAM,sBAAsB,CAAA;AAAA,EAC9C;AAEA,EAAA,IAAI,OAAA,CAAQ,mBAAA,IAAuB,gBAAA,CAAiB,QAAQ,CAAA,EAAG;AAC7D,IAAA,IAAA,GAAO,IAAA,CAAK,GAAA,CAAI,IAAA,EAAM,CAAC,CAAA;AAAA,EACzB;AAEA,EAAA,OAAO,IAAA;AACT;AAEA,SAAS,gBAAA,CAAiB,MAAuB,OAAA,EAA+B;AAC9E,EAAA,IAAI,IAAA,CAAK,IAAA,CAAK,MAAA,KAAW,CAAA,EAAG;AAC1B,IAAA,OAAO,IAAA;AAAA,EACT;AAEA,EAAA,MAAM,OAAA,GAAU,kBAAA,CAAmB,IAAA,CAAK,IAAA,EAAM,SAAS,IAAI,CAAA;AAC3D,EAAA,OAAO,MAAM,CAAC,GAAA,EAAK,UAAU,OAAA,EAAS,QAAA,EAAU,GAAG,CAAC,CAAA;AACtD;AAEA,SAAS,aAAA,CAAc,MAA+B,OAAA,EAA+B;AACnF,EAAA,MAAM,SAAA,GAAY,eAAA,CAAgB,IAAA,CAAK,MAAA,EAAQ,OAAO,CAAA;AACtD,EAAA,MAAM,OAAA,GAAU,gBAAA,CAAiB,IAAA,CAAK,IAAA,EAAM,OAAO,CAAA;AACnD,EAAA,IAAI,OAAA,CAAQ,eAAe,QAAA,EAAU;AACnC,IAAA,OAAO,KAAA,CAAM,CAAC,SAAA,EAAW,QAAA,EAAU,OAAO,CAAC,CAAA;AAAA,EAC7C;AACA,EAAA,OAAO,KAAA,CAAM,CAAC,SAAA,EAAW,GAAA,EAAK,OAAO,CAAC,CAAA;AACxC;AAEA,SAAS,aAAA,CAAc,MAAoB,OAAA,EAA+B;AACxE,EAAA,MAAM,WAAA,GAAc,KAAK,QAAA,CAAS,GAAA,CAAI,CAAC,OAAA,KAAY,eAAA,CAAgB,OAAA,EAAS,OAAO,CAAC,CAAA;AACpF,EAAA,IAAI,WAAA,CAAY,WAAW,CAAA,EAAG;AAC5B,IAAA,OAAO,EAAA;AAAA,EACT;AAEA,EAAA,IAAI,WAAA,GAAmB,YAAY,CAAC,CAAA;AAEpC,EAAA,IAAI,WAAA,CAAY,SAAS,CAAA,EAAG;AAC1B,IAAA,MAAM,QAAA,GAAW,WAAA,CAAY,KAAA,CAAM,CAAC,EAAE,GAAA,CAAI,CAAC,UAAA,KAAe,CAAC,IAAA,EAAM,CAAC,IAAA,EAAM,UAAU,CAAC,CAAC,CAAA;AACpF,IAAA,WAAA,GAAc,KAAA,CAAM,CAAC,WAAA,CAAY,CAAC,CAAA,EAAG,MAAA,CAAO,QAAA,CAAS,OAAA,CAAQ,CAAC,OAAA,KAAY,OAAO,CAAC,CAAC,CAAC,CAAA;AAAA,EACtF;AAEA,EAAA,IAAI,KAAK,eAAA,EAAiB;AACxB,IAAA,IAAI,IAAA,CAAK,gBAAgB,MAAA,EAAQ;AAC/B,MAAA,WAAA,GAAc,CAAC,aAAa,UAAA,CAAW,CAAC,MAAM,IAAA,CAAK,eAAA,CAAgB,KAAK,CAAC,CAAC,CAAA;AAAA,IAC5E,CAAA,MAAO;AACL,MAAA,WAAA,GAAc,CAAC,WAAA,EAAa,QAAA,EAAU,YAAA,CAAa,IAAA,CAAK,eAAe,CAAC,CAAA;AAAA,IAC1E;AAAA,EACF;AAEA,EAAA,OAAO,WAAA;AACT;AAEA,SAAS,eAAA,CAAgB,MAAsB,OAAA,EAA+B;AAC5E,EAAA,MAAM,OAAc,EAAC;AACrB,EAAA,IAAI,QAAA,GAAsC,IAAA;AAE1C,EAAA,KAAA,MAAW,IAAA,IAAQ,KAAK,KAAA,EAAO;AAC7B,IAAA,IAAI,cAAA,CAAe,IAAI,CAAA,EAAG;AACxB,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,IAAA,CAAK,IAAA,KAAS,aAAA,IAAiB,cAAA,CAAe,QAAQ,CAAA,EAAG;AAC3D,MAAA,IAAA,CAAK,IAAA,CAAK,qBAAA,CAAsB,IAAA,EAAM,OAAO,CAAC,CAAA;AAC9C,MAAA,QAAA,GAAW,IAAA;AACX,MAAA;AAAA,IACF;AAEA,IAAA,IAAI,QAAA,EAAU;AACZ,MAAA,MAAM,SAAA,GAAY,UAAA,CAAW,QAAA,EAAU,IAAI,CAAA;AAC3C,MAAA,IAAI,SAAA,EAAW;AACb,QAAA,IAAA,CAAK,KAAK,SAAS,CAAA;AAAA,MACrB;AAAA,IACF;AAEA,IAAA,IAAA,CAAK,IAAA,CAAK,SAAA,CAAU,IAAA,EAAM,OAAO,CAAC,CAAA;AAClC,IAAA,QAAA,GAAW,IAAA;AAAA,EACb;AAEA,EAAA,OAAO,IAAA,CAAK,MAAA,KAAW,CAAA,GAAI,EAAA,GAAK,MAAM,IAAI,CAAA;AAC5C;AAEA,SAAS,UAAA,CAAW,UAA8B,OAAA,EAAyC;AACzF,EAAA,MAAM,UAAA,GAAa,UAAU,QAAQ,CAAA;AACrC,EAAA,MAAM,aAAA,GAAgB,UAAU,OAAO,CAAA;AAEvC,EAAA,IAAI,OAAA,CAAQ,SAAS,aAAA,EAAe;AAClC,IAAA,IAAI,QAAA,IAAY,QAAA,CAAS,IAAA,KAAS,MAAA,EAAQ;AACxC,MAAA,IAAI,QAAA,CAAS,KAAA,CAAM,WAAA,EAAY,KAAM,OAAA,EAAS;AAC5C,QAAA,OAAO,IAAA;AAAA,MACT;AACA,MAAA,IAAI,QAAA,CAAS,SAAS,SAAA,EAAW;AAC/B,QAAA,OAAO,GAAA;AAAA,MACT;AACA,MAAA,OAAO,IAAA;AAAA,IACT;AACA,IAAA,OAAO,GAAA;AAAA,EACT;AAEA,EAAA,IAAI,QAAA,CAAS,SAAS,aAAA,EAAe;AACnC,IAAA,IAAI,aAAA,IAAiB,eAAA,CAAgB,GAAA,CAAI,aAAa,CAAA,EAAG;AACvD,MAAA,OAAO,IAAA;AAAA,IACT;AACA,IAAA,OAAO,GAAA;AAAA,EACT;AAEA,EAAA,IAAI,CAAC,UAAA,IAAc,CAAC,aAAA,EAAe;AACjC,IAAA,OAAO,GAAA;AAAA,EACT;AAEA,EAAA,IAAI,CAAC,UAAA,EAAY;AACf,IAAA,IAAI,aAAA,IAAiB,eAAA,CAAgB,GAAA,CAAI,aAAa,CAAA,EAAG;AACvD,MAAA,OAAO,IAAA;AAAA,IACT;AACA,IAAA,OAAO,GAAA;AAAA,EACT;AAEA,EAAA,IAAI,cAAA,CAAe,GAAA,CAAI,UAAU,CAAA,EAAG;AAClC,IAAA,OAAO,IAAA;AAAA,EACT;AAEA,EAAA,IAAI,aAAA,IAAiB,eAAA,CAAgB,GAAA,CAAI,aAAa,CAAA,EAAG;AACvD,IAAA,OAAO,IAAA;AAAA,EACT;AAEA,EAAA,IAAI,UAAA,IAAc,iBAAiB,aAAA,CAAc,GAAA,CAAI,GAAG,UAAU,CAAA,CAAA,EAAI,aAAa,CAAA,CAAE,CAAA,EAAG;AACtF,IAAA,OAAO,IAAA;AAAA,EACT;AAGA,EAAA,IAAI,UAAA,KAAe,GAAA,IAAO,aAAA,KAAkB,GAAA,EAAK;AAC/C,IAAA,OAAO,GAAA;AAAA,EACT;AAEA,EAAA,IACE,OAAA,CAAQ,SAAS,aAAA,IACjB,OAAA,CAAQ,SAAS,WAAA,IACjB,OAAA,CAAQ,SAAS,cAAA,EACjB;AACA,IAAA,OAAO,GAAA;AAAA,EACT;AAEA,EAAA,OAAO,GAAA;AACT;AAEA,SAAS,iBAAiB,IAAA,EAAsC;AAC9D,EAAA,IAAI,CAAC,IAAA,IAAQ,IAAA,CAAK,IAAA,KAAS,UAAA,EAAY;AACrC,IAAA,OAAO,KAAA;AAAA,EACT;AACA,EAAA,IAAI,IAAA,CAAK,QAAA,CAAS,MAAA,KAAW,CAAA,EAAG;AAC9B,IAAA,OAAO,KAAA;AAAA,EACT;AACA,EAAA,MAAM,YAAA,GAAe,IAAA,CAAK,QAAA,CAAS,CAAC,CAAA;AACpC,EAAA,IAAI,YAAA,CAAa,KAAA,CAAM,MAAA,KAAW,CAAA,EAAG;AACnC,IAAA,OAAO,KAAA;AAAA,EACT;AACA,EAAA,MAAM,SAAA,GAAY,aAAa,KAAA,CAAM,IAAA,CAAK,CAAC,IAAA,KAAS,IAAA,CAAK,SAAS,MAAM,CAAA;AACxE,EAAA,IAAI,CAAC,SAAA,IAAa,SAAA,CAAU,IAAA,KAAS,MAAA,EAAQ;AAC3C,IAAA,OAAO,KAAA;AAAA,EACT;AACA,EAAA,OAAO,SAAA,CAAU,KAAA,CAAM,WAAA,EAAY,KAAM,OAAA;AAC3C;AAEA,IAAM,eAAA,mBAAkB,IAAI,GAAA,CAAI,CAAC,GAAA,EAAK,GAAA,EAAK,GAAA,EAAK,GAAA,EAAK,GAAA,EAAK,GAAA,EAAK,IAAA,EAAM,GAAA,EAAK,GAAG,CAAC,CAAA;AAC9E,IAAM,cAAA,mBAAiB,IAAI,GAAA,CAAI,CAAC,GAAA,EAAK,KAAK,GAAA,EAAK,GAAA,EAAK,GAAA,EAAK,GAAG,CAAC,CAAA;AAC7D,IAAM,aAAA,uBAAoB,GAAA,CAAI,CAAC,UAAU,QAAA,EAAU,QAAA,EAAU,QAAQ,CAAC,CAAA;AAEtE,SAAS,UAAU,IAAA,EAAgD;AACjE,EAAA,IAAI,CAAC,IAAA,EAAM;AACT,IAAA,OAAO,IAAA;AAAA,EACT;AACA,EAAA,IAAI,IAAA,CAAK,SAAS,MAAA,KAAW,IAAA,CAAK,SAAS,aAAA,IAAiB,IAAA,CAAK,SAAS,UAAA,CAAA,EAAa;AACrF,IAAA,OAAO,IAAA,CAAK,KAAA;AAAA,EACd;AACA,EAAA,IAAI,IAAA,CAAK,SAAS,aAAA,EAAe;AAC/B,IAAA,OAAO,GAAA;AAAA,EACT;AACA,EAAA,OAAO,IAAA;AACT;AAEA,SAAS,eAAe,IAAA,EAA0C;AAChE,EAAA,OAAO,OAAA,CAAQ,QAAQ,IAAA,CAAK,IAAA,KAAS,UAAU,IAAA,CAAK,KAAA,CAAM,WAAA,EAAY,KAAM,OAAO,CAAA;AACrF;AAEA,IAAM,uBAAA,GAAqE;AAAA,EACzE,QAAA,EAAU,CAAC,KAAA,KAAU,KAAA;AAAA,EACrB,KAAA,EAAO,CAAC,KAAA,KAAU,KAAA,CAAM,WAAA,EAAY;AAAA,EACpC,KAAA,EAAO,CAAC,KAAA,KAAU,KAAA,CAAM,WAAA,EAAY;AAAA,EACpC,QAAQ,CAAC,KAAA,KACP,KAAA,CAAM,MAAA,KAAW,IAAI,KAAA,GAAQ,KAAA,CAAM,CAAC,CAAA,CAAE,aAAY,GAAI,KAAA,CAAM,KAAA,CAAM,CAAC,EAAE,WAAA;AACzE,CAAA;AAEA,IAAM,gBAAA,GAA2C;AAAA,EAC/C,EAAA,EAAI,UAAA;AAAA,EACJ,GAAA,EAAK,eAAA;AAAA,EACL,EAAA,EAAI,eAAA;AAAA,EACJ,GAAA,EAAK,eAAA;AAAA,EACL,EAAA,EAAI,eAAA;AAAA,EACJ,EAAA,EAAI,eAAA;AAAA,EACJ,GAAA,EAAK,aAAA;AAAA,EACL,EAAA,EAAI,YAAA;AAAA,EACJ,GAAA,EAAK,aAAA;AAAA,EACL,EAAA,EAAI,aAAA;AAAA,EACJ,IAAA,EAAM,eAAA;AAAA,EACN,GAAA,EAAK,aAAA;AAAA,EACL,GAAA,EAAK,aAAA;AAAA,EACL,EAAA,EAAI,aAAA;AAAA,EACJ,IAAA,EAAM,cAAA;AAAA,EACN,KAAA,EAAO,cAAA;AAAA,EACP,GAAA,EAAK,gBAAA;AAAA,EACL,OAAA,EAAS,gBAAA;AAAA,EACT,GAAA,EAAK,cAAA;AAAA,EACL,KAAA,EAAO;AACT,CAAA;AAEA,IAAM,yBAAA,uBAAgC,GAAA,CAAI,CAAC,CAAC,YAAA,EAAc,cAAc,CAAC,CAAC,CAAA;AAE1E,SAAS,SAAA,CAAU,MAAgB,OAAA,EAA+B;AAChE,EAAA,IAAI,IAAA,CAAK,SAAS,QAAA,EAAU;AAC1B,IAAA,OAAO,sBAAA,CAAuB,IAAA,CAAK,KAAA,EAAO,OAAO,CAAA;AAAA,EACnD;AAEA,EAAA,IAAI,QAAQ,IAAA,CAAK,KAAA;AAEjB,EAAA,IAAI,IAAA,CAAK,SAAS,SAAA,EAAW;AAC3B,IAAA,MAAM,SAAA,GACJ,uBAAA,CAAwB,OAAA,CAAQ,WAAW,KAAK,uBAAA,CAAwB,QAAA;AAC1E,IAAA,KAAA,GAAQ,UAAU,KAAK,CAAA;AAAA,EACzB;AAEA,EAAA,IACE,OAAA,CAAQ,cAAA,KACP,IAAA,CAAK,IAAA,KAAS,MAAA,IAAU,KAAK,IAAA,KAAS,UAAA,IAAc,IAAA,CAAK,IAAA,KAAS,SAAA,CAAA,EACnE;AACA,IAAA,MAAM,QAAA,GAAW,MAAM,WAAA,EAAY;AACnC,IAAA,IAAI,OAAO,SAAA,CAAU,cAAA,CAAe,IAAA,CAAK,gBAAA,EAAkB,QAAQ,CAAA,EAAG;AACpE,MAAA,KAAA,GAAQ,iBAAiB,QAAQ,CAAA;AAAA,IACnC;AAAA,EACF;AAEA,EAAA,IAAI,IAAA,CAAK,IAAA,KAAS,MAAA,IAAU,OAAA,CAAQ,gBAAA,EAAkB;AACpD,IAAA,MAAM,WAAA,GAAc,yBAAA,CAA0B,GAAA,CAAI,KAAA,CAAM,aAAa,CAAA;AACrE,IAAA,IAAI,WAAA,EAAa;AACf,MAAA,KAAA,GAAQ,WAAA;AAAA,IACV;AAAA,EACF;AAEA,EAAA,OAAO,KAAA;AACT;AAEA,SAAS,aAAa,IAAA,EAAwB;AAC5C,EAAA,IAAI,IAAA,CAAK,UAAU,OAAA,EAAS;AAC1B,IAAA,OAAO,IAAA,CAAK,KAAA;AAAA,EACd;AACA,EAAA,OAAO,CAAC,GAAA,EAAK,IAAA,CAAK,KAAK,CAAA;AACzB;AAEA,SAAS,UAAA,CAAW,MAAwB,OAAA,EAA+B;AACzE,EAAA,MAAM,IAAA,GAAO,IAAA,CAAK,IAAA,KAAS,UAAA,GAAa,IAAA,GAAO,GAAA;AAC/C,EAAA,MAAM,KAAA,GAAQ,IAAA,CAAK,IAAA,KAAS,UAAA,GAAa,GAAA,GAAM,GAAA;AAC/C,EAAA,IAAI,IAAA,CAAK,QAAA,CAAS,MAAA,KAAW,CAAA,EAAG;AAC9B,IAAA,OAAO,CAAC,MAAM,KAAK,CAAA;AAAA,EACrB;AACA,EAAA,MAAM,OAAA,GAAU,OAAO,OAAO,CAAA;AAC9B,EAAA,MAAM,WAAA,GAAc,KAAK,QAAA,CAAS,GAAA,CAAI,CAAC,OAAA,KAAY,eAAA,CAAgB,OAAA,EAAS,OAAO,CAAC,CAAA;AACpF,EAAA,MAAM,WAAA,GAAc,YAAY,MAAA,GAAS,CAAA;AACzC,EAAA,MAAM,SAAA,GAAiB,CAAC,GAAA,EAAK,IAAI,CAAA;AACjC,EAAA,MAAM,WAAW,gBAAA,CAAiB,OAAA,EAAS,SAAS,WAAA,CAAY,MAAA,GAAS,GAAG,GAAG,CAAA;AAE/E,EAAA,OAAO,KAAA;AAAA,IACL;AAAA,MACE,IAAA;AAAA,MACA,MAAA,CAAO,CAAC,WAAA,GAAc,IAAA,GAAO,UAAU,IAAA,CAAK,SAAA,EAAW,WAAW,CAAC,CAAC,CAAA;AAAA,MACpE,QAAA;AAAA,MACA,cAAc,IAAA,GAAO,QAAA;AAAA,MACrB;AAAA,KACF;AAAA,IACA,EAAE,IAAI,OAAA;AAAQ,GAChB;AACF;AAEA,SAAS,cAAA,CAAe,MAAqB,OAAA,EAA+B;AAC1E,EAAA,MAAM,UAAU,OAAA,CAAQ,iBAAA,GACpB,CAAC,GAAG,IAAA,CAAK,OAAO,CAAA,CAAE,IAAA;AAAA,IAAK,CAAC,CAAA,EAAG,CAAA,KACzB,CAAA,CAAE,GAAA,CAAI,aAAA,CAAc,CAAA,CAAE,GAAA,EAAK,MAAA,EAAW,EAAE,WAAA,EAAa,MAAA,EAAQ;AAAA,MAE/D,IAAA,CAAK,OAAA;AAET,EAAA,IAAI,OAAA,CAAQ,WAAW,CAAA,EAAG;AACxB,IAAA,OAAO,KAAA;AAAA,EACT;AAEA,EAAA,MAAM,OAAA,GAAU,OAAO,WAAW,CAAA;AAElC,EAAA,MAAM,SAAA,GAAY,OAAA,CAAQ,GAAA,CAAI,CAAC,OAAO,KAAA,KAAU;AAC9C,IAAA,MAAM,QAAA,GAAW,mBAAA,CAAoB,KAAA,EAAO,OAAO,CAAA;AACnD,IAAA,MAAM,MAAA,GAAS,KAAA,KAAU,OAAA,CAAQ,MAAA,GAAS,CAAA;AAC1C,IAAA,MAAM,SAAA,GAAY,MAAA,GACd,gBAAA,CAAiB,OAAA,EAAS,OAAA,EAAS,IAAA,EAAM,GAAG,CAAA,GAC5C,OAAA,CAAQ,EAAA,EAAI,GAAA,EAAK,EAAE,SAAS,CAAA;AAChC,IAAA,OAAO,CAAC,UAAU,SAAS,CAAA;AAAA,EAC7B,CAAC,CAAA;AAED,EAAA,OAAO,MAAM,CAAC,IAAA,EAAM,OAAO,CAAC,IAAA,EAAM,KAAK,IAAA,EAAM,SAAS,CAAC,CAAC,GAAG,IAAA,EAAM,GAAG,GAAG,EAAE,EAAA,EAAI,SAAS,CAAA;AACxF;AAEA,SAAS,mBAAA,CAAoB,MAA0B,OAAA,EAA+B;AACpF,EAAA,MAAM,MAAA,GAAS,eAAA,CAAgB,IAAA,CAAK,MAAA,EAAQ,OAAO,CAAA;AACnD,EAAA,MAAM,QAAA,GAAW,eAAA,CAAgB,IAAA,CAAK,KAAA,EAAO,OAAO,CAAA;AACpD,EAAA,OAAO,KAAA,CAAM,CAAC,MAAA,EAAQ,IAAA,EAAM,MAAA,CAAO,CAAC,IAAA,EAAM,QAAQ,CAAC,CAAC,CAAC,CAAA;AACvD;AAEA,SAAS,gBAAgB,IAAA,EAA2B;AAClD,EAAA,OAAO,YAAA,CAAa,KAAK,KAAK,CAAA;AAChC;AAEA,SAAS,qBAAA,CAAsB,MAAuB,OAAA,EAA+B;AACnF,EAAA,IAAI,IAAA,CAAK,QAAA,CAAS,MAAA,KAAW,CAAA,EAAG;AAC9B,IAAA,OAAO,IAAA;AAAA,EACT;AAEA,EAAA,IAAI,KAAK,QAAA,CAAS,MAAA,IAAU,CAAA,IAAK,CAAC,KAAK,UAAA,EAAY;AACjD,IAAA,OAAO,gBAAA,CAAiB,MAAM,OAAO,CAAA;AAAA,EACvC;AAEA,EAAA,MAAM,OAAA,GAAU,OAAO,OAAO,CAAA;AAC9B,EAAA,MAAM,cAAqB,EAAC;AAC5B,EAAA,IAAI,oBAA2B,EAAC;AAEhC,EAAA,MAAM,eAAA,GAAkB,CAAC,OAAA,KAAkB;AACzC,IAAA,IAAI,iBAAA,CAAkB,WAAW,CAAA,EAAG;AAClC,MAAA,IAAI,OAAA,EAAS;AACX,QAAA,WAAA,CAAY,KAAK,OAAO,CAAA;AAAA,MAC1B;AACA,MAAA;AAAA,IACF;AAEA,IAAA,MAAM,YAAA,GAAe,kBAAkB,MAAA,KAAW,CAAA,GAC9C,kBAAkB,CAAC,CAAA,GACnB,IAAA,CAAK,QAAA,EAAU,iBAAiB,CAAA;AAEpC,IAAA,IAAI,OAAA,EAAS;AACX,MAAA,WAAA,CAAY,KAAK,KAAA,CAAM,CAAC,cAAc,QAAA,EAAU,OAAO,CAAC,CAAC,CAAA;AAAA,IAC3D,CAAA,MAAO;AACL,MAAA,WAAA,CAAY,KAAK,YAAY,CAAA;AAAA,IAC/B;AACA,IAAA,iBAAA,GAAoB,EAAC;AAAA,EACvB,CAAA;AAEA,EAAA,KAAA,MAAW,OAAA,IAAW,KAAK,QAAA,EAAU;AACnC,IAAA,IAAI,qBAAA,CAAsB,OAAO,CAAA,EAAG;AAClC,MAAA,iBAAA,CAAkB,IAAA,CAAK,eAAA,CAAgB,OAAA,EAAS,OAAO,CAAC,CAAA;AACxD,MAAA;AAAA,IACF;AAEA,IAAA,MAAM,OAAA,GAAU,eAAA,CAAgB,OAAA,EAAS,OAAO,CAAA;AAChD,IAAA,eAAA,CAAgB,OAAO,CAAA;AAAA,EACzB;AAEA,EAAA,eAAA,EAAgB;AAChB,EAAA,MAAM,SAAA,GAAiB,CAAC,GAAA,EAAK,QAAQ,CAAA;AAErC,EAAA,OAAO,KAAA,CAAM,CAAC,GAAA,EAAK,MAAA,CAAO,CAAC,QAAA,EAAU,IAAA,CAAK,SAAA,EAAW,WAAW,CAAC,CAAC,CAAA,EAAG,QAAA,EAAU,GAAG,CAAA,EAAG;AAAA,IACnF,EAAA,EAAI;AAAA,GACL,CAAA;AACH;AAEA,SAAS,sBAAsB,IAAA,EAA+B;AAC5D,EAAA,IAAI,IAAA,CAAK,KAAA,CAAM,MAAA,KAAW,CAAA,EAAG;AAC3B,IAAA,OAAO,KAAA;AAAA,EACT;AAEA,EAAA,OAAO,IAAA,CAAK,KAAA,CAAM,KAAA,CAAM,CAAC,IAAA,KAAS;AAChC,IAAA,IAAI,IAAA,CAAK,SAAS,MAAA,EAAQ;AACxB,MAAA,OAAO,KAAA;AAAA,IACT;AACA,IAAA,MAAM,OAAA,GAAU,IAAA,CAAK,KAAA,CAAM,IAAA,EAAK;AAChC,IAAA,OAAO,QAAQ,UAAA,CAAW,GAAG,CAAA,IAAK,OAAA,CAAQ,SAAS,GAAG,CAAA;AAAA,EACxD,CAAC,CAAA;AACH;AAEA,SAAS,gBAAA,CAAiB,MAAuB,OAAA,EAA+B;AAC9E,EAAA,IAAI,IAAA,CAAK,QAAA,CAAS,MAAA,KAAW,CAAA,EAAG;AAC9B,IAAA,OAAO,IAAA;AAAA,EACT;AACA,EAAA,MAAM,OAAA,GAAU,OAAO,aAAa,CAAA;AACpC,EAAA,MAAM,WAAA,GAAc,KAAK,QAAA,CAAS,GAAA,CAAI,CAAC,OAAA,KAAY,eAAA,CAAgB,OAAA,EAAS,OAAO,CAAC,CAAA;AACpF,EAAA,IAAI,WAAA,CAAY,MAAA,KAAW,CAAA,IAAK,CAAC,KAAK,UAAA,EAAY;AAChD,IAAA,OAAO,MAAM,CAAC,GAAA,EAAK,MAAA,CAAO,CAAC,UAAU,WAAA,CAAY,CAAC,CAAC,CAAC,GAAG,QAAA,EAAU,GAAG,GAAG,EAAE,EAAA,EAAI,SAAS,CAAA;AAAA,EACxF;AAEA,EAAA,MAAM,WAAW,IAAA,CAAK,QAAA;AACtB,EAAA,MAAM,iBAAiB,IAAA,CAAK,UAAA,IAAe,CAAC,IAAA,CAAK,QAAA,IAAY,YAAY,MAAA,GAAS,CAAA;AAClF,EAAA,MAAM,YAAiB,QAAA,GACnB,CAAC,KAAK,cAAA,GAAiB,QAAA,GAAW,IAAI,CAAA,GACtC,QAAA;AACJ,EAAA,MAAM,WAAA,GAAc,QAAA,GAChB,cAAA,GACE,QAAA,GACA,IAAA,GACF,QAAA;AACJ,EAAA,MAAM,YAAA,GAAe,QAAA,GACjB,cAAA,GACE,QAAA,GACA,IAAA,GACF,QAAA;AAEJ,EAAA,OAAO,KAAA;AAAA,IACL;AAAA,MACE,GAAA;AAAA,MACA,OAAO,CAAC,WAAA,EAAa,KAAK,SAAA,EAAW,WAAW,CAAC,CAAC,CAAA;AAAA,MAClD,YAAA;AAAA,MACA;AAAA,KACF;AAAA,IACA,EAAE,IAAI,OAAA;AAAQ,GAChB;AACF;AAEA,SAAS,gBAAA,CACP,OAAA,EACA,OAAA,EACA,WAAA,EACA,SAAA,EACK;AACL,EAAA,IAAI,CAAC,WAAA,EAAa;AAChB,IAAA,OAAO,EAAA;AAAA,EACT;AACA,EAAA,QAAQ,QAAQ,aAAA;AAAe,IAC7B,KAAK,KAAA;AACH,MAAA,OAAO,SAAA;AAAA,IACT,KAAK,WAAA;AACH,MAAA,OAAO,OAAA,CAAQ,SAAA,EAAW,EAAA,EAAI,EAAE,SAAS,CAAA;AAAA,IAC3C,KAAK,MAAA;AAAA,IACL;AACE,MAAA,OAAO,EAAA;AAAA;AAEb;AAoCA,SAAS,sBAAA,CAAuB,OAAe,OAAA,EAAkC;AAC/E,EAAA,IAAI,CAAC,QAAQ,iBAAA,EAAmB;AAC9B,IAAA,OAAO,KAAA;AAAA,EACT;AAEA,EAAA,IAAI,CAAC,MAAM,UAAA,CAAW,GAAG,KAAK,CAAC,KAAA,CAAM,QAAA,CAAS,GAAG,CAAA,EAAG;AAClD,IAAA,OAAO,KAAA;AAAA,EACT;AAEA,EAAA,MAAM,KAAA,GAAQ,KAAA,CAAM,KAAA,CAAM,CAAA,EAAG,EAAE,CAAA;AAE/B,EAAA,IAAI,KAAA,CAAM,QAAA,CAAS,GAAG,CAAA,EAAG;AACvB,IAAA,OAAO,KAAA;AAAA,EACT;AAEA,EAAA,IAAI,SAAA,CAAU,IAAA,CAAK,KAAK,CAAA,EAAG;AACzB,IAAA,OAAO,KAAA;AAAA,EACT;AAEA,EAAA,OAAO,IAAI,KAAK,CAAA,CAAA,CAAA;AAClB;AAEA,SAAS,eAAe,IAAA,EAAmC;AACzD,EAAA,IAAI,IAAA,CAAK,SAAS,MAAA,EAAQ;AACxB,IAAA,MAAM,OAAA,GAAU,IAAA,CAAK,KAAA,CAAM,IAAA,EAAK;AAChC,IAAA,IAAI,YAAY,GAAA,EAAK;AACnB,MAAA,OAAO,IAAA;AAAA,IACT;AAAA,EACF;AACA,EAAA,OAAO,KAAA;AACT;;;AC1oBA,IAAM,SAAA,GAA+B;AAAA,EACnC;AAAA,IACE,IAAA,EAAM,YAAA;AAAA,IACN,OAAA,EAAS,CAAC,YAAY,CAAA;AAAA,IACtB,UAAA,EAAY,CAAC,MAAA,EAAQ,OAAA,EAAS,OAAO,CAAA;AAAA,IACrC,OAAA,EAAS,mBAAA;AAAA,IACT,OAAA,EAAS,YAAA;AAAA,IACT,kBAAA,EAAoB,GAAA;AAAA,IACpB,iBAAA,EAAmB,CAAC,YAAY;AAAA;AAEpC,CAAA;AAEA,IAAM,OAAA,GAA6B;AAAA,EACjC,UAAA,EAAY;AAAA,IACV,KAAA,EAAO,eAAA;AAAA,IACP,SAAA,EAAW,gBAAA;AAAA,IACX,QAAA;AAAA,IACA,MAAA;AAAA,IACA,SAAA,GAAY;AACV,MAAA,OAAO,KAAA;AAAA,IACT;AAAA;AAEJ,CAAA;AAEA,IAAM,QAAA,GAA+B;AAAA,EACnC,gBAAA,EAAkB;AACpB,CAAA;AAEA,IAAM,MAAA,GAAiB;AAAA,EACrB,SAAA;AAAA,EACA,OAAA;AAAA,EACA,QAAA;AAAA,EACA,OAAA,EAAS,aAAA;AAAA,EACT;AACF,CAAA;AAEOC,eAAA,GAAQ","file":"index.cjs","sourcesContent":["import type { ParserOptions, SupportOptions } from 'prettier';\r\n\r\nexport type TrailingCommaOption = 'none' | 'multiline' | 'all';\r\nexport type IndentStyleOption = 'spaces' | 'tabs';\r\nexport type BraceStyleOption = '1tbs' | 'allman';\r\nexport type KeywordCaseOption = 'preserve' | 'lower' | 'upper' | 'pascal';\r\n\r\nexport interface PluginConfiguration {\r\n  powershellIndentStyle: IndentStyleOption;\r\n  powershellIndentSize: number;\r\n  powershellTrailingComma: TrailingCommaOption;\r\n  powershellSortHashtableKeys: boolean;\r\n  powershellBlankLinesBetweenFunctions: number;\r\n  powershellBlankLineAfterParam: boolean;\r\n  powershellBraceStyle: BraceStyleOption;\r\n  powershellLineWidth: number;\r\n  powershellPreferSingleQuote: boolean;\r\n  powershellKeywordCase: KeywordCaseOption;\r\n  powershellRewriteAliases: boolean;\r\n  powershellRewriteWriteHost: boolean;\r\n}\r\n\r\nexport const pluginOptions: SupportOptions = {\r\n  powershellIndentStyle: {\r\n    category: 'PowerShell',\r\n    type: 'choice',\r\n    default: 'spaces',\r\n    description: 'Indent PowerShell code using spaces or tabs.',\r\n    choices: [\r\n      { value: 'spaces', description: 'Use spaces for indentation.' },\r\n      { value: 'tabs', description: 'Use tabs for indentation.' },\r\n    ],\r\n  },\r\n  powershellIndentSize: {\r\n    category: 'PowerShell',\r\n    type: 'int',\r\n    default: 2,\r\n    description: 'Number of indentation characters for each level.',\r\n    range: { start: 1, end: 8, step: 1 },\r\n  },\r\n  powershellTrailingComma: {\r\n    category: 'PowerShell',\r\n    type: 'choice',\r\n    default: 'multiline',\r\n    description: 'Control trailing commas for array and hashtable literals.',\r\n    choices: [\r\n      { value: 'none', description: 'Never add a trailing comma or semicolon.' },\r\n      {\r\n        value: 'multiline',\r\n        description: 'Add trailing comma/semicolon when the literal spans multiple lines.',\r\n      },\r\n      { value: 'all', description: 'Always add trailing comma/semicolon when possible.' },\r\n    ],\r\n  },\r\n  powershellSortHashtableKeys: {\r\n    category: 'PowerShell',\r\n    type: 'boolean',\r\n    default: false,\r\n    description: 'Sort hashtable keys alphabetically when formatting.',\r\n  },\r\n  powershellBlankLinesBetweenFunctions: {\r\n    category: 'PowerShell',\r\n    type: 'int',\r\n    default: 1,\r\n    description: 'Number of blank lines to ensure between function declarations.',\r\n    range: { start: 0, end: 3, step: 1 },\r\n  },\r\n  powershellBlankLineAfterParam: {\r\n    category: 'PowerShell',\r\n    type: 'boolean',\r\n    default: true,\r\n    description: 'Insert a blank line after param(...) blocks inside script blocks.',\r\n  },\r\n  powershellBraceStyle: {\r\n    category: 'PowerShell',\r\n    type: 'choice',\r\n    default: '1tbs',\r\n    description: 'Control placement of opening braces for script blocks and functions.',\r\n    choices: [\r\n      {\r\n        value: '1tbs',\r\n        description: 'One True Brace Style  keep opening braces on the same line.',\r\n      },\r\n      { value: 'allman', description: 'Allman style  place opening braces on the next line.' },\r\n    ],\r\n  },\r\n  powershellLineWidth: {\r\n    category: 'PowerShell',\r\n    type: 'int',\r\n    default: 120,\r\n    description: 'Maximum preferred line width for PowerShell documents.',\r\n    range: { start: 40, end: 200, step: 1 },\r\n  },\r\n  powershellPreferSingleQuote: {\r\n    category: 'PowerShell',\r\n    type: 'boolean',\r\n    default: false,\r\n    description: 'Prefer single-quoted strings when no interpolation is required.',\r\n  },\r\n  powershellKeywordCase: {\r\n    category: 'PowerShell',\r\n    type: 'choice',\r\n    default: 'preserve',\r\n    description: 'Normalise the casing of PowerShell keywords.',\r\n    choices: [\r\n      { value: 'preserve', description: 'Leave keyword casing unchanged.' },\r\n      { value: 'lower', description: 'Convert keywords to lower-case.' },\r\n      { value: 'upper', description: 'Convert keywords to upper-case.' },\r\n      { value: 'pascal', description: 'Capitalise keywords (PascalCase).' },\r\n    ],\r\n  },\r\n  powershellRewriteAliases: {\r\n    category: 'PowerShell',\r\n    type: 'boolean',\r\n    default: false,\r\n    description: 'Rewrite common cmdlet aliases to their canonical names.',\r\n  },\r\n  powershellRewriteWriteHost: {\r\n    category: 'PowerShell',\r\n    type: 'boolean',\r\n    default: false,\r\n    description: 'Rewrite Write-Host invocations to Write-Output to discourage host-only output.',\r\n  },\r\n};\r\n\r\nexport const defaultOptions = {\r\n  tabWidth: 2,\r\n};\r\n\r\nexport interface ResolvedOptions {\r\n  indentStyle: IndentStyleOption;\r\n  indentSize: number;\r\n  trailingComma: TrailingCommaOption;\r\n  sortHashtableKeys: boolean;\r\n  blankLinesBetweenFunctions: number;\r\n  blankLineAfterParam: boolean;\r\n  braceStyle: BraceStyleOption;\r\n  lineWidth: number;\r\n  preferSingleQuote: boolean;\r\n  keywordCase: KeywordCaseOption;\r\n  rewriteAliases: boolean;\r\n  rewriteWriteHost: boolean;\r\n}\r\n\r\nexport function resolveOptions(options: ParserOptions): ResolvedOptions {\r\n  const indentStyle = (options.powershellIndentStyle as IndentStyleOption | undefined) ?? 'spaces';\r\n  const rawIndentOverride = options.powershellIndentSize;\r\n  const normalizedIndentOverride = Number(rawIndentOverride);\r\n  const normalizedTabWidth = Number(options.tabWidth);\r\n  const indentSize = Number.isFinite(normalizedIndentOverride) && normalizedIndentOverride > 0\r\n    ? Math.floor(normalizedIndentOverride)\r\n    : Number.isFinite(normalizedTabWidth) && normalizedTabWidth > 0\r\n      ? Math.floor(normalizedTabWidth)\r\n      : 2;\r\n\r\n  if (indentStyle === 'tabs') {\r\n    options.useTabs = true;\r\n  } else {\r\n    options.useTabs = false;\r\n  }\r\n  options.tabWidth = indentSize;\r\n\r\n  const trailingComma =\r\n    (options.powershellTrailingComma as TrailingCommaOption | undefined) ?? 'multiline';\r\n  const sortHashtableKeys = Boolean(options.powershellSortHashtableKeys);\r\n  const rawBlankLines = Number(options.powershellBlankLinesBetweenFunctions ?? 1);\r\n  const normalizedBlankLines = Number.isFinite(rawBlankLines) ? rawBlankLines : 1;\r\n  const blankLinesBetweenFunctions = Math.max(0, Math.min(3, Math.floor(normalizedBlankLines)));\r\n  let blankLineAfterParam = true;\r\n  /* c8 ignore next */\r\n  if (options.powershellBlankLineAfterParam === false) {\r\n    blankLineAfterParam = false;\r\n  }\r\n  const braceStyle = (options.powershellBraceStyle as BraceStyleOption | undefined) ?? '1tbs';\r\n  const lineWidth = Math.max(40, Math.min(200, Number(options.powershellLineWidth ?? 120)));\r\n  const preferSingleQuote = options.powershellPreferSingleQuote === true;\r\n  const keywordCase =\r\n    (options.powershellKeywordCase as KeywordCaseOption | undefined) ?? 'preserve';\r\n  const rewriteAliases = options.powershellRewriteAliases === true;\r\n  const rewriteWriteHost = options.powershellRewriteWriteHost === true;\r\n\r\n  if (!options.printWidth || options.printWidth > lineWidth) {\r\n    options.printWidth = lineWidth;\r\n  }\r\n\r\n  return {\r\n    indentStyle,\r\n    indentSize,\r\n    trailingComma,\r\n    sortHashtableKeys,\r\n    blankLinesBetweenFunctions,\r\n    blankLineAfterParam,\r\n    braceStyle,\r\n    lineWidth,\r\n    preferSingleQuote,\r\n    keywordCase,\r\n    rewriteAliases,\r\n    rewriteWriteHost,\r\n  } satisfies ResolvedOptions;\r\n}\r\n","import type { HereStringNode } from './ast.js';\r\n\r\nexport type TokenType =\r\n  | 'newline'\r\n  | 'identifier'\r\n  | 'keyword'\r\n  | 'variable'\r\n  | 'number'\r\n  | 'string'\r\n  | 'heredoc'\r\n  | 'comment'\r\n  | 'block-comment'\r\n  | 'attribute'\r\n  | 'punctuation'\r\n  | 'operator'\r\n  | 'unknown';\r\n\r\nexport interface Token {\r\n  type: TokenType;\r\n  value: string;\r\n  start: number;\r\n  end: number;\r\n  quote?: 'single' | 'double';\r\n}\r\n\r\nconst KEYWORDS = new Set([\r\n  'function',\r\n  'if',\r\n  'elseif',\r\n  'else',\r\n  'for',\r\n  'foreach',\r\n  'while',\r\n  'switch',\r\n  'try',\r\n  'catch',\r\n  'finally',\r\n  'param',\r\n  'class',\r\n]);\r\n\r\nconst PUNCTUATION = new Set(['{', '}', '(', ')', '[', ']', ',', ';', '.', ':']);\r\n\r\nexport function tokenize(source: string): Token[] {\r\n  const tokens: Token[] = [];\r\n  const length = source.length;\r\n  let index = 0;\r\n\r\n  const push = (token: Token) => {\r\n    tokens.push(token);\r\n  };\r\n\r\n  while (index < length) {\r\n    const char = source[index];\r\n    const start = index;\r\n\r\n    if (char === '\\r' || char === '\\n') {\r\n      if (char === '\\r' && source[index + 1] === '\\n') {\r\n        index += 2;\r\n        push({ type: 'newline', value: '\\r\\n', start, end: index });\r\n      } else {\r\n        index += 1;\r\n        push({ type: 'newline', value: '\\n', start, end: index });\r\n      }\r\n      continue;\r\n    }\r\n\r\n    if (char === ' ' || char === '\\t' || char === '\\f') {\r\n      index += 1;\r\n      continue;\r\n    }\r\n\r\n    if (char === '<' && index + 1 < length && source[index + 1] === '#') {\r\n      let searchIndex = index + 2;\r\n      while (searchIndex < length - 1) {\r\n        if (source[searchIndex] === '#' && source[searchIndex + 1] === '>') {\r\n          searchIndex += 2;\r\n          break;\r\n        }\r\n        searchIndex += 1;\r\n      }\r\n      const end = searchIndex >= length ? length : searchIndex;\r\n      push({ type: 'block-comment', value: source.slice(start, end), start, end });\r\n      index = end;\r\n      continue;\r\n    }\r\n\r\n    if (char === '#') {\r\n      index += 1;\r\n      while (index < length && source[index] !== '\\r' && source[index] !== '\\n') {\r\n        index += 1;\r\n      }\r\n      push({ type: 'comment', value: source.slice(start + 1, index).trimEnd(), start, end: index });\r\n      continue;\r\n    }\r\n\r\n    if (char === '[') {\r\n      let lookahead = index + 1;\r\n      while (lookahead < length && /\\s/.test(source[lookahead])) {\r\n        lookahead += 1;\r\n      }\r\n      if (lookahead < length && /[A-Za-z_]/.test(source[lookahead])) {\r\n        let depth = 1;\r\n        let searchIndex = index + 1;\r\n        while (searchIndex < length && depth > 0) {\r\n          const current = source[searchIndex];\r\n          if (current === '\\'' || current === '\"') {\r\n            const quote = current;\r\n            searchIndex += 1;\r\n            while (searchIndex < length) {\r\n              const ch = source[searchIndex];\r\n              if (ch === '`') {\r\n                searchIndex += 2;\r\n                continue;\r\n              }\r\n              if (ch === quote) {\r\n                searchIndex += 1;\r\n                break;\r\n              }\r\n              searchIndex += 1;\r\n            }\r\n            continue;\r\n          }\r\n          if (current === '[') {\r\n            depth += 1;\r\n            searchIndex += 1;\r\n            continue;\r\n          }\r\n          if (current === ']') {\r\n            depth -= 1;\r\n            searchIndex += 1;\r\n            if (depth === 0) {\r\n              break;\r\n            }\r\n            continue;\r\n          }\r\n          searchIndex += 1;\r\n        }\r\n        const attributeEnd = depth === 0 ? searchIndex : length;\r\n        push({ type: 'attribute', value: source.slice(start, attributeEnd), start, end: attributeEnd });\r\n        index = attributeEnd;\r\n        continue;\r\n      }\r\n    }\r\n\r\n    if (char === '@' && (source[index + 1] === '\"' || source[index + 1] === \"'\")) {\r\n      const quoteChar = source[index + 1];\r\n      const quote = quoteChar === '\"' ? 'double' : 'single';\r\n      let searchIndex = index + 2;\r\n      let closing = -1;\r\n      while (searchIndex < length - 1) {\r\n        if (source[searchIndex] === quoteChar && source[searchIndex + 1] === '@') {\r\n          const prevChar = source[searchIndex - 1];\r\n          const prevPrev = source[searchIndex - 2];\r\n          const atImmediateClosing = searchIndex === index + 2;\r\n          const atUnixLineStart = prevChar === '\\n';\r\n          const atWindowsLineStart = prevChar === '\\r' && prevPrev === '\\n';\r\n          if (atImmediateClosing || atUnixLineStart || atWindowsLineStart) {\r\n            closing = searchIndex;\r\n            break;\r\n          }\r\n        }\r\n        searchIndex += 1;\r\n      }\r\n\r\n      let end = length;\r\n      /* c8 ignore next */\r\n      if (closing !== -1) {\r\n        end = closing + 2;\r\n      }\r\n\r\n      push({\r\n        type: 'heredoc',\r\n        value: source.slice(index, end),\r\n        start,\r\n        end,\r\n        quote,\r\n      });\r\n      index = end;\r\n      continue;\r\n    }\r\n\r\n    if (char === \"'\" || char === '\"') {\r\n      const quote = char === '\"' ? 'double' : 'single';\r\n      index += 1;\r\n      let escaped = false;\r\n      while (index < length) {\r\n        const current = source[index];\r\n        if (escaped) {\r\n          escaped = false;\r\n        } else if (current === '`') {\r\n          escaped = true;\r\n        } else if (current === char) {\r\n          index += 1;\r\n          break;\r\n        }\r\n        index += 1;\r\n      }\r\n      push({\r\n        type: 'string',\r\n        value: source.slice(start, index),\r\n        start,\r\n        end: index,\r\n        quote,\r\n      });\r\n      continue;\r\n    }\r\n\r\n    if (char === '@' && (source[index + 1] === '{' || source[index + 1] === '(')) {\r\n      const value = `@${source[index + 1]}`;\r\n      index += 2;\r\n      push({ type: 'operator', value, start, end: index });\r\n      continue;\r\n    }\r\n\r\n    if (char === ':' && source[index + 1] === ':') {\r\n      index += 2;\r\n      push({ type: 'operator', value: '::', start, end: index });\r\n      continue;\r\n    }\r\n\r\n    if (PUNCTUATION.has(char)) {\r\n      index += 1;\r\n      push({ type: 'punctuation', value: char, start, end: index });\r\n      continue;\r\n    }\r\n\r\n    if (char === '|' || char === '=') {\r\n      let value = char;\r\n      if (source[index + 1] === char) {\r\n        value += char;\r\n        index += 2;\r\n      } else {\r\n        index += 1;\r\n      }\r\n      push({ type: 'operator', value, start, end: index });\r\n      continue;\r\n    }\r\n\r\n    if (char === '>' || char === '<') {\r\n      let value = char;\r\n      if (source[index + 1] === char) {\r\n        value += char;\r\n        index += 2;\r\n      } else {\r\n        index += 1;\r\n      }\r\n      push({ type: 'operator', value, start, end: index });\r\n      continue;\r\n    }\r\n\r\n    if (char === '$') {\r\n      index += 1;\r\n      while (index < length) {\r\n        const c = source[index];\r\n        if (/^[A-Za-z0-9_:-]$/.test(c)) {\r\n          index += 1;\r\n          continue;\r\n        }\r\n        if (c === '{') {\r\n          index += 1;\r\n          while (index < length && source[index] !== '}') {\r\n            index += 1;\r\n          }\r\n          if (source[index] === '}') {\r\n            index += 1;\r\n          }\r\n          continue;\r\n        }\r\n        break;\r\n      }\r\n      push({ type: 'variable', value: source.slice(start, index), start, end: index });\r\n      continue;\r\n    }\r\n\r\n    if (/[0-9]/.test(char)) {\r\n      index += 1;\r\n      while (index < length && /[0-9]/.test(source[index])) {\r\n        index += 1;\r\n      }\r\n      if (source[index] === '.' && /[0-9]/.test(source[index + 1])) {\r\n        index += 2;\r\n        while (index < length && /[0-9]/.test(source[index])) {\r\n          index += 1;\r\n        }\r\n      }\r\n      push({ type: 'number', value: source.slice(start, index), start, end: index });\r\n      continue;\r\n    }\r\n\r\n    if (\r\n      /[A-Za-z_]/.test(char) ||\r\n      (char === '-' && index + 1 < length && /[-A-Za-z]/.test(source[index + 1]))\r\n    ) {\r\n      index += 1;\r\n      while (index < length && /[A-Za-z0-9_-]/.test(source[index])) {\r\n        index += 1;\r\n      }\r\n      const raw = source.slice(start, index);\r\n      const lower = raw.toLowerCase();\r\n      if (KEYWORDS.has(lower)) {\r\n        push({ type: 'keyword', value: raw, start, end: index });\r\n      } else {\r\n        push({ type: 'identifier', value: raw, start, end: index });\r\n      }\r\n      continue;\r\n    }\r\n\r\n    // fallback single character token\r\n    index += 1;\r\n    push({ type: 'unknown', value: char, start, end: index });\r\n  }\r\n\r\n  return tokens;\r\n}\r\n\r\nexport function normalizeHereString(node: HereStringNode): string {\r\n  const lines = node.value.split(/\\r?\\n/);\r\n  if (lines.length <= 2) {\r\n    return node.value;\r\n  }\r\n  return lines.slice(1, -1).join('\\n');\r\n}\r\n","import type { ParserOptions } from 'prettier';\r\n\r\nimport type {\r\n  ArrayLiteralNode,\r\n  BlankLineNode,\r\n  CommentNode,\r\n  ExpressionNode,\r\n  ExpressionPartNode,\r\n  FunctionDeclarationNode,\r\n  HashtableEntryNode,\r\n  HashtableNode,\r\n  HereStringNode,\r\n  ParenthesisNode,\r\n  PipelineNode,\r\n  ScriptBlockNode,\r\n  ScriptBodyNode,\r\n  ScriptNode,\r\n  TextNode,\r\n} from './ast.js';\r\nimport { resolveOptions } from './options.js';\r\nimport type { Token } from './tokenizer.js';\r\nimport { tokenize } from './tokenizer.js';\r\n\r\nclass Parser {\r\n  private index = 0;\r\n\r\n  constructor(\r\n    private readonly tokens: Token[],\r\n    private readonly source: string,\r\n  ) {}\r\n\r\n  parseScript(terminators: Set<string> = new Set()): ScriptNode {\r\n    const body: ScriptBodyNode[] = [];\r\n    const start = this.tokens.length > 0 ? this.tokens[0].start : 0;\r\n\r\n    while (!this.isEOF()) {\r\n      const token = this.peek()!;\r\n\r\n      if (terminators.has(token.value) && token.type === 'punctuation') {\r\n        break;\r\n      }\r\n\r\n      if (token.type === 'newline') {\r\n        const blank = this.consumeBlankLines();\r\n        body.push(blank);\r\n        continue;\r\n      }\r\n\r\n      if (token.type === 'comment' || token.type === 'block-comment') {\r\n        const commentToken = this.advance();\r\n        const commentNode = this.createCommentNode(commentToken, false);\r\n        if (body.length > 0) {\r\n          const previousNode = body[body.length - 1]!;\r\n          let lookahead = 0;\r\n          let nextToken: Token | undefined;\r\n          while (true) {\r\n            nextToken = this.peek(lookahead);\r\n            if (!nextToken) {\r\n              break;\r\n            }\r\n            if (nextToken.type === 'newline') {\r\n              lookahead += 1;\r\n              continue;\r\n            }\r\n            break;\r\n          }\r\n          if (previousNode.type === 'Pipeline') {\r\n            const lastSegment = previousNode.segments[previousNode.segments.length - 1];\r\n            const lastPart = lastSegment?.parts[lastSegment.parts.length - 1];\r\n            const belongsToBlock = Boolean(\r\n              lastPart &&\r\n              lastPart.type === 'ScriptBlock' &&\r\n              (commentNode.loc.start < lastPart.loc.end ||\r\n                (nextToken && nextToken.type === 'punctuation' && nextToken.value === '}')),\r\n            );\r\n            if (belongsToBlock && lastPart && lastPart.type === 'ScriptBlock') {\r\n              lastPart.body = [...lastPart.body, commentNode];\r\n              continue;\r\n            }\r\n          }\r\n          if (\r\n            previousNode.type === 'ScriptBlock' &&\r\n            (commentNode.loc.start < previousNode.loc.end ||\r\n              (nextToken && nextToken.type === 'punctuation' && nextToken.value === '}'))\r\n          ) {\r\n            previousNode.body = [...previousNode.body, commentNode];\r\n            continue;\r\n          }\r\n        }\r\n        body.push(commentNode);\r\n        continue;\r\n      }\r\n\r\n      if (this.isFunctionDeclaration()) {\r\n        body.push(this.parseFunction());\r\n        continue;\r\n      }\r\n\r\n      const statement = this.parseStatement();\r\n      if (statement) {\r\n        body.push(statement);\r\n      } else {\r\n        // avoid infinite loops\r\n        this.advance();\r\n      }\r\n    }\r\n\r\n    const end = body.length > 0 ? body[body.length - 1].loc.end : start;\r\n    return {\r\n      type: 'Script',\r\n      body,\r\n      loc: { start, end },\r\n    } satisfies ScriptNode;\r\n  }\r\n\r\n  private parseFunction(): FunctionDeclarationNode {\r\n    const startToken = this.advance(); // function keyword\r\n    const headerTokens: Token[] = [startToken];\r\n\r\n    while (!this.isEOF()) {\r\n      const token = this.peek()!;\r\n      if (token.type === 'comment') {\r\n        break;\r\n      }\r\n      if (token.type === 'punctuation' && token.value === '{') {\r\n        break;\r\n      }\r\n      headerTokens.push(this.advance());\r\n    }\r\n\r\n    const headerExpression = buildExpressionFromTokens(headerTokens, this.source);\r\n    const body = this.parseScriptBlock();\r\n    const end = body.loc.end;\r\n\r\n    return {\r\n      type: 'FunctionDeclaration',\r\n      header: headerExpression,\r\n      body,\r\n      loc: { start: startToken.start, end },\r\n    } satisfies FunctionDeclarationNode;\r\n  }\r\n\r\n  private parseStatement(): PipelineNode | null {\r\n    const segments: Token[][] = [[]];\r\n    let trailingComment: CommentNode | undefined;\r\n\r\n    const structureStack: string[] = [];\r\n    let lineContinuation = false;\r\n\r\n    while (!this.isEOF()) {\r\n      const token = this.peek()!;\r\n\r\n      if (token.type === 'newline') {\r\n        if (lineContinuation) {\r\n          this.advance();\r\n          lineContinuation = false;\r\n          continue;\r\n        }\r\n        /* c8 ignore next */\r\n        if (structureStack.length > 0) {\r\n          const newlineToken = this.advance();\r\n          segments[segments.length - 1].push(newlineToken);\r\n          continue;\r\n        }\r\n        if (structureStack.length === 0 && this.isPipelineContinuationAfterNewline()) {\r\n          this.advance();\r\n          continue;\r\n        }\r\n        break;\r\n      }\r\n\r\n      if (token.type === 'punctuation' && token.value === ';' && structureStack.length === 0) {\r\n        this.advance();\r\n        break;\r\n      }\r\n\r\n      if (token.type === 'punctuation' && token.value === '}' && structureStack.length === 0) {\r\n        break;\r\n      }\r\n\r\n      if (token.type === 'comment') {\r\n        if (this.isInlineComment(token)) {\r\n          trailingComment = this.createCommentNode(this.advance(), true);\r\n        }\r\n        break;\r\n      }\r\n\r\n      if (token.type === 'block-comment') {\r\n        break;\r\n      }\r\n\r\n      if (token.type === 'operator' && token.value === '|') {\r\n        this.advance();\r\n        segments.push([]);\r\n        lineContinuation = false;\r\n        continue;\r\n      }\r\n\r\n      /* c8 ignore next */\r\n      if (token.type === 'unknown' && token.value === '`') {\r\n        this.advance();\r\n        lineContinuation = true;\r\n        continue;\r\n      }\r\n\r\n      const currentSegment = segments[segments.length - 1];\r\n      currentSegment.push(this.advance());\r\n      lineContinuation = false;\r\n\r\n      if (isOpeningToken(token)) {\r\n        structureStack.push(token.value);\r\n      } else if (isClosingToken(token)) {\r\n        structureStack.pop();\r\n      }\r\n    }\r\n\r\n    const filteredSegments = segments.filter((segment) => segment.length > 0);\r\n    if (filteredSegments.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const expressionSegments = filteredSegments.map((segmentTokens) =>\r\n      buildExpressionFromTokens(segmentTokens, this.source),\r\n    );\r\n      const start = expressionSegments[0].loc.start;\r\n    const end = expressionSegments[expressionSegments.length - 1].loc.end;\r\n\r\n    const pipelineNode: PipelineNode = {\r\n      type: 'Pipeline',\r\n      segments: expressionSegments,\r\n        loc: { start, end },\r\n    };\r\n\r\n    if (trailingComment) {\r\n      pipelineNode.trailingComment = trailingComment;\r\n    }\r\n\r\n    return pipelineNode;\r\n  }\r\n\r\n  private parseScriptBlock(): ScriptBlockNode {\r\n    const openToken = this.peek();\r\n    if (!openToken || openToken.type !== 'punctuation' || openToken.value !== '{') {\r\n      return {\r\n        type: 'ScriptBlock',\r\n        body: [],\r\n        loc: { start: openToken?.start ?? 0, end: openToken?.end ?? 0 },\r\n      } satisfies ScriptBlockNode;\r\n    }\r\n    this.advance();\r\n\r\n    const { contentTokens, closingToken } = this.collectBalancedTokens(openToken);\r\n    const nestedParser = new Parser(contentTokens, this.source);\r\n    const script = nestedParser.parseScript(new Set());\r\n    const end = closingToken?.end ?? openToken.end;\r\n\r\n    return {\r\n      type: 'ScriptBlock',\r\n      body: script.body,\r\n      loc: { start: openToken.start, end },\r\n    } satisfies ScriptBlockNode;\r\n  }\r\n\r\n  private collectBalancedTokens(startToken: Token): {\r\n    contentTokens: Token[];\r\n    closingToken?: Token;\r\n  } {\r\n    const contentTokens: Token[] = [];\r\n    const stack: string[] = [startToken.value];\r\n\r\n    while (!this.isEOF()) {\r\n      const token = this.advance();\r\n\r\n      if (isOpeningToken(token)) {\r\n        stack.push(token.value);\r\n        contentTokens.push(token);\r\n        continue;\r\n      }\r\n\r\n      if (isClosingToken(token)) {\r\n        if (stack.length <= 1) {\r\n          return { contentTokens, closingToken: token };\r\n        }\r\n        stack.pop();\r\n        contentTokens.push(token);\r\n        continue;\r\n      }\r\n\r\n      contentTokens.push(token);\r\n    }\r\n\r\n    return { contentTokens };\r\n  }\r\n\r\n  private consumeBlankLines(): BlankLineNode {\r\n    let count = 0;\r\n    const start = this.peek()!.start;\r\n    let end = start;\r\n    while (!this.isEOF()) {\r\n      const token = this.peek();\r\n      if (!token || token.type !== 'newline') {\r\n        break;\r\n      }\r\n      const current = this.advance();\r\n      count += 1;\r\n      end = current.end;\r\n    }\r\n    return {\r\n      type: 'BlankLine',\r\n      count,\r\n      loc: { start, end },\r\n    } satisfies BlankLineNode;\r\n  }\r\n\r\n  private createCommentNode(token: Token, inline: boolean): CommentNode {\r\n    const style = token.type === 'block-comment' ? 'block' : 'line';\r\n    const isInline = style === 'line' && inline && this.isInlineComment(token);\r\n\r\n    return {\r\n      type: 'Comment',\r\n      value: token.value,\r\n      inline: isInline,\r\n      style,\r\n      loc: { start: token.start, end: token.end },\r\n    } satisfies CommentNode;\r\n  }\r\n\r\n  private isInlineComment(token: Token): boolean {\r\n    if (token.type !== 'comment') {\r\n      return false;\r\n    }\r\n    if (this.source.length === 0 || token.start === 0) {\r\n      return true;\r\n    }\r\n\r\n    let cursor = token.start - 1;\r\n    while (cursor >= 0) {\r\n      const char = this.source[cursor];\r\n      if (char === '\\n') {\r\n        return false;\r\n      }\r\n      if (char === '\\r') {\r\n        return false;\r\n      }\r\n      if (!/\\s/.test(char)) {\r\n        return true;\r\n      }\r\n      cursor -= 1;\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  private isPipelineContinuationAfterNewline(): boolean {\r\n    let offset = 1;\r\n    while (true) {\r\n      const next = this.peek(offset);\r\n      if (!next) {\r\n        return false;\r\n      }\r\n      if (next.type === 'newline') {\r\n        offset += 1;\r\n        continue;\r\n      }\r\n      if (next.type === 'comment') {\r\n        return false;\r\n      }\r\n      if (next.type === 'operator' && next.value === '|') {\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private isFunctionDeclaration(): boolean {\r\n    const token = this.peek();\r\n    return Boolean(token && token.type === 'keyword' && token.value.toLowerCase() === 'function');\r\n  }\r\n\r\n  private peek(offset = 0): Token | undefined {\r\n    return this.tokens[this.index + offset];\r\n  }\r\n\r\n  private advance(): Token {\r\n    const token = this.tokens[this.index];\r\n    this.index += 1;\r\n    return token;\r\n  }\r\n\r\n  private isEOF(): boolean {\r\n    return this.index >= this.tokens.length;\r\n  }\r\n}\r\n\r\nfunction isOpeningToken(token: Token): boolean {\r\n  if (token.type === 'operator') {\r\n    return token.value === '@{' || token.value === '@(';\r\n  }\r\n  return (\r\n    token.type === 'punctuation' &&\r\n    (token.value === '{' || token.value === '(' || token.value === '[')\r\n  );\r\n}\r\n\r\nfunction isClosingToken(token: Token): boolean {\r\n  return (\r\n    token.type === 'punctuation' &&\r\n    (token.value === '}' || token.value === ')' || token.value === ']')\r\n  );\r\n}\r\n\r\nfunction buildExpressionFromTokens(tokens: Token[], source: string = ''): ExpressionNode {\r\n  const firstToken = tokens.find((token) => token.type !== 'newline');\r\n  const lastToken = [...tokens].reverse().find((token) => token.type !== 'newline');\r\n  if (!firstToken || !lastToken) {\r\n    return {\r\n      type: 'Expression',\r\n      parts: [],\r\n      loc: { start: tokens[0]?.start ?? 0, end: tokens[tokens.length - 1]?.end ?? 0 },\r\n    } satisfies ExpressionNode;\r\n  }\r\n\r\n  const parts: ExpressionPartNode[] = [];\r\n  let index = 0;\r\n\r\n  while (index < tokens.length) {\r\n    const token = tokens[index];\r\n\r\n    if (token.type === 'newline') {\r\n      index += 1;\r\n      continue;\r\n    }\r\n\r\n    if (token.type === 'operator' && token.value === '@{') {\r\n      const { node, nextIndex } = parseHashtablePart(tokens, index, source);\r\n      parts.push(node);\r\n      index = nextIndex;\r\n      continue;\r\n    }\r\n\r\n    if (\r\n      (token.type === 'operator' && token.value === '@(') ||\r\n      (token.type === 'punctuation' && token.value === '[')\r\n    ) {\r\n      const { node, nextIndex } = parseArrayPart(tokens, index, source);\r\n      parts.push(node);\r\n      index = nextIndex;\r\n      continue;\r\n    }\r\n\r\n    if (token.type === 'punctuation' && token.value === '{') {\r\n      const { node, nextIndex } = parseScriptBlockPart(tokens, index, source);\r\n      parts.push(node);\r\n      index = nextIndex;\r\n      continue;\r\n    }\r\n\r\n    if (token.type === 'punctuation' && token.value === '(') {\r\n      const { node, nextIndex } = parseParenthesisPart(tokens, index, source);\r\n      parts.push(node);\r\n      index = nextIndex;\r\n      continue;\r\n    }\r\n\r\n    if (token.type === 'heredoc') {\r\n      parts.push(createHereStringNode(token));\r\n      index += 1;\r\n      continue;\r\n    }\r\n\r\n    if (token.type === 'attribute') {\r\n      parts.push(createTextNode(token));\r\n      index += 1;\r\n      continue;\r\n    }\r\n\r\n    parts.push(createTextNode(token));\r\n    index += 1;\r\n  }\r\n\r\n  return {\r\n    type: 'Expression',\r\n    parts,\r\n    loc: {\r\n      start: firstToken.start,\r\n      end: lastToken.end,\r\n    },\r\n  } satisfies ExpressionNode;\r\n}\r\n\r\nfunction parseHashtablePart(\r\n  tokens: Token[],\r\n  startIndex: number,\r\n  source: string = '',\r\n): { node: HashtableNode; nextIndex: number } {\r\n  const startToken = tokens[startIndex];\r\n  const { contentTokens, endIndex, closingToken } = collectStructureTokens(tokens, startIndex);\r\n  const entries = splitHashtableEntries(contentTokens).map((entryTokens) =>\r\n    buildHashtableEntry(entryTokens, source),\r\n  );\r\n  const end = closingToken?.end ?? contentTokens[contentTokens.length - 1]?.end ?? startToken.end;\r\n  return {\r\n    node: {\r\n      type: 'Hashtable',\r\n      entries,\r\n      loc: { start: startToken.start, end },\r\n    },\r\n    nextIndex: endIndex,\r\n  };\r\n}\r\n\r\nfunction resolveStructureEnd(\r\n  startToken: Token,\r\n  closingToken: Token | undefined,\r\n  contentTokens: Token[],\r\n): number {\r\n  if (closingToken) {\r\n    return closingToken.end;\r\n  }\r\n  const lastContent = contentTokens[contentTokens.length - 1];\r\n  if (lastContent) {\r\n    return lastContent.end;\r\n  }\r\n  return startToken.end;\r\n}\r\n\r\nfunction parseArrayPart(\r\n  tokens: Token[],\r\n  startIndex: number,\r\n  source: string = '',\r\n): { node: ArrayLiteralNode; nextIndex: number } {\r\n  const startToken = tokens[startIndex];\r\n  const { contentTokens, endIndex, closingToken } = collectStructureTokens(tokens, startIndex);\r\n  const elements = splitArrayElements(contentTokens).map((elementTokens) =>\r\n    buildExpressionFromTokens(elementTokens, source),\r\n  );\r\n  /* c8 ignore next */\r\n  const kind = startToken.value === '@(' ? 'implicit' : 'explicit';\r\n  const end = resolveStructureEnd(startToken, closingToken, contentTokens);\r\n  return {\r\n    node: {\r\n      type: 'ArrayLiteral',\r\n      elements,\r\n      kind,\r\n      loc: { start: startToken.start, end },\r\n    },\r\n    nextIndex: endIndex,\r\n  } satisfies { node: ArrayLiteralNode; nextIndex: number };\r\n}\r\n\r\nfunction parseParenthesisPart(\r\n  tokens: Token[],\r\n  startIndex: number,\r\n  source: string = '',\r\n): { node: ParenthesisNode; nextIndex: number } {\r\n  const startToken = tokens[startIndex];\r\n  const { contentTokens, endIndex, closingToken } = collectStructureTokens(tokens, startIndex);\r\n  const elements = splitArrayElements(contentTokens).map((elementTokens) =>\r\n    buildExpressionFromTokens(elementTokens, source),\r\n  );\r\n  const hasComma = hasTopLevelComma(contentTokens);\r\n  const hasNewline = contentTokens.some((token) => token.type === 'newline');\r\n  const end = resolveStructureEnd(startToken, closingToken, contentTokens);\r\n  return {\r\n    node: {\r\n      type: 'Parenthesis',\r\n      elements,\r\n      hasComma,\r\n      hasNewline,\r\n      loc: { start: startToken.start, end },\r\n    },\r\n    nextIndex: endIndex,\r\n  };\r\n}\r\n\r\nfunction parseScriptBlockPart(\r\n  tokens: Token[],\r\n  startIndex: number,\r\n  source: string = '',\r\n): { node: ScriptBlockNode; nextIndex: number } {\r\n  const startToken = tokens[startIndex];\r\n  const { contentTokens, endIndex, closingToken } = collectStructureTokens(tokens, startIndex);\r\n  const nestedParser = new Parser(contentTokens, source);\r\n  const script = nestedParser.parseScript();\r\n  const end = resolveStructureEnd(startToken, closingToken, contentTokens);\r\n  return {\r\n    node: {\r\n      type: 'ScriptBlock',\r\n      body: script.body,\r\n      loc: { start: startToken.start, end },\r\n    },\r\n    nextIndex: endIndex,\r\n  };\r\n}\r\n\r\nfunction createHereStringNode(token: Token): HereStringNode {\r\n  const quote = token.quote ?? 'double';\r\n  return {\r\n    type: 'HereString',\r\n    quote,\r\n    value: token.value,\r\n    loc: { start: token.start, end: token.end },\r\n  } satisfies HereStringNode;\r\n}\r\n\r\nfunction createTextNode(token: Token): TextNode {\r\n  const role =\r\n    token.type === 'identifier'\r\n      ? 'word'\r\n      : token.type === 'keyword'\r\n        ? 'keyword'\r\n        : token.type === 'number'\r\n          ? 'number'\r\n          : token.type === 'variable'\r\n            ? 'variable'\r\n            : token.type === 'string'\r\n              ? 'string'\r\n              : token.type === 'operator'\r\n                ? 'operator'\r\n                : token.type === 'punctuation'\r\n                  ? 'punctuation'\r\n                  : 'unknown';\r\n\r\n  return {\r\n    type: 'Text',\r\n    value: token.value,\r\n    role,\r\n    loc: { start: token.start, end: token.end },\r\n  } satisfies TextNode;\r\n}\r\n\r\nfunction collectStructureTokens(\r\n  tokens: Token[],\r\n  startIndex: number,\r\n): { contentTokens: Token[]; endIndex: number; closingToken?: Token } {\r\n  const contentTokens: Token[] = [];\r\n  const stack: string[] = [tokens[startIndex].value];\r\n  let index = startIndex + 1;\r\n\r\n  while (index < tokens.length) {\r\n    const token = tokens[index];\r\n\r\n    if (isOpeningToken(token)) {\r\n      stack.push(token.value);\r\n      contentTokens.push(token);\r\n      index += 1;\r\n      continue;\r\n    }\r\n\r\n    if (isClosingToken(token)) {\r\n      if (stack.length === 1) {\r\n        return { contentTokens, endIndex: index + 1, closingToken: token };\r\n      }\r\n      stack.pop();\r\n      contentTokens.push(token);\r\n      index += 1;\r\n      continue;\r\n    }\r\n\r\n    contentTokens.push(token);\r\n    index += 1;\r\n  }\r\n\r\n  return { contentTokens, endIndex: tokens.length };\r\n}\r\n\r\nfunction parseStatementForTest(tokens: Token[]): PipelineNode | null {\r\n  const parser = new Parser(tokens, '');\r\n  const internal = parser as unknown as { parseStatement(): PipelineNode | null };\r\n  return internal.parseStatement();\r\n}\r\n\r\nfunction splitHashtableEntries(tokens: Token[]): Token[][] {\r\n  const entries: Token[][] = [];\r\n  let current: Token[] = [];\r\n  const stack: string[] = [];\r\n\r\n  for (const token of tokens) {\r\n    if (token.type === 'newline' && stack.length === 0) {\r\n      if (current.length > 0) {\r\n        entries.push(current);\r\n        current = [];\r\n      }\r\n      continue;\r\n    }\r\n\r\n    if (token.type === 'punctuation' && token.value === ';' && stack.length === 0) {\r\n      if (current.length > 0) {\r\n        entries.push(current);\r\n        current = [];\r\n      }\r\n      continue;\r\n    }\r\n\r\n    if (isOpeningToken(token)) {\r\n      stack.push(token.value);\r\n      current.push(token);\r\n      continue;\r\n    }\r\n\r\n    if (isClosingToken(token)) {\r\n      stack.pop();\r\n      current.push(token);\r\n      continue;\r\n    }\r\n\r\n    current.push(token);\r\n  }\r\n\r\n  if (current.length > 0) {\r\n    entries.push(current);\r\n  }\r\n\r\n  return entries;\r\n}\r\n\r\nfunction buildHashtableEntry(tokens: Token[], source: string = ''): HashtableEntryNode {\r\n  const equalsIndex = findTopLevelEquals(tokens);\r\n  const keyTokens = equalsIndex === -1 ? tokens : tokens.slice(0, equalsIndex);\r\n  const valueTokens = equalsIndex === -1 ? [] : tokens.slice(equalsIndex + 1);\r\n  const keyExpression = buildExpressionFromTokens(keyTokens, source);\r\n  const valueExpression =\r\n    valueTokens.length > 0\r\n      ? buildExpressionFromTokens(valueTokens, source)\r\n      : buildExpressionFromTokens([], source);\r\n  const key = extractKeyText(keyTokens);\r\n  const start = keyTokens[0]?.start ?? valueTokens[0]?.start ?? 0;\r\n  const end =\r\n    (valueTokens[valueTokens.length - 1] ?? keyTokens[keyTokens.length - 1])?.end ?? start;\r\n\r\n  return {\r\n    type: 'HashtableEntry',\r\n    key,\r\n    rawKey: keyExpression,\r\n    value: valueExpression,\r\n    loc: { start, end },\r\n  } satisfies HashtableEntryNode;\r\n}\r\n\r\nfunction findTopLevelEquals(tokens: Token[]): number {\r\n  const stack: string[] = [];\r\n  for (let index = 0; index < tokens.length; index += 1) {\r\n    const token = tokens[index];\r\n    if (isOpeningToken(token)) {\r\n      stack.push(token.value);\r\n      continue;\r\n    }\r\n    if (isClosingToken(token)) {\r\n      stack.pop();\r\n      continue;\r\n    }\r\n    if (stack.length === 0 && token.type === 'operator' && token.value === '=') {\r\n      return index;\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n\r\nfunction extractKeyText(tokens: Token[]): string {\r\n  const text = tokens\r\n    .filter((token) => token.type !== 'newline')\r\n    .map((token) => token.value)\r\n    .join(' ')\r\n    .trim();\r\n  if (text.startsWith('\"') && text.endsWith('\"')) {\r\n    return text.slice(1, -1);\r\n  }\r\n  if (text.startsWith(\"'\") && text.endsWith(\"'\")) {\r\n    return text.slice(1, -1);\r\n  }\r\n  return text;\r\n}\r\n\r\nfunction splitArrayElements(tokens: Token[]): Token[][] {\r\n  const elements: Token[][] = [];\r\n  let current: Token[] = [];\r\n  const stack: string[] = [];\r\n\r\n  for (const token of tokens) {\r\n    if (token.type === 'newline' && stack.length === 0) {\r\n      if (current.length > 0) {\r\n        elements.push(current);\r\n        current = [];\r\n      }\r\n      continue;\r\n    }\r\n\r\n    if (token.type === 'punctuation' && token.value === ',' && stack.length === 0) {\r\n      elements.push(current);\r\n      current = [];\r\n      continue;\r\n    }\r\n\r\n    if (isOpeningToken(token)) {\r\n      stack.push(token.value);\r\n      current.push(token);\r\n      continue;\r\n    }\r\n\r\n    if (isClosingToken(token)) {\r\n      stack.pop();\r\n      current.push(token);\r\n      continue;\r\n    }\r\n\r\n    current.push(token);\r\n  }\r\n\r\n  if (current.length > 0) {\r\n    elements.push(current);\r\n  }\r\n\r\n  return elements;\r\n}\r\n\r\nfunction hasTopLevelComma(tokens: Token[]): boolean {\r\n  const stack: string[] = [];\r\n  for (const token of tokens) {\r\n    if (isOpeningToken(token)) {\r\n      stack.push(token.value);\r\n      continue;\r\n    }\r\n    if (isClosingToken(token)) {\r\n      stack.pop();\r\n      continue;\r\n    }\r\n    if (stack.length === 0 && token.type === 'punctuation' && token.value === ',') {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function parsePowerShell(source: string, options: ParserOptions): ScriptNode {\r\n  resolveOptions(options);\r\n  const tokens = tokenize(source);\r\n  const parser = new Parser(tokens, source);\r\n  return parser.parseScript();\r\n}\r\n\r\nexport function parseScriptWithTerminators(source: string, terminators: Set<string>): ScriptNode {\r\n  const tokens = tokenize(source);\r\n  const parser = new Parser(tokens, source);\r\n  return parser.parseScript(terminators);\r\n}\r\nexport const __parserTestUtils: {\r\n  isOpeningToken: typeof isOpeningToken;\r\n  isClosingToken: typeof isClosingToken;\r\n  collectStructureTokens: typeof collectStructureTokens;\r\n  splitHashtableEntries: typeof splitHashtableEntries;\r\n  findTopLevelEquals: typeof findTopLevelEquals;\r\n  extractKeyText: typeof extractKeyText;\r\n  splitArrayElements: typeof splitArrayElements;\r\n  hasTopLevelComma: typeof hasTopLevelComma;\r\n  parseScriptWithTerminators: typeof parseScriptWithTerminators;\r\n  buildExpressionFromTokens: typeof buildExpressionFromTokens;\r\n  createHereStringNode: typeof createHereStringNode;\r\n  createTextNode: typeof createTextNode;\r\n  buildHashtableEntry: typeof buildHashtableEntry;\r\n  resolveStructureEnd: typeof resolveStructureEnd;\r\n  parseStatementForTest: typeof parseStatementForTest;\r\n} = {\r\n  isOpeningToken,\r\n  isClosingToken,\r\n  collectStructureTokens,\r\n  splitHashtableEntries,\r\n  findTopLevelEquals,\r\n  extractKeyText,\r\n  splitArrayElements,\r\n  hasTopLevelComma,\r\n  parseScriptWithTerminators,\r\n  buildExpressionFromTokens,\r\n  createHereStringNode,\r\n  createTextNode,\r\n  buildHashtableEntry,\r\n  resolveStructureEnd,\r\n  parseStatementForTest,\r\n};\r\n\r\nexport const locStart = (node: { loc: { start: number } }): number => node.loc.start;\r\nexport const locEnd = (node: { loc: { end: number } }): number => node.loc.end;\r\n","import type { AstPath, Doc, ParserOptions, Printer } from 'prettier';\r\nimport { doc } from 'prettier';\r\n\r\nimport {\r\n  type ArrayLiteralNode,\r\n  type CommentNode,\r\n  type ExpressionNode,\r\n  type ExpressionPartNode,\r\n  type FunctionDeclarationNode,\r\n  type HashtableEntryNode,\r\n  type HashtableNode,\r\n  type HereStringNode,\r\n  type ParenthesisNode,\r\n  type PipelineNode,\r\n  type ScriptBlockNode,\r\n  type ScriptBodyNode,\r\n  type ScriptNode,\r\n  type TextNode,\r\n} from './ast.js';\r\nimport { resolveOptions, type ResolvedOptions } from './options.js';\r\n\r\nconst { group, indent, line, softline, hardline, join, ifBreak, lineSuffix, dedentToRoot, align } =\r\n  doc.builders;\r\n\r\nexport const powerShellPrinter: Printer<ScriptNode> = {\r\n  print(path: AstPath, options: ParserOptions) {\r\n    const node = path.getValue() as ScriptNode | ScriptBodyNode | ExpressionPartNode | undefined;\r\n    if (!node) {\r\n      return '';\r\n    }\r\n    const resolved = resolveOptions(options);\r\n    return printNode(node, resolved);\r\n  },\r\n};\r\n\r\nfunction printNode(\r\n  node: ScriptNode | ScriptBodyNode | ExpressionNode | ExpressionPartNode | HashtableEntryNode,\r\n  options: ResolvedOptions,\r\n): Doc {\r\n  switch (node.type) {\r\n    case 'Script':\r\n      return printScript(node, options);\r\n    case 'ScriptBlock':\r\n      return printScriptBlock(node, options);\r\n    case 'FunctionDeclaration':\r\n      return printFunction(node, options);\r\n    case 'Pipeline':\r\n      return printPipeline(node, options);\r\n    case 'Expression':\r\n      return printExpression(node, options);\r\n    case 'Text':\r\n      return printText(node, options);\r\n    case 'Comment':\r\n      return printComment(node);\r\n    case 'BlankLine':\r\n      return Array.from({ length: node.count }, () => hardline);\r\n    case 'ArrayLiteral':\r\n      return printArray(node, options);\r\n    case 'Hashtable':\r\n      return printHashtable(node, options);\r\n    case 'HashtableEntry':\r\n      return printHashtableEntry(node, options);\r\n    case 'HereString':\r\n      return printHereString(node);\r\n    case 'Parenthesis':\r\n      return printParenthesis(node, options);\r\n    default:\r\n      return '';\r\n  }\r\n}\r\n\r\nfunction concatDocs(docs: Doc[]): Doc {\r\n  if (docs.length === 0) {\r\n    return '';\r\n  }\r\n  let acc: Doc = docs[0];\r\n  for (let index = 1; index < docs.length; index += 1) {\r\n    acc = [acc, docs[index]] as Doc;\r\n  }\r\n  return acc;\r\n}\r\n\r\nfunction indentStatement(docToIndent: Doc, options: ResolvedOptions): Doc {\r\n  const indentUnit = options.indentStyle === 'tabs' ? '\\t' : ' '.repeat(options.indentSize);\r\n  return [indentUnit, align(indentUnit.length, docToIndent)] as Doc;\r\n}\r\n\r\nfunction printScript(node: ScriptNode, options: ResolvedOptions): Doc {\r\n  const bodyDoc = printStatementList(node.body, options, false);\r\n  if (!bodyDoc) {\r\n    return '';\r\n  }\r\n  return [bodyDoc, hardline];\r\n}\r\n\r\nfunction printStatementList(\r\n  body: ScriptBodyNode[],\r\n  options: ResolvedOptions,\r\n  indentStatements: boolean,\r\n): Doc {\r\n  const docs: Doc[] = [];\r\n  let previous: ScriptBodyNode | null = null;\r\n  let pendingBlankLines = 0;\r\n\r\n  for (const entry of body) {\r\n    if (entry.type === 'BlankLine') {\r\n      pendingBlankLines += entry.count;\r\n      continue;\r\n    }\r\n\r\n    if (previous) {\r\n      const blankLines = determineBlankLines(previous, entry, pendingBlankLines, options);\r\n      for (let index = 0; index < blankLines; index += 1) {\r\n        docs.push(hardline);\r\n      }\r\n    }\r\n\r\n    const printed = printNode(entry, options);\r\n    if (\r\n      entry.type === 'Comment' &&\r\n      previous &&\r\n      entry.loc.start < previous.loc.end &&\r\n      docs.length > 0\r\n    ) {\r\n      const commentDoc = indentStatements ? indentStatement(printed, options) : printed;\r\n      const lastIndex = docs.length - 1;\r\n      const combined = concatDocs([docs[lastIndex]!, hardline, commentDoc]);\r\n      docs[lastIndex] = combined;\r\n      previous = entry;\r\n      pendingBlankLines = 0;\r\n      continue;\r\n    }\r\n\r\n    docs.push(indentStatements ? indentStatement(printed, options) : printed);\r\n    previous = entry;\r\n    pendingBlankLines = 0;\r\n  }\r\n\r\n  return concatDocs(docs);\r\n}\r\n\r\nfunction determineBlankLines(\r\n  previous: ScriptBodyNode,\r\n  current: ScriptBodyNode,\r\n  pendingBlankLines: number,\r\n  options: ResolvedOptions,\r\n): number {\r\n  let base = pendingBlankLines > 0 ? pendingBlankLines : 1;\r\n  const desiredFunctionSpacing = options.blankLinesBetweenFunctions + 1;\r\n\r\n  if (\r\n    (previous.type === 'FunctionDeclaration' && current.type === 'FunctionDeclaration') ||\r\n    (previous.type === 'FunctionDeclaration' && current.type !== 'BlankLine') ||\r\n    (current.type === 'FunctionDeclaration' && previous.type !== 'BlankLine')\r\n  ) {\r\n    base = Math.max(base, desiredFunctionSpacing);\r\n  }\r\n\r\n  if (options.blankLineAfterParam && isParamStatement(previous)) {\r\n    base = Math.max(base, 2);\r\n  }\r\n\r\n  return base;\r\n}\r\n\r\nfunction printScriptBlock(node: ScriptBlockNode, options: ResolvedOptions): Doc {\r\n  if (node.body.length === 0) {\r\n    return '{}';\r\n  }\r\n\r\n  const bodyDoc = printStatementList(node.body, options, true);\r\n  return group(['{', hardline, bodyDoc, hardline, '}']);\r\n}\r\n\r\nfunction printFunction(node: FunctionDeclarationNode, options: ResolvedOptions): Doc {\r\n  const headerDoc = printExpression(node.header, options);\r\n  const bodyDoc = printScriptBlock(node.body, options);\r\n  if (options.braceStyle === 'allman') {\r\n    return group([headerDoc, hardline, bodyDoc]);\r\n  }\r\n  return group([headerDoc, ' ', bodyDoc]);\r\n}\r\n\r\nfunction printPipeline(node: PipelineNode, options: ResolvedOptions): Doc {\r\n  const segmentDocs = node.segments.map((segment) => printExpression(segment, options));\r\n  if (segmentDocs.length === 0) {\r\n    return '';\r\n  }\r\n\r\n  let pipelineDoc: Doc = segmentDocs[0];\r\n\r\n  if (segmentDocs.length > 1) {\r\n    const restDocs = segmentDocs.slice(1).map((segmentDoc) => [line, ['| ', segmentDoc]]);\r\n    pipelineDoc = group([segmentDocs[0], indent(restDocs.flatMap((docItem) => docItem))]);\r\n  }\r\n\r\n  if (node.trailingComment) {\r\n    if (node.trailingComment.inline) {\r\n      pipelineDoc = [pipelineDoc, lineSuffix([' #', node.trailingComment.value])];\r\n    } else {\r\n      pipelineDoc = [pipelineDoc, hardline, printComment(node.trailingComment)];\r\n    }\r\n  }\r\n\r\n  return pipelineDoc;\r\n}\r\n\r\nfunction printExpression(node: ExpressionNode, options: ResolvedOptions): Doc {\r\n  const docs: Doc[] = [];\r\n  let previous: ExpressionPartNode | null = null;\r\n\r\n  for (const part of node.parts) {\r\n    if (shouldSkipPart(part)) {\r\n      continue;\r\n    }\r\n\r\n    if (part.type === 'Parenthesis' && isParamKeyword(previous)) {\r\n      docs.push(printParamParenthesis(part, options));\r\n      previous = part;\r\n      continue;\r\n    }\r\n\r\n    if (previous) {\r\n      const separator = gapBetween(previous, part);\r\n      if (separator) {\r\n        docs.push(separator);\r\n      }\r\n    }\r\n\r\n    docs.push(printNode(part, options));\r\n    previous = part;\r\n  }\r\n\r\n  return docs.length === 0 ? '' : group(docs);\r\n}\r\n\r\nfunction gapBetween(previous: ExpressionPartNode, current: ExpressionPartNode): Doc | null {\r\n  const prevSymbol = getSymbol(previous);\r\n  const currentSymbol = getSymbol(current);\r\n\r\n  if (current.type === 'Parenthesis') {\r\n    if (previous && previous.type === 'Text') {\r\n      if (previous.value.toLowerCase() === 'param') {\r\n        return null;\r\n      }\r\n      if (previous.role === 'keyword') {\r\n        return ' ';\r\n      }\r\n      return null;\r\n    }\r\n    return ' ';\r\n  }\r\n\r\n  if (previous.type === 'Parenthesis') {\r\n    if (currentSymbol && NO_SPACE_BEFORE.has(currentSymbol)) {\r\n      return null;\r\n    }\r\n    return ' ';\r\n  }\r\n\r\n  if (!prevSymbol && !currentSymbol) {\r\n    return ' ';\r\n  }\r\n\r\n  if (!prevSymbol) {\r\n    if (currentSymbol && NO_SPACE_BEFORE.has(currentSymbol)) {\r\n      return null;\r\n    }\r\n    return ' ';\r\n  }\r\n\r\n  if (NO_SPACE_AFTER.has(prevSymbol)) {\r\n    return null;\r\n  }\r\n\r\n  if (currentSymbol && NO_SPACE_BEFORE.has(currentSymbol)) {\r\n    return null;\r\n  }\r\n\r\n  if (prevSymbol && currentSymbol && SYMBOL_NO_GAP.has(`${prevSymbol}:${currentSymbol}`)) {\r\n    return null;\r\n  }\r\n\r\n  /* c8 ignore next */\r\n  if (prevSymbol === '=' || currentSymbol === '=') {\r\n    return ' ';\r\n  }\r\n\r\n  if (\r\n    current.type === 'ScriptBlock' ||\r\n    current.type === 'Hashtable' ||\r\n    current.type === 'ArrayLiteral'\r\n  ) {\r\n    return ' ';\r\n  }\r\n\r\n  return ' ';\r\n}\r\n\r\nfunction isParamStatement(node: ScriptBodyNode | null): boolean {\r\n  if (!node || node.type !== 'Pipeline') {\r\n    return false;\r\n  }\r\n  if (node.segments.length === 0) {\r\n    return false;\r\n  }\r\n  const firstSegment = node.segments[0];\r\n  if (firstSegment.parts.length === 0) {\r\n    return false;\r\n  }\r\n  const firstPart = firstSegment.parts.find((part) => part.type === 'Text');\r\n  if (!firstPart || firstPart.type !== 'Text') {\r\n    return false;\r\n  }\r\n  return firstPart.value.toLowerCase() === 'param';\r\n}\r\n\r\nconst NO_SPACE_BEFORE = new Set([')', ']', '}', ',', ';', '.', '::', '>', '<']);\r\nconst NO_SPACE_AFTER = new Set(['(', '[', '{', '.', '>', '<']);\r\nconst SYMBOL_NO_GAP = new Set(['.:word', '::word', 'word:(', 'word:[']);\r\n\r\nfunction getSymbol(node: ExpressionPartNode | null): string | null {\r\n  if (!node) {\r\n    return null;\r\n  }\r\n  if (node.type === 'Text' && (node.role === 'punctuation' || node.role === 'operator')) {\r\n    return node.value;\r\n  }\r\n  if (node.type === 'Parenthesis') {\r\n    return '(';\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction isParamKeyword(node: ExpressionPartNode | null): boolean {\r\n  return Boolean(node && node.type === 'Text' && node.value.toLowerCase() === 'param');\r\n}\r\n\r\nconst KEYWORD_CASE_TRANSFORMS: Record<string, (value: string) => string> = {\r\n  preserve: (value) => value,\r\n  lower: (value) => value.toLowerCase(),\r\n  upper: (value) => value.toUpperCase(),\r\n  pascal: (value) =>\r\n    value.length === 0 ? value : value[0].toUpperCase() + value.slice(1).toLowerCase(),\r\n};\r\n\r\nconst CMDLET_ALIAS_MAP: Record<string, string> = {\r\n  gi: 'Get-Item',\r\n  gci: 'Get-ChildItem',\r\n  ls: 'Get-ChildItem',\r\n  dir: 'Get-ChildItem',\r\n  ld: 'Get-ChildItem',\r\n  la: 'Get-ChildItem',\r\n  gcm: 'Get-Command',\r\n  gm: 'Get-Member',\r\n  gps: 'Get-Process',\r\n  ps: 'Get-Process',\r\n  gwmi: 'Get-WmiObject',\r\n  gsv: 'Get-Service',\r\n  cat: 'Get-Content',\r\n  gc: 'Get-Content',\r\n  echo: 'Write-Output',\r\n  write: 'Write-Output',\r\n  '%': 'ForEach-Object',\r\n  foreach: 'ForEach-Object',\r\n  '?': 'Where-Object',\r\n  where: 'Where-Object',\r\n};\r\n\r\nconst DISALLOWED_CMDLET_REWRITE = new Map([['write-host', 'Write-Output']]);\r\n\r\nfunction printText(node: TextNode, options: ResolvedOptions): Doc {\r\n  if (node.role === 'string') {\r\n    return normalizeStringLiteral(node.value, options);\r\n  }\r\n\r\n  let value = node.value;\r\n\r\n  if (node.role === 'keyword') {\r\n    const transform =\r\n      KEYWORD_CASE_TRANSFORMS[options.keywordCase] ?? KEYWORD_CASE_TRANSFORMS.preserve;\r\n    value = transform(value);\r\n  }\r\n\r\n  if (\r\n    options.rewriteAliases &&\r\n    (node.role === 'word' || node.role === 'operator' || node.role === 'unknown')\r\n  ) {\r\n    const aliasKey = value.toLowerCase();\r\n    if (Object.prototype.hasOwnProperty.call(CMDLET_ALIAS_MAP, aliasKey)) {\r\n      value = CMDLET_ALIAS_MAP[aliasKey]!;\r\n    }\r\n  }\r\n\r\n  if (node.role === 'word' && options.rewriteWriteHost) {\r\n    const replacement = DISALLOWED_CMDLET_REWRITE.get(value.toLowerCase());\r\n    if (replacement) {\r\n      value = replacement;\r\n    }\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\nfunction printComment(node: CommentNode): Doc {\r\n  if (node.style === 'block') {\r\n    return node.value;\r\n  }\r\n  return ['#', node.value];\r\n}\r\n\r\nfunction printArray(node: ArrayLiteralNode, options: ResolvedOptions): Doc {\r\n  const open = node.kind === 'implicit' ? '@(' : '[';\r\n  const close = node.kind === 'implicit' ? ')' : ']';\r\n  if (node.elements.length === 0) {\r\n    return [open, close];\r\n  }\r\n  const groupId = Symbol('array');\r\n  const elementDocs = node.elements.map((element) => printExpression(element, options));\r\n  const shouldBreak = elementDocs.length > 1;\r\n  const separator: Doc = [',', line];\r\n  const trailing = trailingCommaDoc(options, groupId, elementDocs.length > 0, ',');\r\n\r\n  return group(\r\n    [\r\n      open,\r\n      indent([shouldBreak ? line : softline, join(separator, elementDocs)]),\r\n      trailing,\r\n      shouldBreak ? line : softline,\r\n      close,\r\n    ],\r\n    { id: groupId },\r\n  );\r\n}\r\n\r\nfunction printHashtable(node: HashtableNode, options: ResolvedOptions): Doc {\r\n  const entries = options.sortHashtableKeys\r\n    ? [...node.entries].sort((a, b) =>\r\n        a.key.localeCompare(b.key, undefined, { sensitivity: 'base' }),\r\n      )\r\n    : node.entries;\r\n\r\n  if (entries.length === 0) {\r\n    return '@{}';\r\n  }\r\n\r\n  const groupId = Symbol('hashtable');\r\n\r\n  const entryDocs = entries.map((entry, index) => {\r\n    const entryDoc = printHashtableEntry(entry, options);\r\n    const isLast = index === entries.length - 1;\r\n    const separator = isLast\r\n      ? trailingCommaDoc(options, groupId, true, ';')\r\n      : ifBreak('', ';', { groupId });\r\n    return [entryDoc, separator];\r\n  });\r\n\r\n  return group(['@{', indent([line, join(line, entryDocs)]), line, '}'], { id: groupId });\r\n}\r\n\r\nfunction printHashtableEntry(node: HashtableEntryNode, options: ResolvedOptions): Doc {\r\n  const keyDoc = printExpression(node.rawKey, options);\r\n  const valueDoc = printExpression(node.value, options);\r\n  return group([keyDoc, ' =', indent([line, valueDoc])]);\r\n}\r\n\r\nfunction printHereString(node: HereStringNode): Doc {\r\n  return dedentToRoot(node.value);\r\n}\r\n\r\nfunction printParamParenthesis(node: ParenthesisNode, options: ResolvedOptions): Doc {\r\n  if (node.elements.length === 0) {\r\n    return '()';\r\n  }\r\n\r\n  if (node.elements.length <= 1 && !node.hasNewline) {\r\n    return printParenthesis(node, options);\r\n  }\r\n\r\n  const groupId = Symbol('param');\r\n  const elementDocs: Doc[] = [];\r\n  let pendingAttributes: Doc[] = [];\r\n\r\n  const flushAttributes = (nextDoc?: Doc) => {\r\n    if (pendingAttributes.length === 0) {\r\n      if (nextDoc) {\r\n        elementDocs.push(nextDoc);\r\n      }\r\n      return;\r\n    }\r\n\r\n    const attributeDoc = pendingAttributes.length === 1\r\n      ? pendingAttributes[0]\r\n      : join(hardline, pendingAttributes);\r\n\r\n    if (nextDoc) {\r\n      elementDocs.push(group([attributeDoc, hardline, nextDoc]));\r\n    } else {\r\n      elementDocs.push(attributeDoc);\r\n    }\r\n    pendingAttributes = [];\r\n  };\r\n\r\n  for (const element of node.elements) {\r\n    if (isAttributeExpression(element)) {\r\n      pendingAttributes.push(printExpression(element, options));\r\n      continue;\r\n    }\r\n\r\n    const printed = printExpression(element, options);\r\n    flushAttributes(printed);\r\n  }\r\n\r\n  flushAttributes();\r\n  const separator: Doc = [',', hardline];\r\n\r\n  return group(['(', indent([hardline, join(separator, elementDocs)]), hardline, ')'], {\r\n    id: groupId,\r\n  });\r\n}\r\n\r\nfunction isAttributeExpression(node: ExpressionNode): boolean {\r\n  if (node.parts.length === 0) {\r\n    return false;\r\n  }\r\n\r\n  return node.parts.every((part) => {\r\n    if (part.type !== 'Text') {\r\n      return false;\r\n    }\r\n    const trimmed = part.value.trim();\r\n    return trimmed.startsWith('[') && trimmed.endsWith(']');\r\n  });\r\n}\r\n\r\nfunction printParenthesis(node: ParenthesisNode, options: ResolvedOptions): Doc {\r\n  if (node.elements.length === 0) {\r\n    return '()';\r\n  }\r\n  const groupId = Symbol('parenthesis');\r\n  const elementDocs = node.elements.map((element) => printExpression(element, options));\r\n  if (elementDocs.length === 1 && !node.hasNewline) {\r\n    return group(['(', indent([softline, elementDocs[0]]), softline, ')'], { id: groupId });\r\n  }\r\n\r\n  const hasComma = node.hasComma;\r\n  const forceMultiline = node.hasNewline || (!node.hasComma && elementDocs.length > 1);\r\n  const separator: Doc = hasComma\r\n    ? [',', forceMultiline ? hardline : line]\r\n    : hardline;\r\n  const leadingLine = hasComma\r\n    ? forceMultiline\r\n      ? hardline\r\n      : line\r\n    : hardline;\r\n  const trailingLine = hasComma\r\n    ? forceMultiline\r\n      ? hardline\r\n      : line\r\n    : hardline;\r\n\r\n  return group(\r\n    [\r\n      '(',\r\n      indent([leadingLine, join(separator, elementDocs)]),\r\n      trailingLine,\r\n      ')',\r\n    ],\r\n    { id: groupId },\r\n  );\r\n}\r\n\r\nfunction trailingCommaDoc(\r\n  options: ResolvedOptions,\r\n  groupId: symbol,\r\n  hasElements: boolean,\r\n  delimiter: ',' | ';',\r\n): Doc {\r\n  if (!hasElements) {\r\n    return '';\r\n  }\r\n  switch (options.trailingComma) {\r\n    case 'all':\r\n      return delimiter;\r\n    case 'multiline':\r\n      return ifBreak(delimiter, '', { groupId });\r\n    case 'none':\r\n    default:\r\n      return '';\r\n  }\r\n}\r\n\r\nexport function createPrinter(): Printer<ScriptNode> {\r\n  return powerShellPrinter;\r\n}\r\n\r\nexport const __printerTestUtils: {\r\n  gapBetween: typeof gapBetween;\r\n  getSymbol: typeof getSymbol;\r\n  shouldSkipPart: typeof shouldSkipPart;\r\n  normalizeStringLiteral: typeof normalizeStringLiteral;\r\n  printParamParenthesis: typeof printParamParenthesis;\r\n  printPipeline: typeof printPipeline;\r\n  trailingCommaDoc: typeof trailingCommaDoc;\r\n  isParamStatement: typeof isParamStatement;\r\n  printNode: typeof printNode;\r\n  printScript: typeof printScript;\r\n  concatDocs: typeof concatDocs;\r\n  indentStatement: typeof indentStatement;\r\n  printStatementList: typeof printStatementList;\r\n} = {\r\n  gapBetween,\r\n  getSymbol,\r\n  shouldSkipPart,\r\n  normalizeStringLiteral,\r\n  printParamParenthesis,\r\n  printPipeline,\r\n  trailingCommaDoc,\r\n  isParamStatement,\r\n  printNode,\r\n  printScript,\r\n  concatDocs,\r\n  indentStatement,\r\n  printStatementList,\r\n};\r\n\r\nfunction normalizeStringLiteral(value: string, options: ResolvedOptions): string {\r\n  if (!options.preferSingleQuote) {\r\n    return value;\r\n  }\r\n\r\n  if (!value.startsWith('\"') || !value.endsWith('\"')) {\r\n    return value;\r\n  }\r\n\r\n  const inner = value.slice(1, -1);\r\n\r\n  if (inner.includes(\"'\")) {\r\n    return value;\r\n  }\r\n\r\n  if (/[`$\"\\n]/.test(inner)) {\r\n    return value;\r\n  }\r\n\r\n  return `'${inner}'`;\r\n}\r\n\r\nfunction shouldSkipPart(part: ExpressionPartNode): boolean {\r\n  if (part.type === 'Text') {\r\n    const trimmed = part.value.trim();\r\n    if (trimmed === '`') {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n","import type { Plugin, SupportLanguage } from 'prettier';\n\nimport { pluginOptions, defaultOptions } from './options.js';\nimport { parsePowerShell, locEnd, locStart } from './parser.js';\nimport { powerShellPrinter } from './printer.js';\n\nconst languages: SupportLanguage[] = [\n  {\n    name: 'PowerShell',\n    parsers: ['powershell'],\n    extensions: ['.ps1', '.psm1', '.psd1'],\n    tmScope: 'source.powershell',\n    aceMode: 'powershell',\n    linguistLanguageId: 131,\n    vscodeLanguageIds: ['powershell'],\n  },\n] as const;\n\nconst parsers: Plugin['parsers'] = {\n  powershell: {\n    parse: parsePowerShell,\n    astFormat: 'powershell-ast',\n    locStart,\n    locEnd,\n    hasPragma() {\n      return false;\n    },\n  },\n} as const;\n\nconst printers: Plugin['printers'] = {\n  'powershell-ast': powerShellPrinter,\n};\n\nconst plugin: Plugin = {\n  languages,\n  parsers,\n  printers,\n  options: pluginOptions,\n  defaultOptions,\n};\n\nexport default plugin;\n"]}