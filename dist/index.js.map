{"version":3,"sources":["../src/tokenizer.ts","../src/options.ts","../src/parser.ts","../src/printer.ts","../src/index.ts"],"sourcesContent":["import type { HereStringNode } from './ast.js';\r\n\r\nexport type TokenType =\r\n  | 'newline'\r\n  | 'identifier'\r\n  | 'keyword'\r\n  | 'variable'\r\n  | 'number'\r\n  | 'string'\r\n  | 'heredoc'\r\n  | 'comment'\r\n  | 'punctuation'\r\n  | 'operator'\r\n  | 'unknown';\r\n\r\nexport interface Token {\r\n  type: TokenType;\r\n  value: string;\r\n  start: number;\r\n  end: number;\r\n  quote?: 'single' | 'double';\r\n}\r\n\r\nconst KEYWORDS = new Set([\r\n  'function',\r\n  'if',\r\n  'elseif',\r\n  'else',\r\n  'for',\r\n  'foreach',\r\n  'while',\r\n  'switch',\r\n  'try',\r\n  'catch',\r\n  'finally',\r\n  'param',\r\n  'class'\r\n]);\r\n\r\nconst PUNCTUATION = new Set(['{', '}', '(', ')', '[', ']', ',', ';', '.', ':']);\r\nconst OPERATORS = new Set(['|', '=', '==', '!=', '-eq', '-ne', '-gt', '-lt', '-ge', '-le', '=>', '::']);\r\n\r\nexport function tokenize(source: string): Token[] {\r\n  const tokens: Token[] = [];\r\n  const length = source.length;\r\n  let index = 0;\r\n\r\n  const push = (token: Token) => {\r\n    tokens.push(token);\r\n  };\r\n\r\n  while (index < length) {\r\n    const char = source[index];\r\n    const start = index;\r\n\r\n    if (char === '\\r' || char === '\\n') {\r\n      if (char === '\\r' && source[index + 1] === '\\n') {\r\n        index += 2;\r\n        push({ type: 'newline', value: '\\r\\n', start, end: index });\r\n      } else {\r\n        index += 1;\r\n        push({ type: 'newline', value: '\\n', start, end: index });\r\n      }\r\n      continue;\r\n    }\r\n\r\n    if (char === ' ' || char === '\\t' || char === '\\f') {\r\n      index += 1;\r\n      continue;\r\n    }\r\n\r\n    if (char === '#' ) {\r\n      index += 1;\r\n      while (index < length && source[index] !== '\\r' && source[index] !== '\\n') {\r\n        index += 1;\r\n      }\r\n      push({ type: 'comment', value: source.slice(start + 1, index).trimEnd(), start, end: index });\r\n      continue;\r\n    }\r\n\r\n    if (char === '@' && (source[index + 1] === '\"' || source[index + 1] === '\\'')) {\r\n      const quoteChar = source[index + 1];\r\n      const quote = quoteChar === '\"' ? 'double' : 'single';\r\n      let searchIndex = index + 2;\r\n      let closing = -1;\r\n      while (searchIndex < length - 1) {\r\n        if (source[searchIndex] === quoteChar && source[searchIndex + 1] === '@') {\r\n          const prevChar = source[searchIndex - 1];\r\n          const prevPrev = source[searchIndex - 2];\r\n          if (\r\n            searchIndex === index + 2 ||\r\n            prevChar === '\\n' ||\r\n            (prevChar === '\\r' && prevPrev === '\\n')\r\n          ) {\r\n            closing = searchIndex;\r\n            break;\r\n          }\r\n        }\r\n        searchIndex += 1;\r\n      }\r\n\r\n      let end = length;\r\n      if (closing !== -1) {\r\n        end = closing + 2;\r\n        if (source[end] === '\\r' && source[end + 1] === '\\n') {\r\n          end += 2;\r\n        } else if (source[end] === '\\n') {\r\n          end += 1;\r\n        }\r\n      }\r\n\r\n      push({\r\n        type: 'heredoc',\r\n        value: source.slice(index, end),\r\n        start,\r\n        end,\r\n        quote\r\n      });\r\n      index = end;\r\n      continue;\r\n    }\r\n\r\n    if (char === '\\'' || char === '\"') {\r\n      const quote = char === '\"' ? 'double' : 'single';\r\n      index += 1;\r\n      let escaped = false;\r\n      while (index < length) {\r\n        const current = source[index];\r\n        if (escaped) {\r\n          escaped = false;\r\n        } else if (current === '`') {\r\n          escaped = true;\r\n        } else if (current === char) {\r\n          index += 1;\r\n          break;\r\n        }\r\n        index += 1;\r\n      }\r\n      push({\r\n        type: 'string',\r\n        value: source.slice(start, index),\r\n        start,\r\n        end: index,\r\n        quote\r\n      });\r\n      continue;\r\n    }\r\n\r\n    if (char === '@' && (source[index + 1] === '{' || source[index + 1] === '(')) {\r\n      const value = `@${source[index + 1]}`;\r\n      index += 2;\r\n      push({ type: 'operator', value, start, end: index });\r\n      continue;\r\n    }\r\n\r\n    if (PUNCTUATION.has(char)) {\r\n      index += 1;\r\n      push({ type: 'punctuation', value: char, start, end: index });\r\n      continue;\r\n    }\r\n\r\n    if (char === '|' || char === '=') {\r\n      let value = char;\r\n      if (source[index + 1] === char) {\r\n        value += char;\r\n        index += 2;\r\n      } else {\r\n        index += 1;\r\n      }\r\n      push({ type: 'operator', value, start, end: index });\r\n      continue;\r\n    }\r\n\r\n    if (char === ':' && source[index + 1] === ':') {\r\n      index += 2;\r\n      push({ type: 'operator', value: '::', start, end: index });\r\n      continue;\r\n    }\r\n\r\n    if (char === '$') {\r\n      index += 1;\r\n      while (index < length) {\r\n        const c = source[index];\r\n        if (/^[A-Za-z0-9_:\\-]$/.test(c)) {\r\n          index += 1;\r\n          continue;\r\n        }\r\n        if (c === '{') {\r\n          index += 1;\r\n          while (index < length && source[index] !== '}') {\r\n            index += 1;\r\n          }\r\n          if (source[index] === '}') {\r\n            index += 1;\r\n          }\r\n          continue;\r\n        }\r\n        break;\r\n      }\r\n      push({ type: 'variable', value: source.slice(start, index), start, end: index });\r\n      continue;\r\n    }\r\n\r\n    if (/[0-9]/.test(char)) {\r\n      index += 1;\r\n      while (index < length && /[0-9]/.test(source[index])) {\r\n        index += 1;\r\n      }\r\n      if (source[index] === '.' && /[0-9]/.test(source[index + 1])) {\r\n        index += 2;\r\n        while (index < length && /[0-9]/.test(source[index])) {\r\n          index += 1;\r\n        }\r\n      }\r\n      push({ type: 'number', value: source.slice(start, index), start, end: index });\r\n      continue;\r\n    }\r\n\r\n    if (/[A-Za-z_]/.test(char) || (char === '-' && /[A-Za-z]/.test(source[index + 1]))) {\r\n      index += 1;\r\n      while (\r\n        index < length &&\r\n        /[A-Za-z0-9_\\-]/.test(source[index])\r\n      ) {\r\n        index += 1;\r\n      }\r\n      const raw = source.slice(start, index);\r\n      const lower = raw.toLowerCase();\r\n      if (KEYWORDS.has(lower)) {\r\n        push({ type: 'keyword', value: raw, start, end: index });\r\n      } else {\r\n        push({ type: 'identifier', value: raw, start, end: index });\r\n      }\r\n      continue;\r\n    }\r\n\r\n    // fallback single character token\r\n    index += 1;\r\n    push({ type: 'unknown', value: char, start, end: index });\r\n  }\r\n\r\n  return tokens;\r\n}\r\n\r\nexport function normalizeHereString(node: HereStringNode): string {\r\n  const lines = node.value.split(/\\r?\\n/);\r\n  if (lines.length <= 2) {\r\n    return node.value;\r\n  }\r\n  return lines\r\n    .slice(1, -1)\r\n    .join('\\n');\r\n}\r\n","import type { ParserOptions, SupportOptions } from 'prettier';\r\n\r\nexport type TrailingCommaOption = 'none' | 'multiline' | 'all';\r\nexport type IndentStyleOption = 'spaces' | 'tabs';\r\n\r\nexport interface PluginConfiguration {\r\n  powershellIndentStyle: IndentStyleOption;\r\n  powershellIndentSize: number;\r\n  powershellTrailingComma: TrailingCommaOption;\r\n  powershellSortHashtableKeys: boolean;\r\n  powershellBlankLinesBetweenFunctions: number;\r\n  powershellBlankLineAfterParam: boolean;\r\n}\r\n\r\nexport const pluginOptions: SupportOptions = {\r\n  powershellIndentStyle: {\r\n    category: 'PowerShell',\r\n    type: 'choice',\r\n    default: 'spaces',\r\n    description: 'Indent PowerShell code using spaces or tabs.',\r\n    choices: [\r\n      { value: 'spaces', description: 'Use spaces for indentation.' },\r\n      { value: 'tabs', description: 'Use tabs for indentation.' }\r\n    ]\r\n  },\r\n  powershellIndentSize: {\r\n    category: 'PowerShell',\r\n    type: 'int',\r\n    default: 2,\r\n    description: 'Number of indentation characters for each level.',\r\n    range: { start: 1, end: 8, step: 1 }\r\n  },\r\n  powershellTrailingComma: {\r\n    category: 'PowerShell',\r\n    type: 'choice',\r\n    default: 'multiline',\r\n    description: 'Control trailing commas for array and hashtable literals.',\r\n    choices: [\r\n      { value: 'none', description: 'Never add a trailing comma or semicolon.' },\r\n      { value: 'multiline', description: 'Add trailing comma/semicolon when the literal spans multiple lines.' },\r\n      { value: 'all', description: 'Always add trailing comma/semicolon when possible.' }\r\n    ]\r\n  },\r\n  powershellSortHashtableKeys: {\r\n    category: 'PowerShell',\r\n    type: 'boolean',\r\n    default: false,\r\n    description: 'Sort hashtable keys alphabetically when formatting.'\r\n  },\r\n  powershellBlankLinesBetweenFunctions: {\r\n    category: 'PowerShell',\r\n    type: 'int',\r\n    default: 1,\r\n    description: 'Number of blank lines to ensure between function declarations.',\r\n    range: { start: 0, end: 3, step: 1 }\r\n  },\r\n  powershellBlankLineAfterParam: {\r\n    category: 'PowerShell',\r\n    type: 'boolean',\r\n    default: true,\r\n    description: 'Insert a blank line after param(...) blocks inside script blocks.'\r\n  }\r\n};\r\n\r\nexport const defaultOptions = {\r\n  tabWidth: 2\r\n};\r\n\r\nexport interface ResolvedOptions {\r\n  indentStyle: IndentStyleOption;\r\n  indentSize: number;\r\n  trailingComma: TrailingCommaOption;\r\n  sortHashtableKeys: boolean;\r\n  blankLinesBetweenFunctions: number;\r\n  blankLineAfterParam: boolean;\r\n}\r\n\r\nexport function resolveOptions(options: ParserOptions): ResolvedOptions {\r\n  const indentStyle = (options.powershellIndentStyle as IndentStyleOption | undefined) ?? 'spaces';\r\n  const indentSize = (options.powershellIndentSize as number | undefined) ?? options.tabWidth ?? 2;\r\n\r\n  if (indentStyle === 'tabs') {\r\n    options.useTabs = true;\r\n  } else {\r\n    options.useTabs = false;\r\n  }\r\n  options.tabWidth = indentSize;\r\n\r\n  const trailingComma = (options.powershellTrailingComma as TrailingCommaOption | undefined) ?? 'multiline';\r\n  const sortHashtableKeys = Boolean(options.powershellSortHashtableKeys);\r\n  const blankLinesBetweenFunctions = Math.max(\r\n    0,\r\n    Math.min(3, Number(options.powershellBlankLinesBetweenFunctions ?? 1))\r\n  );\r\n  const blankLineAfterParam = options.powershellBlankLineAfterParam === false ? false : true;\r\n\r\n  return {\r\n    indentStyle,\r\n    indentSize,\r\n    trailingComma,\r\n    sortHashtableKeys,\r\n    blankLinesBetweenFunctions,\r\n    blankLineAfterParam\r\n  } satisfies ResolvedOptions;\r\n}\r\n","import type {\r\n  ArrayLiteralNode,\r\n  BlankLineNode,\r\n  CommentNode,\r\n  ExpressionNode,\r\n  ExpressionPartNode,\r\n  FunctionDeclarationNode,\r\n  HashtableEntryNode,\r\n  HashtableNode,\r\n  HereStringNode,\r\n  ParenthesisNode,\r\n  PipelineNode,\r\n  ScriptBlockNode,\r\n  ScriptBodyNode,\r\n  ScriptNode,\r\n  TextNode\r\n} from './ast.js';\r\nimport type { Token } from './tokenizer.js';\r\nimport { tokenize } from './tokenizer.js';\r\nimport type { ParserOptions } from 'prettier';\r\nimport { resolveOptions } from './options.js';\r\n\r\nclass Parser {\r\n  private index = 0;\r\n\r\n  constructor(private readonly tokens: Token[], private readonly source: string) {}\r\n\r\n  parseScript(terminators: Set<string> = new Set()): ScriptNode {\r\n    const body: ScriptBodyNode[] = [];\r\n    const start = this.tokens.length > 0 ? this.tokens[0]!.start : 0;\r\n\r\n    while (!this.isEOF()) {\r\n      const token = this.peek();\r\n      if (!token) {\r\n        break;\r\n      }\r\n\r\n      if (terminators.has(token.value) && token.type === 'punctuation') {\r\n        break;\r\n      }\r\n\r\n      if (token.type === 'newline') {\r\n        const blank = this.consumeBlankLines();\r\n        if (blank) {\r\n          body.push(blank);\r\n        }\r\n        continue;\r\n      }\r\n\r\n      if (token.type === 'comment') {\r\n        const commentToken = this.advance();\r\n        body.push(this.createCommentNode(commentToken, false));\r\n        continue;\r\n      }\r\n\r\n      if (this.isFunctionDeclaration()) {\r\n        body.push(this.parseFunction());\r\n        continue;\r\n      }\r\n\r\n      const statement = this.parseStatement();\r\n      if (statement) {\r\n        body.push(statement);\r\n      } else {\r\n        // avoid infinite loops\r\n        this.advance();\r\n      }\r\n    }\r\n\r\n    const end = body.length > 0 ? body[body.length - 1]!.loc.end : start;\r\n    return {\r\n      type: 'Script',\r\n      body,\r\n      loc: { start, end }\r\n    } satisfies ScriptNode;\r\n  }\r\n\r\n  private parseFunction(): FunctionDeclarationNode {\r\n    const startToken = this.advance(); // function keyword\r\n    const headerTokens: Token[] = [startToken];\r\n\r\n    while (!this.isEOF()) {\r\n      const token = this.peek();\r\n      if (!token) {\r\n        break;\r\n      }\r\n      if (token.type === 'comment') {\r\n        break;\r\n      }\r\n      if (token.type === 'punctuation' && token.value === '{') {\r\n        break;\r\n      }\r\n      headerTokens.push(this.advance());\r\n    }\r\n\r\n    const headerExpression = buildExpressionFromTokens(headerTokens);\r\n    const body = this.parseScriptBlock();\r\n    const end = body.loc.end;\r\n\r\n    return {\r\n      type: 'FunctionDeclaration',\r\n      header: headerExpression,\r\n      body,\r\n      loc: { start: startToken.start, end }\r\n    } satisfies FunctionDeclarationNode;\r\n  }\r\n\r\n  private parseStatement(): PipelineNode | null {\r\n    const startToken = this.peek();\r\n    if (!startToken) {\r\n      return null;\r\n    }\r\n\r\n    const segments: Token[][] = [[]];\r\n    let trailingComment: CommentNode | undefined;\r\n\r\n    const structureStack: string[] = [];\r\n\r\n    while (!this.isEOF()) {\r\n      const token = this.peek();\r\n      if (!token) {\r\n        break;\r\n      }\r\n\r\n      if (token.type === 'newline') {\r\n        if (structureStack.length > 0) {\r\n          const newlineToken = this.advance();\r\n          segments[segments.length - 1]!.push(newlineToken);\r\n          continue;\r\n        }\r\n        if (structureStack.length === 0 && this.isPipelineContinuationAfterNewline()) {\r\n          this.advance();\r\n          continue;\r\n        }\r\n        break;\r\n      }\r\n\r\n      if (token.type === 'punctuation' && token.value === ';' && structureStack.length === 0) {\r\n        this.advance();\r\n        break;\r\n      }\r\n\r\n      if (token.type === 'punctuation' && token.value === '}' && structureStack.length === 0) {\r\n        break;\r\n      }\r\n\r\n      if (token.type === 'comment') {\r\n        trailingComment = this.createCommentNode(this.advance(), true);\r\n        break;\r\n      }\r\n\r\n      if (token.type === 'operator' && token.value === '|') {\r\n        this.advance();\r\n        segments.push([]);\r\n        continue;\r\n      }\r\n\r\n      const currentSegment = segments[segments.length - 1]!;\r\n      currentSegment.push(this.advance());\r\n\r\n      if (isOpeningToken(token)) {\r\n        structureStack.push(token.value);\r\n      } else if (isClosingToken(token)) {\r\n        structureStack.pop();\r\n      }\r\n    }\r\n\r\n    const filteredSegments = segments.filter((segment) => segment.length > 0);\r\n    if (filteredSegments.length === 0) {\r\n      return null;\r\n    }\r\n\r\n    const expressionSegments = filteredSegments.map((segmentTokens) =>\r\n      buildExpressionFromTokens(segmentTokens),\r\n    );\r\n    const end = expressionSegments[expressionSegments.length - 1]!.loc.end;\r\n\r\n    return {\r\n      type: 'Pipeline',\r\n      segments: expressionSegments,\r\n      trailingComment,\r\n      loc: { start: startToken.start, end }\r\n    } satisfies PipelineNode;\r\n  }\r\n\r\n  private parseScriptBlock(): ScriptBlockNode {\r\n    const openToken = this.peek();\r\n    if (!openToken || openToken.type !== 'punctuation' || openToken.value !== '{') {\r\n      return {\r\n        type: 'ScriptBlock',\r\n        body: [],\r\n        loc: { start: openToken?.start ?? 0, end: openToken?.end ?? 0 }\r\n      } satisfies ScriptBlockNode;\r\n    }\r\n    this.advance();\r\n\r\n    const { contentTokens, closingToken } = this.collectBalancedTokens(openToken);\r\n    const nestedParser = new Parser(contentTokens, this.source);\r\n    const script = nestedParser.parseScript(new Set());\r\n    const end = closingToken?.end ?? openToken.end;\r\n\r\n    return {\r\n      type: 'ScriptBlock',\r\n      body: script.body,\r\n      loc: { start: openToken.start, end }\r\n    } satisfies ScriptBlockNode;\r\n  }\r\n\r\n  private collectBalancedTokens(startToken: Token): { contentTokens: Token[]; closingToken?: Token } {\r\n    const contentTokens: Token[] = [];\r\n    const stack: string[] = [startToken.value];\r\n\r\n    while (!this.isEOF()) {\r\n      const token = this.advance();\r\n      if (!token) {\r\n        break;\r\n      }\r\n\r\n      if (isOpeningToken(token)) {\r\n        stack.push(token.value);\r\n        contentTokens.push(token);\r\n        continue;\r\n      }\r\n\r\n      if (isClosingToken(token)) {\r\n        if (stack.length <= 1) {\r\n          return { contentTokens, closingToken: token };\r\n        }\r\n        stack.pop();\r\n        contentTokens.push(token);\r\n        continue;\r\n      }\r\n\r\n      contentTokens.push(token);\r\n    }\r\n\r\n    return { contentTokens };\r\n  }\r\n\r\n  private consumeBlankLines(): BlankLineNode | null {\r\n    let count = 0;\r\n    let start = this.peek()?.start ?? 0;\r\n    let end = start;\r\n    while (!this.isEOF()) {\r\n      const token = this.peek();\r\n      if (!token || token.type !== 'newline') {\r\n        break;\r\n      }\r\n      const current = this.advance();\r\n      count += 1;\r\n      end = current.end;\r\n    }\r\n    if (count === 0) {\r\n      return null;\r\n    }\r\n    return {\r\n      type: 'BlankLine',\r\n      count,\r\n      loc: { start, end }\r\n    } satisfies BlankLineNode;\r\n  }\r\n\r\n  private createCommentNode(token: Token, inline: boolean): CommentNode {\r\n    return {\r\n      type: 'Comment',\r\n      value: token.value,\r\n      inline,\r\n      loc: { start: token.start, end: token.end }\r\n    } satisfies CommentNode;\r\n  }\r\n\r\n  private isPipelineContinuationAfterNewline(): boolean {\r\n    let offset = 1;\r\n    while (true) {\r\n      const next = this.peek(offset);\r\n      if (!next) {\r\n        return false;\r\n      }\r\n      if (next.type === 'newline') {\r\n        offset += 1;\r\n        continue;\r\n      }\r\n      if (next.type === 'comment') {\r\n        return false;\r\n      }\r\n      if (next.type === 'operator' && next.value === '|') {\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n  }\r\n\r\n  private isFunctionDeclaration(): boolean {\r\n    const token = this.peek();\r\n    return Boolean(token && token.type === 'keyword' && token.value.toLowerCase() === 'function');\r\n  }\r\n\r\n  private peek(offset = 0): Token | undefined {\r\n    return this.tokens[this.index + offset];\r\n  }\r\n\r\n  private advance(): Token {\r\n    const token = this.tokens[this.index];\r\n    this.index += 1;\r\n    return token!;\r\n  }\r\n\r\n  private isEOF(): boolean {\r\n    return this.index >= this.tokens.length;\r\n  }\r\n}\r\n\r\nfunction isOpeningToken(token: Token): boolean {\r\n  if (token.type === 'operator') {\r\n    return token.value === '@{' || token.value === '@(';\r\n  }\r\n  return token.type === 'punctuation' && (token.value === '{' || token.value === '(' || token.value === '[');\r\n}\r\n\r\nfunction isClosingToken(token: Token): boolean {\r\n  return token.type === 'punctuation' && (token.value === '}' || token.value === ')' || token.value === ']');\r\n}\r\n\r\nfunction buildExpressionFromTokens(tokens: Token[]): ExpressionNode {\r\n  const firstToken = tokens.find((token) => token.type !== 'newline');\r\n  const lastToken = [...tokens].reverse().find((token) => token.type !== 'newline');\r\n  if (!firstToken || !lastToken) {\r\n    return {\r\n      type: 'Expression',\r\n      parts: [],\r\n      loc: { start: tokens[0]?.start ?? 0, end: tokens[tokens.length - 1]?.end ?? 0 }\r\n    } satisfies ExpressionNode;\r\n  }\r\n\r\n  const parts: ExpressionPartNode[] = [];\r\n  let index = 0;\r\n\r\n  while (index < tokens.length) {\r\n    const token = tokens[index]!;\r\n\r\n    if (token.type === 'newline') {\r\n      index += 1;\r\n      continue;\r\n    }\r\n\r\n    if (token.type === 'operator' && token.value === '@{') {\r\n      const { node, nextIndex } = parseHashtablePart(tokens, index);\r\n      parts.push(node);\r\n      index = nextIndex;\r\n      continue;\r\n    }\r\n\r\n    if (\r\n      (token.type === 'operator' && token.value === '@(') ||\r\n      (token.type === 'punctuation' && token.value === '[')\r\n    ) {\r\n      const { node, nextIndex } = parseArrayPart(tokens, index);\r\n      parts.push(node);\r\n      index = nextIndex;\r\n      continue;\r\n    }\r\n\r\n    if (token.type === 'punctuation' && token.value === '{') {\r\n      const { node, nextIndex } = parseScriptBlockPart(tokens, index);\r\n      parts.push(node);\r\n      index = nextIndex;\r\n      continue;\r\n    }\r\n\r\n    if (token.type === 'punctuation' && token.value === '(') {\r\n      const { node, nextIndex } = parseParenthesisPart(tokens, index);\r\n      parts.push(node);\r\n      index = nextIndex;\r\n      continue;\r\n    }\r\n\r\n    if (token.type === 'heredoc') {\r\n      parts.push(createHereStringNode(token));\r\n      index += 1;\r\n      continue;\r\n    }\r\n\r\n    parts.push(createTextNode(token));\r\n    index += 1;\r\n  }\r\n\r\n  return {\r\n    type: 'Expression',\r\n    parts,\r\n    loc: {\r\n      start: firstToken.start,\r\n      end: lastToken.end\r\n    }\r\n  } satisfies ExpressionNode;\r\n}\r\n\r\nfunction parseHashtablePart(tokens: Token[], startIndex: number): { node: HashtableNode; nextIndex: number } {\r\n  const startToken = tokens[startIndex]!;\r\n  const { contentTokens, endIndex, closingToken } = collectStructureTokens(tokens, startIndex);\r\n  const entries = splitHashtableEntries(contentTokens).map((entryTokens) =>\r\n    buildHashtableEntry(entryTokens),\r\n  );\r\n  const end = closingToken?.end ?? (contentTokens[contentTokens.length - 1]?.end ?? startToken.end);\r\n  return {\r\n    node: {\r\n      type: 'Hashtable',\r\n      entries,\r\n      loc: { start: startToken.start, end }\r\n    },\r\n    nextIndex: endIndex\r\n  };\r\n}\r\n\r\nfunction parseArrayPart(tokens: Token[], startIndex: number): { node: ArrayLiteralNode; nextIndex: number } {\r\n  const startToken = tokens[startIndex]!;\r\n  const { contentTokens, endIndex, closingToken } = collectStructureTokens(tokens, startIndex);\r\n  const elements = splitArrayElements(contentTokens).map((elementTokens) =>\r\n    buildExpressionFromTokens(elementTokens),\r\n  );\r\n  const kind = startToken.value === '@(' ? 'implicit' : 'explicit';\r\n  const end = closingToken?.end ?? (contentTokens[contentTokens.length - 1]?.end ?? startToken.end);\r\n  return {\r\n    node: {\r\n      type: 'ArrayLiteral',\r\n      elements,\r\n      kind,\r\n      loc: { start: startToken.start, end }\r\n    },\r\n    nextIndex: endIndex\r\n  } satisfies { node: ArrayLiteralNode; nextIndex: number };\r\n}\r\n\r\nfunction parseParenthesisPart(tokens: Token[], startIndex: number): { node: ParenthesisNode; nextIndex: number } {\r\n  const startToken = tokens[startIndex]!;\r\n  const { contentTokens, endIndex, closingToken } = collectStructureTokens(tokens, startIndex);\r\n  const elements = splitArrayElements(contentTokens).map((elementTokens) =>\r\n    buildExpressionFromTokens(elementTokens),\r\n  );\r\n  const hasComma = hasTopLevelComma(contentTokens);\r\n  const hasNewline = contentTokens.some((token) => token.type === 'newline');\r\n  const end = closingToken?.end ?? (contentTokens[contentTokens.length - 1]?.end ?? startToken.end);\r\n  return {\r\n    node: {\r\n      type: 'Parenthesis',\r\n      elements,\r\n      hasComma,\r\n      hasNewline,\r\n      loc: { start: startToken.start, end }\r\n    },\r\n    nextIndex: endIndex\r\n  };\r\n}\r\n\r\nfunction parseScriptBlockPart(tokens: Token[], startIndex: number): { node: ScriptBlockNode; nextIndex: number } {\r\n  const startToken = tokens[startIndex]!;\r\n  const { contentTokens, endIndex, closingToken } = collectStructureTokens(tokens, startIndex);\r\n  const nestedParser = new Parser(contentTokens, '');\r\n  const script = nestedParser.parseScript();\r\n  const end = closingToken?.end ?? (contentTokens[contentTokens.length - 1]?.end ?? startToken.end);\r\n  return {\r\n    node: {\r\n      type: 'ScriptBlock',\r\n      body: script.body,\r\n      loc: { start: startToken.start, end }\r\n    },\r\n    nextIndex: endIndex\r\n  };\r\n}\r\n\r\nfunction createHereStringNode(token: Token): HereStringNode {\r\n  const quote = token.quote ?? 'double';\r\n  return {\r\n    type: 'HereString',\r\n    quote,\r\n    value: token.value,\r\n    loc: { start: token.start, end: token.end }\r\n  } satisfies HereStringNode;\r\n}\r\n\r\nfunction createTextNode(token: Token): TextNode {\r\n  const role = token.type === 'identifier'\r\n    ? 'word'\r\n    : token.type === 'keyword'\r\n    ? 'keyword'\r\n    : token.type === 'number'\r\n    ? 'number'\r\n    : token.type === 'variable'\r\n    ? 'variable'\r\n    : token.type === 'string'\r\n    ? 'string'\r\n    : token.type === 'operator'\r\n    ? 'operator'\r\n    : token.type === 'punctuation'\r\n    ? 'punctuation'\r\n    : 'unknown';\r\n\r\n  return {\r\n    type: 'Text',\r\n    value: token.value,\r\n    role,\r\n    loc: { start: token.start, end: token.end }\r\n  } satisfies TextNode;\r\n}\r\n\r\nfunction collectStructureTokens(\r\n  tokens: Token[],\r\n  startIndex: number\r\n): { contentTokens: Token[]; endIndex: number; closingToken?: Token } {\r\n  const contentTokens: Token[] = [];\r\n  const stack: string[] = [tokens[startIndex]!.value];\r\n  let index = startIndex + 1;\r\n\r\n  while (index < tokens.length) {\r\n    const token = tokens[index]!;\r\n\r\n    if (isOpeningToken(token)) {\r\n      stack.push(token.value);\r\n      contentTokens.push(token);\r\n      index += 1;\r\n      continue;\r\n    }\r\n\r\n    if (isClosingToken(token)) {\r\n      if (stack.length === 1) {\r\n        return { contentTokens, endIndex: index + 1, closingToken: token };\r\n      }\r\n      stack.pop();\r\n      contentTokens.push(token);\r\n      index += 1;\r\n      continue;\r\n    }\r\n\r\n    contentTokens.push(token);\r\n    index += 1;\r\n  }\r\n\r\n  return { contentTokens, endIndex: tokens.length };\r\n}\r\n\r\nfunction splitHashtableEntries(tokens: Token[]): Token[][] {\r\n  const entries: Token[][] = [];\r\n  let current: Token[] = [];\r\n  const stack: string[] = [];\r\n\r\n  for (const token of tokens) {\r\n    if (token.type === 'newline' && stack.length === 0) {\r\n      if (current.length > 0) {\r\n        entries.push(current);\r\n        current = [];\r\n      }\r\n      continue;\r\n    }\r\n\r\n    if (token.type === 'punctuation' && token.value === ';' && stack.length === 0) {\r\n      if (current.length > 0) {\r\n        entries.push(current);\r\n        current = [];\r\n      }\r\n      continue;\r\n    }\r\n\r\n    if (isOpeningToken(token)) {\r\n      stack.push(token.value);\r\n      current.push(token);\r\n      continue;\r\n    }\r\n\r\n    if (isClosingToken(token)) {\r\n      if (stack.length > 0) {\r\n        stack.pop();\r\n      }\r\n      current.push(token);\r\n      continue;\r\n    }\r\n\r\n    current.push(token);\r\n  }\r\n\r\n  if (current.length > 0) {\r\n    entries.push(current);\r\n  }\r\n\r\n  return entries;\r\n}\r\n\r\nfunction buildHashtableEntry(tokens: Token[]): HashtableEntryNode {\r\n  const equalsIndex = findTopLevelEquals(tokens);\r\n  const keyTokens = equalsIndex === -1 ? tokens : tokens.slice(0, equalsIndex);\r\n  const valueTokens = equalsIndex === -1 ? [] : tokens.slice(equalsIndex + 1);\r\n  const keyExpression = buildExpressionFromTokens(keyTokens);\r\n  const valueExpression = valueTokens.length > 0 ? buildExpressionFromTokens(valueTokens) : buildExpressionFromTokens([]);\r\n  const key = extractKeyText(keyTokens);\r\n  const start = keyTokens[0]?.start ?? (valueTokens[0]?.start ?? 0);\r\n  const end = (valueTokens[valueTokens.length - 1] ?? keyTokens[keyTokens.length - 1])?.end ?? start;\r\n\r\n  return {\r\n    type: 'HashtableEntry',\r\n    key,\r\n    rawKey: keyExpression,\r\n    value: valueExpression,\r\n    loc: { start, end }\r\n  } satisfies HashtableEntryNode;\r\n}\r\n\r\nfunction findTopLevelEquals(tokens: Token[]): number {\r\n  const stack: string[] = [];\r\n  for (let index = 0; index < tokens.length; index += 1) {\r\n    const token = tokens[index]!;\r\n    if (isOpeningToken(token)) {\r\n      stack.push(token.value);\r\n      continue;\r\n    }\r\n    if (isClosingToken(token)) {\r\n      stack.pop();\r\n      continue;\r\n    }\r\n    if (stack.length === 0 && token.type === 'operator' && token.value === '=') {\r\n      return index;\r\n    }\r\n  }\r\n  return -1;\r\n}\r\n\r\nfunction extractKeyText(tokens: Token[]): string {\r\n  const text = tokens\r\n    .filter((token) => token.type !== 'newline')\r\n    .map((token) => token.value)\r\n    .join(' ')\r\n    .trim();\r\n  if (text.startsWith('\"') && text.endsWith('\"')) {\r\n    return text.slice(1, -1);\r\n  }\r\n  if (text.startsWith('\\'') && text.endsWith('\\'')) {\r\n    return text.slice(1, -1);\r\n  }\r\n  return text;\r\n}\r\n\r\nfunction splitArrayElements(tokens: Token[]): Token[][] {\r\n  const elements: Token[][] = [];\r\n  let current: Token[] = [];\r\n  const stack: string[] = [];\r\n\r\n  for (const token of tokens) {\r\n    if (token.type === 'newline' && stack.length === 0) {\r\n      if (current.length > 0) {\r\n        elements.push(current);\r\n        current = [];\r\n      }\r\n      continue;\r\n    }\r\n\r\n    if (token.type === 'punctuation' && token.value === ',' && stack.length === 0) {\r\n      elements.push(current);\r\n      current = [];\r\n      continue;\r\n    }\r\n\r\n    if (isOpeningToken(token)) {\r\n      stack.push(token.value);\r\n      current.push(token);\r\n      continue;\r\n    }\r\n\r\n    if (isClosingToken(token)) {\r\n      if (stack.length > 0) {\r\n        stack.pop();\r\n      }\r\n      current.push(token);\r\n      continue;\r\n    }\r\n\r\n    current.push(token);\r\n  }\r\n\r\n  if (current.length > 0) {\r\n    elements.push(current);\r\n  }\r\n\r\n  return elements;\r\n}\r\n\r\nfunction hasTopLevelComma(tokens: Token[]): boolean {\r\n  const stack: string[] = [];\r\n  for (const token of tokens) {\r\n    if (isOpeningToken(token)) {\r\n      stack.push(token.value);\r\n      continue;\r\n    }\r\n    if (isClosingToken(token)) {\r\n      if (stack.length > 0) {\r\n        stack.pop();\r\n      }\r\n      continue;\r\n    }\r\n    if (stack.length === 0 && token.type === 'punctuation' && token.value === ',') {\r\n      return true;\r\n    }\r\n  }\r\n  return false;\r\n}\r\n\r\nexport function parsePowerShell(source: string, options: ParserOptions): ScriptNode {\r\n  resolveOptions(options);\r\n  const tokens = tokenize(source);\r\n  const parser = new Parser(tokens, source);\r\n  return parser.parseScript();\r\n}\r\n\r\nexport const locStart = (node: { loc: { start: number } }): number => node.loc.start;\r\nexport const locEnd = (node: { loc: { end: number } }): number => node.loc.end;\r\n","import type { AstPath, Doc, ParserOptions, Printer } from 'prettier';\r\nimport { doc } from 'prettier';\r\nimport {\r\n  type ArrayLiteralNode,\r\n  type BlankLineNode,\r\n  type CommentNode,\r\n  type ExpressionNode,\r\n  type ExpressionPartNode,\r\n  type FunctionDeclarationNode,\r\n  type HashtableEntryNode,\r\n  type HashtableNode,\r\n  type HereStringNode,\r\n  type ParenthesisNode,\r\n  type PipelineNode,\r\n  type ScriptBlockNode,\r\n  type ScriptBodyNode,\r\n  type ScriptNode,\r\n  type TextNode\r\n} from './ast.js';\r\nimport { resolveOptions, type ResolvedOptions } from './options.js';\r\n\r\nconst { group, indent, line, softline, hardline, join, ifBreak, lineSuffix, dedentToRoot } =\r\n  doc.builders;\r\n\r\nexport const powerShellPrinter: Printer<ScriptNode> = {\r\n  print(path: AstPath, options: ParserOptions) {\r\n    const node = path.getValue() as ScriptNode | ScriptBodyNode | ExpressionPartNode | undefined;\r\n    if (!node) {\r\n      return '';\r\n    }\r\n    const resolved = resolveOptions(options);\r\n    return printNode(node, resolved);\r\n  }\r\n};\r\n\r\nfunction printNode(\r\n  node:\r\n    | ScriptNode\r\n    | ScriptBodyNode\r\n    | ExpressionNode\r\n    | ExpressionPartNode\r\n    | HashtableEntryNode,\r\n  options: ResolvedOptions\r\n): Doc {\r\n  switch (node.type) {\r\n    case 'Script':\r\n      return printScript(node, options);\r\n    case 'ScriptBlock':\r\n      return printScriptBlock(node, options);\r\n    case 'FunctionDeclaration':\r\n      return printFunction(node, options);\r\n    case 'Pipeline':\r\n      return printPipeline(node, options);\r\n    case 'Expression':\r\n      return printExpression(node, options);\r\n    case 'Text':\r\n      return printText(node);\r\n    case 'Comment':\r\n      return printComment(node);\r\n    case 'BlankLine':\r\n      return Array.from({ length: node.count }, () => hardline);\r\n    case 'ArrayLiteral':\r\n      return printArray(node, options);\r\n    case 'Hashtable':\r\n      return printHashtable(node, options);\r\n    case 'HashtableEntry':\r\n      return printHashtableEntry(node, options);\r\n    case 'HereString':\r\n      return printHereString(node);\r\n    case 'Parenthesis':\r\n      return printParenthesis(node, options);\r\n    default:\r\n      return '';\r\n  }\r\n}\r\n\r\nfunction concatDocs(docs: Doc[]): Doc {\r\n  if (docs.length === 0) {\r\n    return '';\r\n  }\r\n  let acc: Doc = docs[0]!;\r\n  for (let index = 1; index < docs.length; index += 1) {\r\n    acc = [acc, docs[index]!] as Doc;\r\n  }\r\n  return acc;\r\n}\r\n\r\nfunction printScript(node: ScriptNode, options: ResolvedOptions): Doc {\r\n  const bodyDoc = printStatementList(node.body, options);\r\n  if (!bodyDoc) {\r\n    return '';\r\n  }\r\n  return [bodyDoc, hardline];\r\n}\r\n\r\nfunction printStatementList(body: ScriptBodyNode[], options: ResolvedOptions): Doc {\r\n  const docs: Doc[] = [];\r\n  let previous: ScriptBodyNode | null = null;\r\n  let pendingBlankLines = 0;\r\n\r\n  for (const entry of body) {\r\n    if (entry.type === 'BlankLine') {\r\n      pendingBlankLines += entry.count;\r\n      continue;\r\n    }\r\n\r\n    if (previous) {\r\n      const blankLines = determineBlankLines(previous, entry, pendingBlankLines, options);\r\n      for (let index = 0; index < blankLines; index += 1) {\r\n        docs.push(hardline);\r\n      }\r\n    }\r\n\r\n    docs.push(printNode(entry, options));\r\n    previous = entry;\r\n    pendingBlankLines = 0;\r\n  }\r\n\r\n  return concatDocs(docs);\r\n}\r\n\r\nfunction determineBlankLines(\r\n  previous: ScriptBodyNode,\r\n  current: ScriptBodyNode,\r\n  pendingBlankLines: number,\r\n  options: ResolvedOptions\r\n): number {\r\n  let base = pendingBlankLines > 0 ? pendingBlankLines : 1;\r\n  const desiredFunctionSpacing = options.blankLinesBetweenFunctions + 1;\r\n\r\n  if (\r\n    (previous.type === 'FunctionDeclaration' && current.type === 'FunctionDeclaration') ||\r\n    (previous.type === 'FunctionDeclaration' && current.type !== 'BlankLine') ||\r\n    (current.type === 'FunctionDeclaration' && previous.type !== 'BlankLine')\r\n  ) {\r\n    base = Math.max(base, desiredFunctionSpacing);\r\n  }\r\n\r\n  if (options.blankLineAfterParam && isParamStatement(previous)) {\r\n    base = Math.max(base, 2);\r\n  }\r\n\r\n  return base;\r\n}\r\n\r\nfunction printScriptBlock(node: ScriptBlockNode, options: ResolvedOptions): Doc {\r\n  if (node.body.length === 0) {\r\n    return '{}';\r\n  }\r\n\r\n  const bodyDoc = printStatementList(node.body, options);\r\n  return group([\r\n    '{',\r\n    indent([hardline, bodyDoc]),\r\n    hardline,\r\n    '}'\r\n  ]);\r\n}\r\n\r\nfunction printFunction(node: FunctionDeclarationNode, options: ResolvedOptions): Doc {\r\n  const headerDoc = printExpression(node.header, options);\r\n  const bodyDoc = printScriptBlock(node.body, options);\r\n  return group([headerDoc, ' ', bodyDoc]);\r\n}\r\n\r\nfunction printPipeline(node: PipelineNode, options: ResolvedOptions): Doc {\r\n  const segmentDocs = node.segments.map((segment) => printExpression(segment, options));\r\n  if (segmentDocs.length === 0) {\r\n    return '';\r\n  }\r\n\r\n  let pipelineDoc: Doc = segmentDocs[0]!;\r\n\r\n  if (segmentDocs.length > 1) {\r\n    const restDocs = segmentDocs.slice(1).map((segmentDoc) => ['| ', segmentDoc] as Doc);\r\n    pipelineDoc = group([\r\n      segmentDocs[0]!,\r\n      indent(restDocs.flatMap((docItem) => [line, docItem]))\r\n    ]);\r\n  }\r\n\r\n  if (node.trailingComment) {\r\n    pipelineDoc = [pipelineDoc, lineSuffix([' #', node.trailingComment.value])];\r\n  }\r\n\r\n  return pipelineDoc;\r\n}\r\n\r\nfunction printExpression(node: ExpressionNode, options: ResolvedOptions): Doc {\r\n  const docs: Doc[] = [];\r\n  let previous: ExpressionPartNode | null = null;\r\n\r\n  for (const part of node.parts) {\r\n    if (part.type === 'Parenthesis' && isParamKeyword(previous)) {\r\n      docs.push(printParamParenthesis(part, options));\r\n      previous = part;\r\n      continue;\r\n    }\r\n\r\n    if (previous && shouldInsertSpace(previous, part)) {\r\n      docs.push(' ');\r\n    }\r\n    docs.push(printNode(part, options));\r\n    previous = part;\r\n  }\r\n\r\n  return docs.length === 0 ? '' : group(docs);\r\n}\r\n\r\nfunction shouldInsertSpace(previous: ExpressionPartNode, current: ExpressionPartNode): boolean {\r\n  const prevSymbol = getSymbol(previous);\r\n  const currentSymbol = getSymbol(current);\r\n\r\n  if (current.type === 'Parenthesis') {\r\n    if (previous.type === 'Text' && previous.value.toLowerCase() === 'param') {\r\n      return false;\r\n    }\r\n    if (previous.type === 'Text' && previous.role === 'keyword') {\r\n      return true;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  if (previous.type === 'Parenthesis') {\r\n    if (currentSymbol && NO_SPACE_BEFORE.has(currentSymbol)) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  if (!prevSymbol && !currentSymbol) {\r\n    return true;\r\n  }\r\n\r\n  if (!prevSymbol) {\r\n    if (currentSymbol && NO_SPACE_BEFORE.has(currentSymbol)) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  if (NO_SPACE_AFTER.has(prevSymbol)) {\r\n    return false;\r\n  }\r\n\r\n  if (currentSymbol && NO_SPACE_BEFORE.has(currentSymbol)) {\r\n    return false;\r\n  }\r\n\r\n  if (prevSymbol && currentSymbol && SYMBOL_NO_GAP.has(`${prevSymbol}:${currentSymbol}`)) {\r\n    return false;\r\n  }\r\n\r\n  if (prevSymbol === '=' || currentSymbol === '=') {\r\n    return true;\r\n  }\r\n\r\n  if (current.type === 'ScriptBlock' || current.type === 'Hashtable' || current.type === 'ArrayLiteral') {\r\n    if (prevSymbol && NO_SPACE_BEFORE_BLOCK.has(prevSymbol)) {\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nfunction isParamStatement(node: ScriptBodyNode | null): boolean {\r\n  if (!node || node.type !== 'Pipeline') {\r\n    return false;\r\n  }\r\n  if (node.segments.length === 0) {\r\n    return false;\r\n  }\r\n  const firstSegment = node.segments[0]!;\r\n  if (firstSegment.parts.length === 0) {\r\n    return false;\r\n  }\r\n  const firstPart = firstSegment.parts.find((part) => part.type === 'Text');\r\n  if (!firstPart || firstPart.type !== 'Text') {\r\n    return false;\r\n  }\r\n  return firstPart.value.toLowerCase() === 'param';\r\n}\r\n\r\nconst NO_SPACE_BEFORE = new Set([')', ']', '}', ',', ';', '.', '::']);\r\nconst NO_SPACE_AFTER = new Set(['(', '[', '{', '.']);\r\nconst NO_SPACE_BEFORE_BLOCK = new Set(['(', '{', '=']);\r\nconst SYMBOL_NO_GAP = new Set(['.:word', '::word', 'word:(', 'word:[']);\r\n\r\nfunction getSymbol(node: ExpressionPartNode | null): string | null {\r\n  if (!node) {\r\n    return null;\r\n  }\r\n  if (node.type === 'Text' && (node.role === 'punctuation' || node.role === 'operator')) {\r\n    return node.value;\r\n  }\r\n  if (node.type === 'Parenthesis') {\r\n    return '(';\r\n  }\r\n  return null;\r\n}\r\n\r\nfunction isParamKeyword(node: ExpressionPartNode | null): boolean {\r\n  return Boolean(node && node.type === 'Text' && node.value.toLowerCase() === 'param');\r\n}\r\n\r\nfunction printText(node: TextNode): Doc {\r\n  return node.value;\r\n}\r\n\r\nfunction printComment(node: CommentNode): Doc {\r\n  return ['#', node.value];\r\n}\r\n\r\nfunction printArray(node: ArrayLiteralNode, options: ResolvedOptions): Doc {\r\n  const open = node.kind === 'implicit' ? '@(' : '[';\r\n  const close = node.kind === 'implicit' ? ')' : ']';\r\n  if (node.elements.length === 0) {\r\n    return [open, close];\r\n  }\r\n  const groupId = Symbol('array');\r\n  const elementDocs = node.elements.map((element) => printExpression(element, options));\r\n  const shouldBreak = elementDocs.length > 1;\r\n  const separator: Doc = [',', line];\r\n  const trailing = trailingCommaDoc(options, groupId, elementDocs.length > 0, ',');\r\n\r\n  return group([\r\n    open,\r\n    indent([\r\n      shouldBreak ? line : softline,\r\n      join(separator, elementDocs)\r\n    ]),\r\n    trailing,\r\n    shouldBreak ? line : softline,\r\n    close\r\n  ], { id: groupId });\r\n}\r\n\r\nfunction printHashtable(node: HashtableNode, options: ResolvedOptions): Doc {\r\n  const entries = options.sortHashtableKeys\r\n    ? [...node.entries].sort((a, b) => a.key.localeCompare(b.key, undefined, { sensitivity: 'base' }))\r\n    : node.entries;\r\n\r\n  if (entries.length === 0) {\r\n    return '@{}';\r\n  }\r\n\r\n  const groupId = Symbol('hashtable');\r\n\r\n  const entryDocs = entries.map((entry, index) => {\r\n    const entryDoc = printHashtableEntry(entry, options);\r\n    const isLast = index === entries.length - 1;\r\n    const separator = isLast ? trailingCommaDoc(options, groupId, true, ';') : ifBreak('', ';', { groupId });\r\n    return [entryDoc, separator];\r\n  });\r\n\r\n  return group([\r\n    '@{',\r\n    indent([line, join(line, entryDocs)]),\r\n    line,\r\n    '}'\r\n  ], { id: groupId });\r\n}\r\n\r\nfunction printHashtableEntry(node: HashtableEntryNode, options: ResolvedOptions): Doc {\r\n  const keyDoc = printExpression(node.rawKey, options);\r\n  const valueDoc = printExpression(node.value, options);\r\n  return group([keyDoc, ' =', indent([line, valueDoc])]);\r\n}\r\n\r\nfunction printHereString(node: HereStringNode): Doc {\r\n  return dedentToRoot(node.value);\r\n}\r\n\r\nfunction printParamParenthesis(node: ParenthesisNode, options: ResolvedOptions): Doc {\r\n  if (node.elements.length === 0) {\r\n    return '()';\r\n  }\r\n\r\n  if (node.elements.length <= 1 && !node.hasNewline) {\r\n    return printParenthesis(node, options);\r\n  }\r\n\r\n  const groupId = Symbol('param');\r\n  const elementDocs = node.elements.map((element) => printExpression(element, options));\r\n  const separator: Doc = [',', hardline];\r\n\r\n  return group([\r\n    '(',\r\n    indent([hardline, join(separator, elementDocs)]),\r\n    hardline,\r\n    ')'\r\n  ], { id: groupId });\r\n}\r\n\r\nfunction printParenthesis(node: ParenthesisNode, options: ResolvedOptions): Doc {\r\n  if (node.elements.length === 0) {\r\n    return '()';\r\n  }\r\n  const groupId = Symbol('parenthesis');\r\n  const elementDocs = node.elements.map((element) => printExpression(element, options));\r\n  if (elementDocs.length === 1 && !node.hasNewline) {\r\n    return group([\r\n      '(',\r\n      indent([softline, elementDocs[0]!]),\r\n      softline,\r\n      ')'\r\n    ], { id: groupId });\r\n  }\r\n\r\n  const hasComma = node.hasComma;\r\n    const forceMultiline = node.hasNewline || (!node.hasComma && elementDocs.length > 1);\r\n    const separator: Doc = hasComma\r\n      ? [',', forceMultiline ? hardline : line]\r\n      : (forceMultiline ? hardline : line);\r\n\r\n  return group([\r\n    '(',\r\n    indent([\r\n        forceMultiline ? hardline : hasComma ? line : softline,\r\n      join(separator, elementDocs)\r\n    ]),\r\n      forceMultiline ? hardline : hasComma ? line : softline,\r\n    ')'\r\n  ], { id: groupId });\r\n}\r\n\r\nfunction trailingCommaDoc(\r\n  options: ResolvedOptions,\r\n  groupId: symbol,\r\n  hasElements: boolean,\r\n  delimiter: ',' | ';'\r\n): Doc {\r\n  if (!hasElements) {\r\n    return '';\r\n  }\r\n  switch (options.trailingComma) {\r\n    case 'all':\r\n      return delimiter;\r\n    case 'multiline':\r\n      return ifBreak(delimiter, '', { groupId });\r\n    case 'none':\r\n    default:\r\n      return '';\r\n  }\r\n}\r\n\r\nexport function createPrinter(): Printer<ScriptNode> {\r\n  return powerShellPrinter;\r\n}\r\n","import type { Plugin, SupportLanguage } from 'prettier';\r\nimport { parsePowerShell, locEnd, locStart } from './parser.js';\r\nimport { powerShellPrinter } from './printer.js';\r\nimport { pluginOptions, defaultOptions } from './options.js';\r\n\r\nconst languages: SupportLanguage[] = [\r\n  {\r\n    name: 'PowerShell',\r\n    parsers: ['powershell'],\r\n    extensions: ['.ps1', '.psm1', '.psd1'],\r\n    tmScope: 'source.powershell',\r\n    aceMode: 'powershell',\r\n    linguistLanguageId: 131,\r\n    vscodeLanguageIds: ['powershell']\r\n  }\r\n] as const;\r\n\r\nconst parsers: Plugin['parsers'] = {\r\n  powershell: {\r\n    parse: parsePowerShell,\r\n    astFormat: 'powershell-ast',\r\n    locStart,\r\n    locEnd,\r\n    hasPragma() {\r\n      return false;\r\n    }\r\n  }\r\n} as const;\r\n\r\nconst printers: Plugin['printers'] = {\r\n  'powershell-ast': powerShellPrinter\r\n};\r\n\r\nconst plugin: Plugin = {\r\n  languages,\r\n  parsers,\r\n  printers,\r\n  options: pluginOptions,\r\n  defaultOptions\r\n};\r\n\r\nexport default plugin;\r\nexport { languages, parsers, printers, pluginOptions as options, defaultOptions };\r\n"],"mappings":"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","names":[]}