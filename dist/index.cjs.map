{"version":3,"sources":["../src/options.ts","../src/tokenizer.ts","../src/parser.ts","../src/printer.ts","../src/index.ts"],"names":["currentSegment","doc","index_default"],"mappings":"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","file":"index.cjs","sourcesContent":["import type { ParserOptions, SupportOptions } from \"prettier\";\n\nexport type TrailingCommaOption = \"none\" | \"multiline\" | \"all\";\nexport type IndentStyleOption = \"spaces\" | \"tabs\";\nexport type BraceStyleOption = \"1tbs\" | \"allman\";\nexport type KeywordCaseOption = \"preserve\" | \"lower\" | \"upper\" | \"pascal\";\n\nexport interface PluginConfiguration {\n    powershellIndentStyle: IndentStyleOption;\n    powershellIndentSize: number;\n    powershellTrailingComma: TrailingCommaOption;\n    powershellSortHashtableKeys: boolean;\n    powershellBlankLinesBetweenFunctions: number;\n    powershellBlankLineAfterParam: boolean;\n    powershellBraceStyle: BraceStyleOption;\n    powershellLineWidth: number;\n    powershellPreferSingleQuote: boolean;\n    powershellKeywordCase: KeywordCaseOption;\n    powershellRewriteAliases: boolean;\n    powershellRewriteWriteHost: boolean;\n}\n\nexport const pluginOptions: SupportOptions = {\n    powershellIndentStyle: {\n        category: \"PowerShell\",\n        type: \"choice\",\n        default: \"spaces\",\n        description: \"Indent PowerShell code using spaces or tabs.\",\n        choices: [\n            { value: \"spaces\", description: \"Use spaces for indentation.\" },\n            { value: \"tabs\", description: \"Use tabs for indentation.\" },\n        ],\n    },\n    powershellIndentSize: {\n        category: \"PowerShell\",\n        type: \"int\",\n        default: 2,\n        description: \"Number of indentation characters for each level.\",\n        range: { start: 1, end: 8, step: 1 },\n    },\n    powershellTrailingComma: {\n        category: \"PowerShell\",\n        type: \"choice\",\n        default: \"multiline\",\n        description:\n            \"Control trailing commas for array and hashtable literals.\",\n        choices: [\n            {\n                value: \"none\",\n                description: \"Never add a trailing comma or semicolon.\",\n            },\n            {\n                value: \"multiline\",\n                description:\n                    \"Add trailing comma/semicolon when the literal spans multiple lines.\",\n            },\n            {\n                value: \"all\",\n                description:\n                    \"Always add trailing comma/semicolon when possible.\",\n            },\n        ],\n    },\n    powershellSortHashtableKeys: {\n        category: \"PowerShell\",\n        type: \"boolean\",\n        default: false,\n        description: \"Sort hashtable keys alphabetically when formatting.\",\n    },\n    powershellBlankLinesBetweenFunctions: {\n        category: \"PowerShell\",\n        type: \"int\",\n        default: 1,\n        description:\n            \"Number of blank lines to ensure between function declarations.\",\n        range: { start: 0, end: 3, step: 1 },\n    },\n    powershellBlankLineAfterParam: {\n        category: \"PowerShell\",\n        type: \"boolean\",\n        default: true,\n        description:\n            \"Insert a blank line after param(...) blocks inside script blocks.\",\n    },\n    powershellBraceStyle: {\n        category: \"PowerShell\",\n        type: \"choice\",\n        default: \"1tbs\",\n        description:\n            \"Control placement of opening braces for script blocks and functions.\",\n        choices: [\n            {\n                value: \"1tbs\",\n                description:\n                    \"One True Brace Style  keep opening braces on the same line.\",\n            },\n            {\n                value: \"allman\",\n                description:\n                    \"Allman style  place opening braces on the next line.\",\n            },\n        ],\n    },\n    powershellLineWidth: {\n        category: \"PowerShell\",\n        type: \"int\",\n        default: 120,\n        description: \"Maximum preferred line width for PowerShell documents.\",\n        range: { start: 40, end: 200, step: 1 },\n    },\n    powershellPreferSingleQuote: {\n        category: \"PowerShell\",\n        type: \"boolean\",\n        default: false,\n        description:\n            \"Prefer single-quoted strings when no interpolation is required.\",\n    },\n    powershellKeywordCase: {\n        category: \"PowerShell\",\n        type: \"choice\",\n        default: \"preserve\",\n        description: \"Normalise the casing of PowerShell keywords.\",\n        choices: [\n            {\n                value: \"preserve\",\n                description: \"Leave keyword casing unchanged.\",\n            },\n            { value: \"lower\", description: \"Convert keywords to lower-case.\" },\n            { value: \"upper\", description: \"Convert keywords to upper-case.\" },\n            {\n                value: \"pascal\",\n                description: \"Capitalise keywords (PascalCase).\",\n            },\n        ],\n    },\n    powershellRewriteAliases: {\n        category: \"PowerShell\",\n        type: \"boolean\",\n        default: false,\n        description: \"Rewrite common cmdlet aliases to their canonical names.\",\n    },\n    powershellRewriteWriteHost: {\n        category: \"PowerShell\",\n        type: \"boolean\",\n        default: false,\n        description:\n            \"Rewrite Write-Host invocations to Write-Output to discourage host-only output.\",\n    },\n};\n\nexport const defaultOptions = {\n    tabWidth: 2,\n};\n\nexport interface ResolvedOptions {\n    indentStyle: IndentStyleOption;\n    indentSize: number;\n    trailingComma: TrailingCommaOption;\n    sortHashtableKeys: boolean;\n    blankLinesBetweenFunctions: number;\n    blankLineAfterParam: boolean;\n    braceStyle: BraceStyleOption;\n    lineWidth: number;\n    preferSingleQuote: boolean;\n    keywordCase: KeywordCaseOption;\n    rewriteAliases: boolean;\n    rewriteWriteHost: boolean;\n}\n\nexport function resolveOptions(options: ParserOptions): ResolvedOptions {\n    const indentStyle =\n        (options.powershellIndentStyle as IndentStyleOption | undefined) ??\n        \"spaces\";\n    const rawIndentOverride = options.powershellIndentSize;\n    const normalizedIndentOverride = Number(rawIndentOverride);\n    const normalizedTabWidth = Number(options.tabWidth);\n    const indentSize =\n        Number.isFinite(normalizedIndentOverride) &&\n        normalizedIndentOverride > 0\n            ? Math.floor(normalizedIndentOverride)\n            : Number.isFinite(normalizedTabWidth) && normalizedTabWidth > 0\n              ? Math.floor(normalizedTabWidth)\n              : 2;\n\n    if (indentStyle === \"tabs\") {\n        options.useTabs = true;\n    } else {\n        options.useTabs = false;\n    }\n    options.tabWidth = indentSize;\n\n    const trailingComma =\n        (options.powershellTrailingComma as TrailingCommaOption | undefined) ??\n        \"multiline\";\n    const sortHashtableKeys = Boolean(options.powershellSortHashtableKeys);\n    const rawBlankLines = Number(\n        options.powershellBlankLinesBetweenFunctions ?? 1\n    );\n    const normalizedBlankLines = Number.isFinite(rawBlankLines)\n        ? rawBlankLines\n        : 1;\n    const blankLinesBetweenFunctions = Math.max(\n        0,\n        Math.min(3, Math.floor(normalizedBlankLines))\n    );\n    let blankLineAfterParam = true;\n    /* c8 ignore next */\n    if (options.powershellBlankLineAfterParam === false) {\n        blankLineAfterParam = false;\n    }\n    const braceStyle =\n        (options.powershellBraceStyle as BraceStyleOption | undefined) ??\n        \"1tbs\";\n    const lineWidth = Math.max(\n        40,\n        Math.min(200, Number(options.powershellLineWidth ?? 120))\n    );\n    const preferSingleQuote = options.powershellPreferSingleQuote === true;\n    const keywordCase =\n        (options.powershellKeywordCase as KeywordCaseOption | undefined) ??\n        \"preserve\";\n    const rewriteAliases = options.powershellRewriteAliases === true;\n    const rewriteWriteHost = options.powershellRewriteWriteHost === true;\n\n    if (!options.printWidth || options.printWidth > lineWidth) {\n        options.printWidth = lineWidth;\n    }\n\n    return {\n        indentStyle,\n        indentSize,\n        trailingComma,\n        sortHashtableKeys,\n        blankLinesBetweenFunctions,\n        blankLineAfterParam,\n        braceStyle,\n        lineWidth,\n        preferSingleQuote,\n        keywordCase,\n        rewriteAliases,\n        rewriteWriteHost,\n    } satisfies ResolvedOptions;\n}\n","import type { HereStringNode } from \"./ast.js\";\n\nexport type TokenType =\n    | \"newline\"\n    | \"identifier\"\n    | \"keyword\"\n    | \"variable\"\n    | \"number\"\n    | \"string\"\n    | \"heredoc\"\n    | \"comment\"\n    | \"block-comment\"\n    | \"attribute\"\n    | \"punctuation\"\n    | \"operator\"\n    | \"unknown\";\n\nexport interface Token {\n    type: TokenType;\n    value: string;\n    start: number;\n    end: number;\n    quote?: \"single\" | \"double\";\n}\n\nconst KEYWORDS = new Set([\n    \"function\",\n    \"if\",\n    \"elseif\",\n    \"else\",\n    \"for\",\n    \"foreach\",\n    \"while\",\n    \"switch\",\n    \"try\",\n    \"catch\",\n    \"finally\",\n    \"param\",\n    \"class\",\n]);\n\nconst PUNCTUATION = new Set([\n    \"{\",\n    \"}\",\n    \"(\",\n    \")\",\n    \"[\",\n    \"]\",\n    \",\",\n    \";\",\n    \".\",\n    \":\",\n]);\n\nexport function tokenize(source: string): Token[] {\n    const tokens: Token[] = [];\n    const length = source.length;\n    let index = 0;\n\n    const push = (token: Token) => {\n        tokens.push(token);\n    };\n\n    while (index < length) {\n        const char = source[index];\n        const start = index;\n\n        if (char === \"\\r\" || char === \"\\n\") {\n            if (char === \"\\r\" && source[index + 1] === \"\\n\") {\n                index += 2;\n                push({ type: \"newline\", value: \"\\r\\n\", start, end: index });\n            } else {\n                index += 1;\n                push({ type: \"newline\", value: \"\\n\", start, end: index });\n            }\n            continue;\n        }\n\n        if (char === \" \" || char === \"\\t\" || char === \"\\f\") {\n            index += 1;\n            continue;\n        }\n\n        if (char === \"<\" && index + 1 < length && source[index + 1] === \"#\") {\n            let searchIndex = index + 2;\n            while (searchIndex < length - 1) {\n                if (\n                    source[searchIndex] === \"#\" &&\n                    source[searchIndex + 1] === \">\"\n                ) {\n                    searchIndex += 2;\n                    break;\n                }\n                searchIndex += 1;\n            }\n            const end = searchIndex >= length ? length : searchIndex;\n            push({\n                type: \"block-comment\",\n                value: source.slice(start, end),\n                start,\n                end,\n            });\n            index = end;\n            continue;\n        }\n\n        if (char === \"#\") {\n            index += 1;\n            while (\n                index < length &&\n                source[index] !== \"\\r\" &&\n                source[index] !== \"\\n\"\n            ) {\n                index += 1;\n            }\n            push({\n                type: \"comment\",\n                value: source.slice(start + 1, index).trimEnd(),\n                start,\n                end: index,\n            });\n            continue;\n        }\n\n        if (char === \"[\") {\n            let lookahead = index + 1;\n            while (lookahead < length && /\\s/.test(source[lookahead])) {\n                lookahead += 1;\n            }\n            if (lookahead < length && /[A-Za-z_]/.test(source[lookahead])) {\n                let depth = 1;\n                let searchIndex = index + 1;\n                while (searchIndex < length && depth > 0) {\n                    const current = source[searchIndex];\n                    if (current === \"'\" || current === '\"') {\n                        const quote = current;\n                        searchIndex += 1;\n                        while (searchIndex < length) {\n                            const ch = source[searchIndex];\n                            if (ch === \"`\") {\n                                searchIndex += 2;\n                                continue;\n                            }\n                            if (ch === quote) {\n                                searchIndex += 1;\n                                break;\n                            }\n                            searchIndex += 1;\n                        }\n                        continue;\n                    }\n                    if (current === \"[\") {\n                        depth += 1;\n                        searchIndex += 1;\n                        continue;\n                    }\n                    if (current === \"]\") {\n                        depth -= 1;\n                        searchIndex += 1;\n                        if (depth === 0) {\n                            break;\n                        }\n                        continue;\n                    }\n                    searchIndex += 1;\n                }\n                const attributeEnd = depth === 0 ? searchIndex : length;\n                push({\n                    type: \"attribute\",\n                    value: source.slice(start, attributeEnd),\n                    start,\n                    end: attributeEnd,\n                });\n                index = attributeEnd;\n                continue;\n            }\n        }\n\n        if (\n            char === \"@\" &&\n            (source[index + 1] === '\"' || source[index + 1] === \"'\")\n        ) {\n            const quoteChar = source[index + 1];\n            const quote = quoteChar === '\"' ? \"double\" : \"single\";\n            let searchIndex = index + 2;\n            let closing = -1;\n            while (searchIndex < length - 1) {\n                if (\n                    source[searchIndex] === quoteChar &&\n                    source[searchIndex + 1] === \"@\"\n                ) {\n                    const prevChar = source[searchIndex - 1];\n                    const prevPrev = source[searchIndex - 2];\n                    const atImmediateClosing = searchIndex === index + 2;\n                    const atUnixLineStart = prevChar === \"\\n\";\n                    const atWindowsLineStart =\n                        prevChar === \"\\r\" && prevPrev === \"\\n\";\n                    if (\n                        atImmediateClosing ||\n                        atUnixLineStart ||\n                        atWindowsLineStart\n                    ) {\n                        closing = searchIndex;\n                        break;\n                    }\n                }\n                searchIndex += 1;\n            }\n\n            let end = length;\n            /* c8 ignore next */\n            if (closing !== -1) {\n                end = closing + 2;\n            }\n\n            push({\n                type: \"heredoc\",\n                value: source.slice(index, end),\n                start,\n                end,\n                quote,\n            });\n            index = end;\n            continue;\n        }\n\n        if (char === \"'\" || char === '\"') {\n            const quote = char === '\"' ? \"double\" : \"single\";\n            index += 1;\n            let escaped = false;\n            while (index < length) {\n                const current = source[index];\n                if (escaped) {\n                    escaped = false;\n                } else if (current === \"`\") {\n                    escaped = true;\n                } else if (current === char) {\n                    index += 1;\n                    break;\n                }\n                index += 1;\n            }\n            push({\n                type: \"string\",\n                value: source.slice(start, index),\n                start,\n                end: index,\n                quote,\n            });\n            continue;\n        }\n\n        if (\n            char === \"@\" &&\n            (source[index + 1] === \"{\" || source[index + 1] === \"(\")\n        ) {\n            const value = `@${source[index + 1]}`;\n            index += 2;\n            push({ type: \"operator\", value, start, end: index });\n            continue;\n        }\n\n        if (char === \":\" && source[index + 1] === \":\") {\n            index += 2;\n            push({ type: \"operator\", value: \"::\", start, end: index });\n            continue;\n        }\n\n        if (PUNCTUATION.has(char)) {\n            index += 1;\n            push({ type: \"punctuation\", value: char, start, end: index });\n            continue;\n        }\n\n        if (char === \"|\" || char === \"=\") {\n            let value = char;\n            if (source[index + 1] === char) {\n                value += char;\n                index += 2;\n            } else {\n                index += 1;\n            }\n            push({ type: \"operator\", value, start, end: index });\n            continue;\n        }\n\n        if (char === \">\" || char === \"<\") {\n            let value = char;\n            if (source[index + 1] === char) {\n                value += char;\n                index += 2;\n            } else {\n                index += 1;\n            }\n            push({ type: \"operator\", value, start, end: index });\n            continue;\n        }\n\n        if (char === \"$\") {\n            index += 1;\n            while (index < length) {\n                const c = source[index];\n                if (/^[A-Za-z0-9_:-]$/.test(c)) {\n                    index += 1;\n                    continue;\n                }\n                if (c === \"{\") {\n                    index += 1;\n                    while (index < length && source[index] !== \"}\") {\n                        index += 1;\n                    }\n                    if (source[index] === \"}\") {\n                        index += 1;\n                    }\n                    continue;\n                }\n                break;\n            }\n            push({\n                type: \"variable\",\n                value: source.slice(start, index),\n                start,\n                end: index,\n            });\n            continue;\n        }\n\n        if (/[0-9]/.test(char)) {\n            index += 1;\n            // Check for hex number (0x...)\n            if (\n                char === \"0\" &&\n                index < length &&\n                (source[index] === \"x\" || source[index] === \"X\")\n            ) {\n                index += 1; // consume 'x' or 'X'\n                while (index < length && /[0-9A-Fa-f]/.test(source[index])) {\n                    index += 1;\n                }\n                push({\n                    type: \"number\",\n                    value: source.slice(start, index),\n                    start,\n                    end: index,\n                });\n                continue;\n            }\n            // Regular decimal number\n            while (index < length && /[0-9]/.test(source[index])) {\n                index += 1;\n            }\n            if (source[index] === \".\" && /[0-9]/.test(source[index + 1])) {\n                index += 2;\n                while (index < length && /[0-9]/.test(source[index])) {\n                    index += 1;\n                }\n            }\n            push({\n                type: \"number\",\n                value: source.slice(start, index),\n                start,\n                end: index,\n            });\n            continue;\n        }\n\n        if (\n            /[A-Za-z_]/.test(char) ||\n            (char === \"-\" &&\n                index + 1 < length &&\n                /[-A-Za-z]/.test(source[index + 1]))\n        ) {\n            index += 1;\n            while (index < length && /[A-Za-z0-9_-]/.test(source[index])) {\n                index += 1;\n            }\n            const raw = source.slice(start, index);\n            const lower = raw.toLowerCase();\n            if (KEYWORDS.has(lower)) {\n                push({ type: \"keyword\", value: raw, start, end: index });\n            } else {\n                push({ type: \"identifier\", value: raw, start, end: index });\n            }\n            continue;\n        }\n\n        // fallback single character token\n        index += 1;\n        push({ type: \"unknown\", value: char, start, end: index });\n    }\n\n    return tokens;\n}\n\nexport function normalizeHereString(node: HereStringNode): string {\n    const lines = node.value.split(/\\r?\\n/);\n    if (lines.length <= 2) {\n        return node.value;\n    }\n    return lines.slice(1, -1).join(\"\\n\");\n}\n","import type { ParserOptions } from \"prettier\";\n\nimport type {\n    ArrayLiteralNode,\n    BlankLineNode,\n    CommentNode,\n    ExpressionNode,\n    ExpressionPartNode,\n    FunctionDeclarationNode,\n    HashtableEntryNode,\n    HashtableNode,\n    HereStringNode,\n    ParenthesisNode,\n    PipelineNode,\n    ScriptBlockNode,\n    ScriptBodyNode,\n    ScriptNode,\n    SourceLocation,\n    TextNode,\n    TokenRole,\n} from \"./ast.js\";\nimport { resolveOptions } from \"./options.js\";\nimport type { Token } from \"./tokenizer.js\";\nimport { tokenize } from \"./tokenizer.js\";\n\nconst FALLBACK_OPERATOR_TOKENS = new Set([\n    \"+\",\n    \"-\",\n    \"*\",\n    \"/\",\n    \"%\",\n    \"&\",\n    \"|\",\n    \"^\",\n    \"!\",\n    \"?\",\n    \"++\",\n    \"--\",\n    \"+=\",\n    \"-=\",\n    \"*=\",\n    \"/=\",\n    \"%=\",\n    \"&=\",\n    \"|=\",\n    \"^=\",\n    \"??\",\n]);\n\nfunction extendNodeLocation(node: { loc: SourceLocation }, end: number): void {\n    if (end > node.loc.end) {\n        node.loc = { ...node.loc, end };\n    }\n}\n\nclass Parser {\n    private index = 0;\n\n    constructor(\n        private readonly tokens: Token[],\n        private readonly source: string\n    ) {}\n\n    parseScript(terminators: Set<string> = new Set()): ScriptNode {\n        const body: ScriptBodyNode[] = [];\n        const start = this.tokens.length > 0 ? this.tokens[0].start : 0;\n\n        while (!this.isEOF()) {\n            const token = this.peek()!;\n\n            if (terminators.has(token.value) && token.type === \"punctuation\") {\n                break;\n            }\n\n            if (token.type === \"newline\") {\n                const blank = this.consumeBlankLines();\n                body.push(blank);\n                continue;\n            }\n\n            if (token.type === \"comment\" || token.type === \"block-comment\") {\n                const commentToken = this.advance();\n                const commentNode = this.createCommentNode(commentToken, false);\n                if (body.length > 0) {\n                    const previousNode = body[body.length - 1];\n                    let lookahead = 0;\n                    let nextToken: Token | undefined;\n                    while (true) {\n                        nextToken = this.peek(lookahead);\n                        if (!nextToken) {\n                            break;\n                        }\n                        if (nextToken.type === \"newline\") {\n                            lookahead += 1;\n                            continue;\n                        }\n                        break;\n                    }\n                    if (previousNode.type === \"Pipeline\") {\n                        const lastSegment =\n                            previousNode.segments[\n                                previousNode.segments.length - 1\n                            ];\n                        const lastPart =\n                            lastSegment?.parts[lastSegment.parts.length - 1];\n                        const belongsToBlock = Boolean(\n                            lastPart &&\n                                lastPart.type === \"ScriptBlock\" &&\n                                (commentNode.loc.start < lastPart.loc.end ||\n                                    (nextToken &&\n                                        nextToken.type === \"punctuation\" &&\n                                        nextToken.value === \"}\"))\n                        );\n                        if (\n                            belongsToBlock &&\n                            lastPart &&\n                            lastPart.type === \"ScriptBlock\" &&\n                            lastSegment\n                        ) {\n                            lastPart.body.push(commentNode);\n                            extendNodeLocation(lastPart, commentNode.loc.end);\n                            extendNodeLocation(\n                                lastSegment,\n                                commentNode.loc.end\n                            );\n                            extendNodeLocation(\n                                previousNode,\n                                commentNode.loc.end\n                            );\n                            continue;\n                        }\n                    }\n                }\n                body.push(commentNode);\n                continue;\n            }\n\n            if (this.isFunctionDeclaration()) {\n                body.push(this.parseFunction());\n                continue;\n            }\n\n            const statement = this.parseStatement();\n            if (statement) {\n                body.push(statement);\n            } else {\n                // avoid infinite loops\n                this.advance();\n            }\n        }\n\n        const end = body.length > 0 ? body[body.length - 1].loc.end : start;\n        return {\n            type: \"Script\",\n            body,\n            loc: { start, end },\n        } satisfies ScriptNode;\n    }\n\n    private parseFunction(): FunctionDeclarationNode {\n        const startToken = this.advance(); // function keyword\n        const headerTokens: Token[] = [startToken];\n\n        while (!this.isEOF()) {\n            const token = this.peek()!;\n            if (token.type === \"comment\") {\n                break;\n            }\n            if (token.type === \"punctuation\" && token.value === \"{\") {\n                break;\n            }\n            headerTokens.push(this.advance());\n        }\n\n        const headerExpression = buildExpressionFromTokens(\n            headerTokens,\n            this.source\n        );\n        const body = this.parseScriptBlock();\n        const end = body.loc.end;\n\n        return {\n            type: \"FunctionDeclaration\",\n            header: headerExpression,\n            body,\n            loc: { start: startToken.start, end },\n        } satisfies FunctionDeclarationNode;\n    }\n\n    private parseStatement(): PipelineNode | null {\n        const segments: Token[][] = [[]];\n        let trailingComment: CommentNode | undefined;\n\n        const structureStack: string[] = [];\n        let lineContinuation = false;\n\n        while (!this.isEOF()) {\n            const token = this.peek()!;\n\n            if (token.type === \"newline\") {\n                if (lineContinuation) {\n                    this.advance();\n                    lineContinuation = false;\n                    continue;\n                }\n                /* c8 ignore next */\n                if (structureStack.length > 0) {\n                    const newlineToken = this.advance();\n                    segments[segments.length - 1].push(newlineToken);\n                    continue;\n                }\n                if (\n                    structureStack.length === 0 &&\n                    this.isPipelineContinuationAfterNewline()\n                ) {\n                    this.advance();\n                    continue;\n                }\n                break;\n            }\n\n            if (\n                token.type === \"punctuation\" &&\n                token.value === \";\" &&\n                structureStack.length === 0\n            ) {\n                this.advance();\n                break;\n            }\n\n            if (\n                token.type === \"punctuation\" &&\n                token.value === \"}\" &&\n                structureStack.length === 0\n            ) {\n                break;\n            }\n\n            if (token.type === \"comment\") {\n                if (\n                    structureStack.length === 0 &&\n                    this.isInlineComment(token)\n                ) {\n                    trailingComment = this.createCommentNode(\n                        this.advance(),\n                        true\n                    );\n                }\n                if (structureStack.length === 0) {\n                    break;\n                }\n                // Inside a structure - include the comment as part of the statement\n                const currentSegment = segments[segments.length - 1];\n                currentSegment.push(this.advance());\n                continue;\n            }\n\n            if (token.type === \"block-comment\") {\n                if (structureStack.length === 0) {\n                    break;\n                }\n                // Inside a structure - include the block comment\n                const currentSegment = segments[segments.length - 1];\n                currentSegment.push(this.advance());\n                continue;\n            }\n\n            if (token.type === \"operator\" && token.value === \"|\") {\n                if (structureStack.length > 0) {\n                    const currentSegment = segments[segments.length - 1];\n                    currentSegment.push(this.advance());\n                    lineContinuation = false;\n                    continue;\n                }\n\n                this.advance();\n                segments.push([]);\n                lineContinuation = false;\n                continue;\n            }\n\n            /* c8 ignore next */\n            if (token.type === \"unknown\" && token.value === \"`\") {\n                this.advance();\n                lineContinuation = true;\n                continue;\n            }\n\n            const currentSegment = segments[segments.length - 1];\n            currentSegment.push(this.advance());\n            lineContinuation = false;\n\n            if (isOpeningToken(token)) {\n                structureStack.push(token.value);\n            } else if (isClosingToken(token)) {\n                structureStack.pop();\n            }\n        }\n\n        const filteredSegments = segments.filter(\n            (segment) => segment.length > 0\n        );\n        if (filteredSegments.length === 0) {\n            return null;\n        }\n\n        const expressionSegments = filteredSegments.map((segmentTokens) =>\n            buildExpressionFromTokens(segmentTokens, this.source)\n        );\n        const start = expressionSegments[0].loc.start;\n        const end = expressionSegments[expressionSegments.length - 1].loc.end;\n\n        const pipelineNode: PipelineNode = {\n            type: \"Pipeline\",\n            segments: expressionSegments,\n            loc: { start, end },\n        };\n\n        if (trailingComment) {\n            pipelineNode.trailingComment = trailingComment;\n        }\n\n        return pipelineNode;\n    }\n\n    private parseScriptBlock(): ScriptBlockNode {\n        const openToken = this.peek();\n        if (\n            !openToken ||\n            openToken.type !== \"punctuation\" ||\n            openToken.value !== \"{\"\n        ) {\n            return {\n                type: \"ScriptBlock\",\n                body: [],\n                loc: { start: openToken?.start ?? 0, end: openToken?.end ?? 0 },\n            } satisfies ScriptBlockNode;\n        }\n        this.advance();\n\n        const { contentTokens, closingToken } =\n            this.collectBalancedTokens(openToken);\n        const nestedParser = new Parser(contentTokens, this.source);\n        const script = nestedParser.parseScript(new Set());\n        const closingEnd = closingToken?.end ?? openToken.end;\n        const bodyEnd =\n            script.body.length > 0\n                ? script.body[script.body.length - 1].loc.end\n                : closingEnd;\n        const end = Math.max(closingEnd, bodyEnd);\n\n        return {\n            type: \"ScriptBlock\",\n            body: script.body,\n            loc: { start: openToken.start, end },\n        } satisfies ScriptBlockNode;\n    }\n\n    private collectBalancedTokens(startToken: Token): {\n        contentTokens: Token[];\n        closingToken?: Token;\n    } {\n        const contentTokens: Token[] = [];\n        const stack: string[] = [startToken.value];\n\n        while (!this.isEOF()) {\n            const token = this.advance();\n\n            if (isOpeningToken(token)) {\n                stack.push(token.value);\n                contentTokens.push(token);\n                continue;\n            }\n\n            if (isClosingToken(token)) {\n                if (stack.length <= 1) {\n                    return { contentTokens, closingToken: token };\n                }\n                stack.pop();\n                contentTokens.push(token);\n                continue;\n            }\n\n            contentTokens.push(token);\n        }\n\n        return { contentTokens };\n    }\n\n    private consumeBlankLines(): BlankLineNode {\n        let count = 0;\n        const start = this.peek()!.start;\n        let end = start;\n        while (!this.isEOF()) {\n            const token = this.peek();\n            if (!token || token.type !== \"newline\") {\n                break;\n            }\n            const current = this.advance();\n            count += 1;\n            end = current.end;\n        }\n        return {\n            type: \"BlankLine\",\n            count,\n            loc: { start, end },\n        } satisfies BlankLineNode;\n    }\n\n    private createCommentNode(token: Token, inline: boolean): CommentNode {\n        const style = token.type === \"block-comment\" ? \"block\" : \"line\";\n        const isInline =\n            style === \"line\" && inline && this.isInlineComment(token);\n\n        return {\n            type: \"Comment\",\n            value: token.value,\n            inline: isInline,\n            style,\n            loc: { start: token.start, end: token.end },\n        } satisfies CommentNode;\n    }\n\n    private isInlineComment(token: Token): boolean {\n        if (token.type !== \"comment\") {\n            return false;\n        }\n        if (this.source.length === 0 || token.start === 0) {\n            return true;\n        }\n\n        let cursor = token.start - 1;\n        while (cursor >= 0) {\n            const char = this.source[cursor];\n            if (char === \"\\n\") {\n                return false;\n            }\n            if (char === \"\\r\") {\n                return false;\n            }\n            if (!/\\s/.test(char)) {\n                return true;\n            }\n            cursor -= 1;\n        }\n\n        return false;\n    }\n\n    private isPipelineContinuationAfterNewline(): boolean {\n        let offset = 1;\n        while (true) {\n            const next = this.peek(offset);\n            if (!next) {\n                return false;\n            }\n            if (next.type === \"newline\") {\n                offset += 1;\n                continue;\n            }\n            if (next.type === \"comment\") {\n                return false;\n            }\n            if (next.type === \"operator\" && next.value === \"|\") {\n                return true;\n            }\n            return false;\n        }\n    }\n\n    private isFunctionDeclaration(): boolean {\n        const token = this.peek();\n        return Boolean(\n            token &&\n                token.type === \"keyword\" &&\n                token.value.toLowerCase() === \"function\"\n        );\n    }\n\n    private peek(offset = 0): Token | undefined {\n        return this.tokens[this.index + offset];\n    }\n\n    private advance(): Token {\n        const token = this.tokens[this.index];\n        this.index += 1;\n        return token;\n    }\n\n    private isEOF(): boolean {\n        return this.index >= this.tokens.length;\n    }\n}\n\nfunction isOpeningToken(token: Token): boolean {\n    if (token.type === \"operator\") {\n        return token.value === \"@{\" || token.value === \"@(\";\n    }\n    return (\n        token.type === \"punctuation\" &&\n        (token.value === \"{\" || token.value === \"(\" || token.value === \"[\")\n    );\n}\n\nfunction isClosingToken(token: Token): boolean {\n    return (\n        token.type === \"punctuation\" &&\n        (token.value === \"}\" || token.value === \")\" || token.value === \"]\")\n    );\n}\n\nfunction buildExpressionFromTokens(\n    tokens: Token[],\n    source: string = \"\"\n): ExpressionNode {\n    const firstToken = tokens.find((token) => token.type !== \"newline\");\n    const lastToken = [...tokens]\n        .reverse()\n        .find((token) => token.type !== \"newline\");\n    if (!firstToken || !lastToken) {\n        return {\n            type: \"Expression\",\n            parts: [],\n            loc: {\n                start: tokens[0]?.start ?? 0,\n                end: tokens[tokens.length - 1]?.end ?? 0,\n            },\n        } satisfies ExpressionNode;\n    }\n\n    const parts: ExpressionPartNode[] = [];\n    let index = 0;\n\n    while (index < tokens.length) {\n        const token = tokens[index];\n\n        if (token.type === \"newline\") {\n            index += 1;\n            continue;\n        }\n\n        if (token.type === \"operator\" && token.value === \"@{\") {\n            const { node, nextIndex } = parseHashtablePart(\n                tokens,\n                index,\n                source\n            );\n            parts.push(node);\n            index = nextIndex;\n            continue;\n        }\n\n        if (\n            (token.type === \"operator\" && token.value === \"@(\") ||\n            (token.type === \"punctuation\" && token.value === \"[\")\n        ) {\n            const { node, nextIndex } = parseArrayPart(tokens, index, source);\n            parts.push(node);\n            index = nextIndex;\n            continue;\n        }\n\n        if (token.type === \"punctuation\" && token.value === \"{\") {\n            const { node, nextIndex } = parseScriptBlockPart(\n                tokens,\n                index,\n                source\n            );\n            parts.push(node);\n            index = nextIndex;\n            continue;\n        }\n\n        if (token.type === \"punctuation\" && token.value === \"(\") {\n            const { node, nextIndex } = parseParenthesisPart(\n                tokens,\n                index,\n                source\n            );\n            parts.push(node);\n            index = nextIndex;\n            continue;\n        }\n\n        if (token.type === \"heredoc\") {\n            parts.push(createHereStringNode(token));\n            index += 1;\n            continue;\n        }\n\n        if (token.type === \"attribute\") {\n            parts.push(createTextNode(token));\n            index += 1;\n            continue;\n        }\n\n        parts.push(createTextNode(token));\n        index += 1;\n    }\n\n    const expressionEnd =\n        parts.length > 0 ? parts[parts.length - 1].loc.end : lastToken.end;\n\n    return {\n        type: \"Expression\",\n        parts,\n        loc: {\n            start: firstToken.start,\n            end: expressionEnd,\n        },\n    } satisfies ExpressionNode;\n}\n\nfunction parseHashtablePart(\n    tokens: Token[],\n    startIndex: number,\n    source: string = \"\"\n): { node: HashtableNode; nextIndex: number } {\n    const startToken = tokens[startIndex];\n    const { contentTokens, endIndex, closingToken } = collectStructureTokens(\n        tokens,\n        startIndex\n    );\n    const entries = splitHashtableEntries(contentTokens).map((entryTokens) =>\n        buildHashtableEntry(entryTokens, source)\n    );\n    const end =\n        closingToken?.end ??\n        contentTokens[contentTokens.length - 1]?.end ??\n        startToken.end;\n    return {\n        node: {\n            type: \"Hashtable\",\n            entries,\n            loc: { start: startToken.start, end },\n        },\n        nextIndex: endIndex,\n    };\n}\n\nfunction resolveStructureEnd(\n    startToken: Token,\n    closingToken: Token | undefined,\n    contentTokens: Token[]\n): number {\n    if (closingToken) {\n        return closingToken.end;\n    }\n    const lastContent =\n        contentTokens.length > 0\n            ? contentTokens[contentTokens.length - 1]\n            : undefined;\n    if (lastContent) {\n        return lastContent.end;\n    }\n    return startToken.end;\n}\n\nfunction parseArrayPart(\n    tokens: Token[],\n    startIndex: number,\n    source: string = \"\"\n): { node: ArrayLiteralNode; nextIndex: number } {\n    const startToken = tokens[startIndex];\n    const { contentTokens, endIndex, closingToken } = collectStructureTokens(\n        tokens,\n        startIndex\n    );\n    const elements = splitArrayElements(contentTokens).map((elementTokens) =>\n        buildExpressionFromTokens(elementTokens, source)\n    );\n    /* c8 ignore next */\n    const kind = startToken.value === \"@(\" ? \"implicit\" : \"explicit\";\n    const end = resolveStructureEnd(startToken, closingToken, contentTokens);\n    return {\n        node: {\n            type: \"ArrayLiteral\",\n            elements,\n            kind,\n            loc: { start: startToken.start, end },\n        },\n        nextIndex: endIndex,\n    } satisfies { node: ArrayLiteralNode; nextIndex: number };\n}\n\nfunction parseParenthesisPart(\n    tokens: Token[],\n    startIndex: number,\n    source: string = \"\"\n): { node: ParenthesisNode; nextIndex: number } {\n    const startToken = tokens[startIndex];\n    const { contentTokens, endIndex, closingToken } = collectStructureTokens(\n        tokens,\n        startIndex\n    );\n    const elements = splitArrayElements(contentTokens).map((elementTokens) =>\n        buildExpressionFromTokens(elementTokens, source)\n    );\n    const hasComma = hasTopLevelComma(contentTokens);\n    const hasNewline = contentTokens.some((token) => token.type === \"newline\");\n    const end = resolveStructureEnd(startToken, closingToken, contentTokens);\n    return {\n        node: {\n            type: \"Parenthesis\",\n            elements,\n            hasComma,\n            hasNewline,\n            loc: { start: startToken.start, end },\n        },\n        nextIndex: endIndex,\n    };\n}\n\nfunction parseScriptBlockPart(\n    tokens: Token[],\n    startIndex: number,\n    source: string = \"\"\n): { node: ScriptBlockNode; nextIndex: number } {\n    const startToken = tokens[startIndex];\n    const { contentTokens, endIndex, closingToken } = collectStructureTokens(\n        tokens,\n        startIndex\n    );\n    const nestedParser = new Parser(contentTokens, source);\n    const script = nestedParser.parseScript();\n    const closingEnd = resolveStructureEnd(\n        startToken,\n        closingToken,\n        contentTokens\n    );\n    const bodyEnd =\n        script.body.length > 0\n            ? script.body[script.body.length - 1].loc.end\n            : closingEnd;\n    const end = Math.max(closingEnd, bodyEnd);\n    return {\n        node: {\n            type: \"ScriptBlock\",\n            body: script.body,\n            loc: { start: startToken.start, end },\n        },\n        nextIndex: endIndex,\n    };\n}\n\nfunction createHereStringNode(token: Token): HereStringNode {\n    const quote = token.quote ?? \"double\";\n    return {\n        type: \"HereString\",\n        quote,\n        value: token.value,\n        loc: { start: token.start, end: token.end },\n    } satisfies HereStringNode;\n}\n\nfunction createTextNode(token: Token): TextNode {\n    let role: TokenRole =\n        token.type === \"identifier\"\n            ? \"word\"\n            : token.type === \"keyword\"\n              ? \"keyword\"\n              : token.type === \"number\"\n                ? \"number\"\n                : token.type === \"variable\"\n                  ? \"variable\"\n                  : token.type === \"string\"\n                    ? \"string\"\n                    : token.type === \"operator\"\n                      ? \"operator\"\n                      : token.type === \"punctuation\"\n                        ? \"punctuation\"\n                        : \"unknown\";\n\n    if (\n        (role === \"unknown\" || role === \"word\") &&\n        FALLBACK_OPERATOR_TOKENS.has(token.value)\n    ) {\n        role = \"operator\";\n    }\n\n    return {\n        type: \"Text\",\n        value: token.value,\n        role,\n        loc: { start: token.start, end: token.end },\n    } satisfies TextNode;\n}\n\nfunction collectStructureTokens(\n    tokens: Token[],\n    startIndex: number\n): { contentTokens: Token[]; endIndex: number; closingToken?: Token } {\n    const contentTokens: Token[] = [];\n    const stack: string[] = [tokens[startIndex].value];\n    let index = startIndex + 1;\n\n    while (index < tokens.length) {\n        const token = tokens[index];\n\n        if (isOpeningToken(token)) {\n            stack.push(token.value);\n            contentTokens.push(token);\n            index += 1;\n            continue;\n        }\n\n        if (isClosingToken(token)) {\n            if (stack.length === 1) {\n                return {\n                    contentTokens,\n                    endIndex: index + 1,\n                    closingToken: token,\n                };\n            }\n            stack.pop();\n            contentTokens.push(token);\n            index += 1;\n            continue;\n        }\n\n        contentTokens.push(token);\n        index += 1;\n    }\n\n    return { contentTokens, endIndex: tokens.length };\n}\n\nfunction parseStatementForTest(tokens: Token[]): PipelineNode | null {\n    const parser = new Parser(tokens, \"\");\n    const internal = parser as unknown as {\n        parseStatement(): PipelineNode | null;\n    };\n    return internal.parseStatement();\n}\n\nfunction splitHashtableEntries(tokens: Token[]): Token[][] {\n    const entries: Token[][] = [];\n    let current: Token[] = [];\n    const stack: string[] = [];\n\n    for (const token of tokens) {\n        if (token.type === \"newline\" && stack.length === 0) {\n            if (current.length > 0) {\n                entries.push(current);\n                current = [];\n            }\n            continue;\n        }\n\n        if (\n            token.type === \"punctuation\" &&\n            token.value === \";\" &&\n            stack.length === 0\n        ) {\n            if (current.length > 0) {\n                entries.push(current);\n                current = [];\n            }\n            continue;\n        }\n\n        if (isOpeningToken(token)) {\n            stack.push(token.value);\n            current.push(token);\n            continue;\n        }\n\n        if (isClosingToken(token)) {\n            stack.pop();\n            current.push(token);\n            continue;\n        }\n\n        current.push(token);\n    }\n\n    if (current.length > 0) {\n        entries.push(current);\n    }\n\n    return entries;\n}\n\nfunction buildHashtableEntry(\n    tokens: Token[],\n    source: string = \"\"\n): HashtableEntryNode {\n    const equalsIndex = findTopLevelEquals(tokens);\n    const keyTokens =\n        equalsIndex === -1 ? tokens : tokens.slice(0, equalsIndex);\n    const valueTokens = equalsIndex === -1 ? [] : tokens.slice(equalsIndex + 1);\n    const keyExpression = buildExpressionFromTokens(keyTokens, source);\n    const valueExpression =\n        valueTokens.length > 0\n            ? buildExpressionFromTokens(valueTokens, source)\n            : buildExpressionFromTokens([], source);\n    const key = extractKeyText(keyTokens);\n    const start = keyTokens[0]?.start ?? valueTokens[0]?.start ?? 0;\n    const end =\n        (valueTokens[valueTokens.length - 1] ?? keyTokens[keyTokens.length - 1])\n            ?.end ?? start;\n\n    return {\n        type: \"HashtableEntry\",\n        key,\n        rawKey: keyExpression,\n        value: valueExpression,\n        loc: { start, end },\n    } satisfies HashtableEntryNode;\n}\n\nfunction findTopLevelEquals(tokens: Token[]): number {\n    const stack: string[] = [];\n    for (let index = 0; index < tokens.length; index += 1) {\n        const token = tokens[index];\n        if (isOpeningToken(token)) {\n            stack.push(token.value);\n            continue;\n        }\n        if (isClosingToken(token)) {\n            stack.pop();\n            continue;\n        }\n        if (\n            stack.length === 0 &&\n            token.type === \"operator\" &&\n            token.value === \"=\"\n        ) {\n            return index;\n        }\n    }\n    return -1;\n}\n\nfunction extractKeyText(tokens: Token[]): string {\n    const text = tokens\n        .filter((token) => token.type !== \"newline\")\n        .map((token) => token.value)\n        .join(\" \")\n        .trim();\n    if (text.startsWith('\"') && text.endsWith('\"')) {\n        return text.slice(1, -1);\n    }\n    if (text.startsWith(\"'\") && text.endsWith(\"'\")) {\n        return text.slice(1, -1);\n    }\n    return text;\n}\n\nfunction splitArrayElements(tokens: Token[]): Token[][] {\n    const elements: Token[][] = [];\n    let current: Token[] = [];\n    const stack: string[] = [];\n\n    for (const token of tokens) {\n        if (token.type === \"newline\" && stack.length === 0) {\n            if (current.length > 0) {\n                elements.push(current);\n                current = [];\n            }\n            continue;\n        }\n\n        if (\n            token.type === \"punctuation\" &&\n            token.value === \",\" &&\n            stack.length === 0\n        ) {\n            elements.push(current);\n            current = [];\n            continue;\n        }\n\n        if (isOpeningToken(token)) {\n            stack.push(token.value);\n            current.push(token);\n            continue;\n        }\n\n        if (isClosingToken(token)) {\n            stack.pop();\n            current.push(token);\n            continue;\n        }\n\n        current.push(token);\n    }\n\n    if (current.length > 0) {\n        elements.push(current);\n    }\n\n    return elements;\n}\n\nfunction hasTopLevelComma(tokens: Token[]): boolean {\n    const stack: string[] = [];\n    for (const token of tokens) {\n        if (isOpeningToken(token)) {\n            stack.push(token.value);\n            continue;\n        }\n        if (isClosingToken(token)) {\n            stack.pop();\n            continue;\n        }\n        if (\n            stack.length === 0 &&\n            token.type === \"punctuation\" &&\n            token.value === \",\"\n        ) {\n            return true;\n        }\n    }\n    return false;\n}\n\nexport function parsePowerShell(\n    source: string,\n    options: ParserOptions\n): ScriptNode {\n    resolveOptions(options);\n    const tokens = tokenize(source);\n    const parser = new Parser(tokens, source);\n    return parser.parseScript();\n}\n\nexport function parseScriptWithTerminators(\n    source: string,\n    terminators: Set<string>\n): ScriptNode {\n    const tokens = tokenize(source);\n    const parser = new Parser(tokens, source);\n    return parser.parseScript(terminators);\n}\nexport const __parserTestUtils: {\n    isOpeningToken: typeof isOpeningToken;\n    isClosingToken: typeof isClosingToken;\n    collectStructureTokens: typeof collectStructureTokens;\n    splitHashtableEntries: typeof splitHashtableEntries;\n    findTopLevelEquals: typeof findTopLevelEquals;\n    extractKeyText: typeof extractKeyText;\n    splitArrayElements: typeof splitArrayElements;\n    hasTopLevelComma: typeof hasTopLevelComma;\n    parseScriptWithTerminators: typeof parseScriptWithTerminators;\n    buildExpressionFromTokens: typeof buildExpressionFromTokens;\n    createHereStringNode: typeof createHereStringNode;\n    createTextNode: typeof createTextNode;\n    buildHashtableEntry: typeof buildHashtableEntry;\n    resolveStructureEnd: typeof resolveStructureEnd;\n    parseStatementForTest: typeof parseStatementForTest;\n} = {\n    isOpeningToken,\n    isClosingToken,\n    collectStructureTokens,\n    splitHashtableEntries,\n    findTopLevelEquals,\n    extractKeyText,\n    splitArrayElements,\n    hasTopLevelComma,\n    parseScriptWithTerminators,\n    buildExpressionFromTokens,\n    createHereStringNode,\n    createTextNode,\n    buildHashtableEntry,\n    resolveStructureEnd,\n    parseStatementForTest,\n};\n\nexport const locStart = (node: { loc: { start: number } }): number =>\n    node.loc.start;\nexport const locEnd = (node: { loc: { end: number } }): number => node.loc.end;\n","import type { AstPath, Doc, ParserOptions, Printer } from \"prettier\";\nimport { doc } from \"prettier\";\n\nimport {\n    type ArrayLiteralNode,\n    type CommentNode,\n    type ExpressionNode,\n    type ExpressionPartNode,\n    type FunctionDeclarationNode,\n    type HashtableEntryNode,\n    type HashtableNode,\n    type HereStringNode,\n    type ParenthesisNode,\n    type PipelineNode,\n    type ScriptBlockNode,\n    type ScriptBodyNode,\n    type ScriptNode,\n    type TextNode,\n} from \"./ast.js\";\nimport { resolveOptions, type ResolvedOptions } from \"./options.js\";\n\nconst {\n    group,\n    indent,\n    line,\n    softline,\n    hardline,\n    join,\n    ifBreak,\n    lineSuffix,\n    dedentToRoot,\n    align,\n} = doc.builders;\n\nexport const powerShellPrinter: Printer<ScriptNode> = {\n    print(path: AstPath, options: ParserOptions) {\n        const node = path.getValue() as\n            | ScriptNode\n            | ScriptBodyNode\n            | ExpressionPartNode\n            | undefined;\n        if (!node) {\n            return \"\";\n        }\n        const resolved = resolveOptions(options);\n        return printNode(node, resolved);\n    },\n};\n\nfunction printNode(\n    node:\n        | ScriptNode\n        | ScriptBodyNode\n        | ExpressionNode\n        | ExpressionPartNode\n        | HashtableEntryNode,\n    options: ResolvedOptions\n): Doc {\n    switch (node.type) {\n        case \"Script\":\n            return printScript(node, options);\n        case \"ScriptBlock\":\n            return printScriptBlock(node, options);\n        case \"FunctionDeclaration\":\n            return printFunction(node, options);\n        case \"Pipeline\":\n            return printPipeline(node, options);\n        case \"Expression\":\n            return printExpression(node, options);\n        case \"Text\":\n            return printText(node, options);\n        case \"Comment\":\n            return printComment(node);\n        case \"BlankLine\":\n            return Array.from({ length: node.count }, () => hardline);\n        case \"ArrayLiteral\":\n            return printArray(node, options);\n        case \"Hashtable\":\n            return printHashtable(node, options);\n        case \"HashtableEntry\":\n            return printHashtableEntry(node, options);\n        case \"HereString\":\n            return printHereString(node);\n        case \"Parenthesis\":\n            return printParenthesis(node, options);\n        default:\n            return \"\";\n    }\n}\n\nfunction concatDocs(docs: Doc[]): Doc {\n    if (docs.length === 0) {\n        return \"\";\n    }\n    let acc: Doc = docs[0];\n    for (let index = 1; index < docs.length; index += 1) {\n        acc = [acc, docs[index]] as Doc;\n    }\n    return acc;\n}\n\nfunction indentStatement(docToIndent: Doc, options: ResolvedOptions): Doc {\n    const indentUnit =\n        options.indentStyle === \"tabs\" ? \"\\t\" : \" \".repeat(options.indentSize);\n    return [indentUnit, align(indentUnit.length, docToIndent)] as Doc;\n}\n\nfunction printScript(node: ScriptNode, options: ResolvedOptions): Doc {\n    const bodyDoc = printStatementList(node.body, options, false);\n    if (!bodyDoc) {\n        return \"\";\n    }\n    return [bodyDoc, hardline];\n}\n\nfunction printStatementList(\n    body: ScriptBodyNode[],\n    options: ResolvedOptions,\n    indentStatements: boolean\n): Doc {\n    const docs: Doc[] = [];\n    let previous: ScriptBodyNode | null = null;\n    let pendingBlankLines = 0;\n\n    for (const entry of body) {\n        if (entry.type === \"BlankLine\") {\n            pendingBlankLines = Math.max(pendingBlankLines, entry.count);\n            continue;\n        }\n\n        if (previous) {\n            const blankLines = determineBlankLines(\n                previous,\n                entry,\n                pendingBlankLines,\n                options\n            );\n            for (let index = 0; index < blankLines; index += 1) {\n                docs.push(hardline);\n            }\n        }\n\n        const printed = printNode(entry, options);\n        if (\n            entry.type === \"Comment\" &&\n            previous &&\n            entry.loc.start < previous.loc.end &&\n            docs.length > 0\n        ) {\n            const commentDoc = indentStatements\n                ? indentStatement(printed, options)\n                : printed;\n            const lastIndex = docs.length - 1;\n            const priorDoc = docs[lastIndex];\n            docs[lastIndex] = priorDoc\n                ? concatDocs([\n                      priorDoc,\n                      hardline,\n                      commentDoc,\n                  ])\n                : commentDoc;\n            previous = entry;\n            pendingBlankLines = 0;\n            continue;\n        }\n\n        docs.push(\n            indentStatements ? indentStatement(printed, options) : printed\n        );\n        previous = entry;\n        pendingBlankLines = 0;\n    }\n\n    return concatDocs(docs);\n}\n\nfunction determineBlankLines(\n    previous: ScriptBodyNode,\n    current: ScriptBodyNode,\n    pendingBlankLines: number,\n    options: ResolvedOptions\n): number {\n    let base = pendingBlankLines > 0 ? pendingBlankLines : 1;\n    const desiredFunctionSpacing = options.blankLinesBetweenFunctions + 1;\n\n    if (\n        (previous.type === \"FunctionDeclaration\" &&\n            current.type === \"FunctionDeclaration\") ||\n        (previous.type === \"FunctionDeclaration\" &&\n            current.type !== \"BlankLine\") ||\n        (current.type === \"FunctionDeclaration\" &&\n            previous.type !== \"BlankLine\")\n    ) {\n        base = Math.max(base, desiredFunctionSpacing);\n    }\n\n    if (options.blankLineAfterParam && isParamStatement(previous)) {\n        base = Math.max(base, 2);\n    }\n\n    return base;\n}\n\nfunction printScriptBlock(\n    node: ScriptBlockNode,\n    options: ResolvedOptions\n): Doc {\n    if (node.body.length === 0) {\n        return \"{}\";\n    }\n\n    const bodyDoc = printStatementList(node.body, options, true);\n    return group([\n        \"{\",\n        hardline,\n        bodyDoc,\n        hardline,\n        \"}\",\n    ]);\n}\n\nfunction printFunction(\n    node: FunctionDeclarationNode,\n    options: ResolvedOptions\n): Doc {\n    const headerDoc = printExpression(node.header, options);\n    const bodyDoc = printScriptBlock(node.body, options);\n    if (options.braceStyle === \"allman\") {\n        return group([\n            headerDoc,\n            hardline,\n            bodyDoc,\n        ]);\n    }\n    return group([\n        headerDoc,\n        \" \",\n        bodyDoc,\n    ]);\n}\n\nfunction printPipeline(node: PipelineNode, options: ResolvedOptions): Doc {\n    const segmentDocs = node.segments.map((segment) =>\n        printExpression(segment, options)\n    );\n    if (segmentDocs.length === 0) {\n        return \"\";\n    }\n\n    let pipelineDoc: Doc = segmentDocs[0];\n\n    if (segmentDocs.length > 1) {\n        const restDocs = segmentDocs\n            .slice(1)\n            .map((segmentDoc) => [line, [\"| \", segmentDoc]]);\n        pipelineDoc = group([\n            segmentDocs[0],\n            indent(restDocs.flatMap((docItem) => docItem)),\n        ]);\n    }\n\n    if (node.trailingComment) {\n        if (node.trailingComment.inline) {\n            pipelineDoc = [\n                pipelineDoc,\n                lineSuffix([\" #\", node.trailingComment.value]),\n            ];\n        } else {\n            pipelineDoc = [\n                pipelineDoc,\n                hardline,\n                printComment(node.trailingComment),\n            ];\n        }\n    }\n\n    return pipelineDoc;\n}\n\nfunction printExpression(node: ExpressionNode, options: ResolvedOptions): Doc {\n    const docs: Doc[] = [];\n\n    const filteredParts = node.parts.filter((part) => !shouldSkipPart(part));\n    const normalizedParts: ExpressionPartNode[] = [];\n\n    for (let index = 0; index < filteredParts.length; index += 1) {\n        const current = filteredParts[index];\n        if (current.type === \"Text\" && current.role === \"operator\") {\n            const next = filteredParts[index + 1];\n            if (next && next.type === \"Text\" && next.role === \"operator\") {\n                const combinedValue = current.value + next.value;\n                if (CONCATENATED_OPERATOR_PAIRS.has(combinedValue)) {\n                    normalizedParts.push({\n                        ...current,\n                        value: combinedValue,\n                        loc: { start: current.loc.start, end: next.loc.end },\n                    });\n                    index += 1;\n                    continue;\n                }\n            }\n        }\n        normalizedParts.push(current);\n    }\n\n    let previous: ExpressionPartNode | null = null;\n\n    for (let i = 0; i < normalizedParts.length; i += 1) {\n        const part = normalizedParts[i];\n\n        if (part.type === \"Parenthesis\" && isParamKeyword(previous)) {\n            docs.push(printParamParenthesis(part, options));\n            previous = part;\n            continue;\n        }\n\n        // Check if this is comment text (not starting with #, but appears to be prose)\n        if (\n            part.type === \"Text\" &&\n            part.role === \"unknown\" &&\n            previous &&\n            !part.value.trim().startsWith(\"#\") &&\n            !part.value.trim().startsWith(\"$\") &&\n            !part.value.trim().startsWith(\"[\") &&\n            part.value.trim().length > 10\n        ) {\n            // This looks like comment text - treat it as an inline comment\n            docs.push(lineSuffix([\" # \", part.value.trim()]));\n            previous = part;\n            continue;\n        }\n\n        if (previous) {\n            // Special case: word followed by parenthesis could be method call or cmdlet\n            // Check if the word comes after . or :: (method call - no space)\n            if (\n                part.type === \"Parenthesis\" &&\n                previous.type === \"Text\" &&\n                previous.role === \"word\" &&\n                i >= 2\n            ) {\n                const beforeWord = normalizedParts[i - 2];\n                if (\n                    beforeWord &&\n                    beforeWord.type === \"Text\" &&\n                    (beforeWord.value === \".\" || beforeWord.value === \"::\")\n                ) {\n                    // This is a method call - no space before (\n                    docs.push(printNode(part, options));\n                    previous = part;\n                    continue;\n                }\n            }\n\n            const separator = gapBetween(previous, part);\n            if (separator) {\n                docs.push(separator);\n            }\n        }\n\n        docs.push(printNode(part, options));\n        previous = part;\n    }\n\n    return docs.length === 0 ? \"\" : group(docs);\n}\n\nfunction gapBetween(\n    previous: ExpressionPartNode,\n    current: ExpressionPartNode\n): Doc | null {\n    const prevSymbol = getSymbol(previous);\n    const currentSymbol = getSymbol(current);\n\n    if (\n        current.type === \"ArrayLiteral\" &&\n        current.kind === \"explicit\" &&\n        Boolean(previous)\n    ) {\n        return null;\n    }\n\n    if (\n        current.type === \"Text\" &&\n        current.role === \"operator\" &&\n        (current.value === \"++\" || current.value === \"--\")\n    ) {\n        return null;\n    }\n\n    if (\n        previous.type === \"Text\" &&\n        previous.role === \"operator\" &&\n        current.type === \"Text\" &&\n        current.role === \"operator\"\n    ) {\n        const combined = previous.value + current.value;\n        if (CONCATENATED_OPERATOR_PAIRS.has(combined)) {\n            return null;\n        }\n    }\n\n    if (current.type === \"Parenthesis\") {\n        if (previous && previous.type === \"Text\") {\n            if (previous.value.toLowerCase() === \"param\") {\n                return null;\n            }\n            if (previous.role === \"keyword\") {\n                return \" \";\n            }\n            // Operators need space before parenthesis\n            if (previous.role === \"operator\") {\n                return \" \";\n            }\n            // Cmdlets and functions (words) need space before parenthesis\n            // Method calls are handled in printExpression\n            if (previous.role === \"word\") {\n                return \" \";\n            }\n            // PowerShell logical operators need space before parenthesis\n            const prevLower = previous.value.toLowerCase();\n            if (\n                prevLower.startsWith(\"-\") &&\n                (prevLower === \"-not\" ||\n                    prevLower === \"-and\" ||\n                    prevLower === \"-or\" ||\n                    prevLower === \"-xor\")\n            ) {\n                return \" \";\n            }\n            return null;\n        }\n        return \" \";\n    }\n\n    if (previous.type === \"Parenthesis\") {\n        if (currentSymbol && NO_SPACE_BEFORE.has(currentSymbol)) {\n            return null;\n        }\n        return \" \";\n    }\n\n    if (!prevSymbol && !currentSymbol) {\n        return \" \";\n    }\n\n    if (!prevSymbol) {\n        if (currentSymbol && NO_SPACE_BEFORE.has(currentSymbol)) {\n            return null;\n        }\n        return \" \";\n    }\n\n    if (NO_SPACE_AFTER.has(prevSymbol)) {\n        return null;\n    }\n\n    if (currentSymbol && NO_SPACE_BEFORE.has(currentSymbol)) {\n        return null;\n    }\n\n    if (\n        prevSymbol &&\n        currentSymbol &&\n        SYMBOL_NO_GAP.has(`${prevSymbol}:${currentSymbol}`)\n    ) {\n        return null;\n    }\n\n    if (prevSymbol && currentSymbol) {\n        const pair = `${prevSymbol}${currentSymbol}`;\n        if (CONCATENATED_OPERATOR_PAIRS.has(pair)) {\n            return null;\n        }\n    }\n\n    /* c8 ignore next */\n    if (prevSymbol === \"=\" || currentSymbol === \"=\") {\n        return \" \";\n    }\n\n    if (\n        current.type === \"ScriptBlock\" ||\n        current.type === \"Hashtable\" ||\n        current.type === \"ArrayLiteral\"\n    ) {\n        return \" \";\n    }\n\n    return \" \";\n}\n\nfunction isParamStatement(node: ScriptBodyNode | null): boolean {\n    if (!node || node.type !== \"Pipeline\") {\n        return false;\n    }\n    if (node.segments.length === 0) {\n        return false;\n    }\n    const firstSegment = node.segments[0];\n    if (firstSegment.parts.length === 0) {\n        return false;\n    }\n    const firstPart = firstSegment.parts.find((part) => part.type === \"Text\");\n    if (!firstPart || firstPart.type !== \"Text\") {\n        return false;\n    }\n    return firstPart.value.toLowerCase() === \"param\";\n}\n\nconst NO_SPACE_BEFORE = new Set([\n    \")\",\n    \"]\",\n    \"}\",\n    \",\",\n    \";\",\n    \".\",\n    \"::\",\n    \":\",\n    \">\",\n    \"<\",\n]);\nconst NO_SPACE_AFTER = new Set([\n    \"(\",\n    \"[\",\n    \"{\",\n    \".\",\n    \"::\",\n    \":\",\n    \"@\",\n    \">\",\n    \"<\",\n]);\nconst SYMBOL_NO_GAP = new Set([\n    \".:word\",\n    \"::word\",\n    \"word:(\",\n    \"word:[\",\n]);\nconst CONCATENATED_OPERATOR_PAIRS = new Set([\n    \"++\",\n    \"--\",\n    \"+=\",\n    \"-=\",\n    \"*=\",\n    \"/=\",\n    \"%=\",\n    \"&=\",\n    \"|=\",\n    \"^=\",\n    \"??\",\n]);\n\nfunction getSymbol(node: ExpressionPartNode | null): string | null {\n    if (!node) {\n        return null;\n    }\n    if (\n        node.type === \"Text\" &&\n        (node.role === \"punctuation\" || node.role === \"operator\")\n    ) {\n        return node.value;\n    }\n    // Handle special characters that may be role=\"unknown\"\n    if (node.type === \"Text\" && node.role === \"unknown\") {\n        const val = node.value.trim();\n        if (val === \"@\" || val === \"::\" || val === \":\") {\n            return val;\n        }\n    }\n    if (node.type === \"Parenthesis\") {\n        return \"(\";\n    }\n    return null;\n}\n\nfunction isParamKeyword(node: ExpressionPartNode | null): boolean {\n    return Boolean(\n        node && node.type === \"Text\" && node.value.toLowerCase() === \"param\"\n    );\n}\n\nconst KEYWORD_CASE_TRANSFORMS: Record<string, (value: string) => string> = {\n    preserve: (value) => value,\n    lower: (value) => value.toLowerCase(),\n    upper: (value) => value.toUpperCase(),\n    pascal: (value) =>\n        value.length === 0\n            ? value\n            : value[0].toUpperCase() + value.slice(1).toLowerCase(),\n};\n\nconst CMDLET_ALIAS_MAP: Record<string, string> = {\n    gi: \"Get-Item\",\n    gci: \"Get-ChildItem\",\n    ls: \"Get-ChildItem\",\n    dir: \"Get-ChildItem\",\n    ld: \"Get-ChildItem\",\n    la: \"Get-ChildItem\",\n    gcm: \"Get-Command\",\n    gm: \"Get-Member\",\n    gps: \"Get-Process\",\n    ps: \"Get-Process\",\n    gwmi: \"Get-WmiObject\",\n    gsv: \"Get-Service\",\n    cat: \"Get-Content\",\n    gc: \"Get-Content\",\n    echo: \"Write-Output\",\n    write: \"Write-Output\",\n    \"%\": \"ForEach-Object\",\n    foreach: \"ForEach-Object\",\n    \"?\": \"Where-Object\",\n    where: \"Where-Object\",\n};\n\nconst DISALLOWED_CMDLET_REWRITE = new Map([[\"write-host\", \"Write-Output\"]]);\n\nfunction printText(node: TextNode, options: ResolvedOptions): Doc {\n    if (node.role === \"string\") {\n        return normalizeStringLiteral(node.value, options);\n    }\n\n    let value = node.value;\n\n    if (node.role === \"keyword\") {\n        const transform =\n            KEYWORD_CASE_TRANSFORMS[options.keywordCase] ??\n            KEYWORD_CASE_TRANSFORMS.preserve;\n        value = transform(value);\n    }\n\n    if (\n        options.rewriteAliases &&\n        (node.role === \"word\" ||\n            node.role === \"operator\" ||\n            node.role === \"unknown\")\n    ) {\n        const aliasKey = value.toLowerCase();\n        if (Object.prototype.hasOwnProperty.call(CMDLET_ALIAS_MAP, aliasKey)) {\n            value = CMDLET_ALIAS_MAP[aliasKey]!;\n        }\n    }\n\n    if (node.role === \"word\" && options.rewriteWriteHost) {\n        const replacement = DISALLOWED_CMDLET_REWRITE.get(value.toLowerCase());\n        if (replacement) {\n            value = replacement;\n        }\n    }\n\n    return value;\n}\n\nfunction printComment(node: CommentNode): Doc {\n    if (node.style === \"block\") {\n        return node.value;\n    }\n    return [\"#\", node.value];\n}\n\nfunction printArray(node: ArrayLiteralNode, options: ResolvedOptions): Doc {\n    const open = node.kind === \"implicit\" ? \"@(\" : \"[\";\n    const close = node.kind === \"implicit\" ? \")\" : \"]\";\n    if (node.elements.length === 0) {\n        return [open, close];\n    }\n    const groupId = Symbol(\"array\");\n    const elementDocs = node.elements.map((element) =>\n        printExpression(element, options)\n    );\n    const shouldBreak = elementDocs.length > 1;\n    const separator: Doc = [\",\", line];\n    // PowerShell does NOT support trailing commas in arrays, so never add them\n\n    return group(\n        [\n            open,\n            indent([\n                shouldBreak ? line : softline,\n                join(separator, elementDocs),\n            ]),\n            shouldBreak ? line : softline,\n            close,\n        ],\n        { id: groupId }\n    );\n}\n\nfunction printHashtable(node: HashtableNode, options: ResolvedOptions): Doc {\n    const entries = options.sortHashtableKeys\n        ? [...node.entries].sort((a, b) =>\n              a.key.localeCompare(b.key, undefined, { sensitivity: \"base\" })\n          )\n        : node.entries;\n\n    if (entries.length === 0) {\n        return \"@{}\";\n    }\n\n    const groupId = Symbol(\"hashtable\");\n\n    const entryDocs = entries.map((entry, index) => {\n        const entryDoc = printHashtableEntry(entry, options);\n        const isLast = index === entries.length - 1;\n        const separator = isLast\n            ? trailingCommaDoc(options, groupId, true, \";\")\n            : ifBreak(\"\", \";\", { groupId });\n        return [entryDoc, separator];\n    });\n\n    return group(\n        [\n            \"@{\",\n            indent([line, join(line, entryDocs)]),\n            line,\n            \"}\",\n        ],\n        {\n            id: groupId,\n        }\n    );\n}\n\nfunction printHashtableEntry(\n    node: HashtableEntryNode,\n    options: ResolvedOptions\n): Doc {\n    const keyDoc = printExpression(node.rawKey, options);\n    const valueDoc = printExpression(node.value, options);\n    return group([\n        keyDoc,\n        \" =\",\n        indent([line, valueDoc]),\n    ]);\n}\n\nfunction printHereString(node: HereStringNode): Doc {\n    return dedentToRoot(node.value);\n}\n\nfunction printParamParenthesis(\n    node: ParenthesisNode,\n    options: ResolvedOptions\n): Doc {\n    if (node.elements.length === 0) {\n        return \"()\";\n    }\n\n    if (node.elements.length <= 1 && !node.hasNewline) {\n        return printParenthesis(node, options);\n    }\n\n    const groupId = Symbol(\"param\");\n    const elementDocs: Doc[] = [];\n    let pendingAttributes: Doc[] = [];\n\n    const flushAttributes = (nextDoc?: Doc) => {\n        if (pendingAttributes.length === 0) {\n            if (nextDoc) {\n                elementDocs.push(nextDoc);\n            }\n            return;\n        }\n\n        const attributeDoc =\n            pendingAttributes.length === 1\n                ? pendingAttributes[0]\n                : join(hardline, pendingAttributes);\n\n        if (nextDoc) {\n            elementDocs.push(\n                group([\n                    attributeDoc,\n                    hardline,\n                    nextDoc,\n                ])\n            );\n        } else {\n            elementDocs.push(attributeDoc);\n        }\n        pendingAttributes = [];\n    };\n\n    for (let i = 0; i < node.elements.length; i += 1) {\n        const element = node.elements[i];\n\n        // Skip comment-only expressions - they'll be handled as trailing comments\n        if (isCommentExpression(element)) {\n            continue;\n        }\n\n        if (isAttributeExpression(element)) {\n            pendingAttributes.push(printExpression(element, options));\n            continue;\n        }\n\n        let printed = printExpression(element, options);\n\n        // Check if the next element is a comment - if so, attach it inline\n        const nextElement = node.elements[i + 1];\n        if (nextElement && isCommentExpression(nextElement)) {\n            const commentText = extractCommentText(nextElement);\n            if (commentText) {\n                printed = [printed, lineSuffix([\" \", commentText])];\n                i += 1; // Skip the comment element since we've consumed it\n            }\n        }\n\n        flushAttributes(printed);\n    }\n\n    flushAttributes();\n    const separator: Doc = [\",\", hardline];\n\n    return group(\n        [\n            \"(\",\n            indent([hardline, join(separator, elementDocs)]),\n            hardline,\n            \")\",\n        ],\n        {\n            id: groupId,\n        }\n    );\n}\n\nfunction isAttributeExpression(node: ExpressionNode): boolean {\n    if (node.parts.length === 0) {\n        return false;\n    }\n\n    return node.parts.every((part) => {\n        if (part.type !== \"Text\") {\n            return false;\n        }\n        const trimmed = part.value.trim();\n        return trimmed.startsWith(\"[\") && trimmed.endsWith(\"]\");\n    });\n}\n\nfunction isCommentExpression(node: ExpressionNode): boolean {\n    if (node.parts.length !== 1) {\n        return false;\n    }\n\n    const part = node.parts[0];\n    if (part.type !== \"Text\") {\n        return false;\n    }\n\n    // Check if it's likely a comment based on context:\n    // 1. Starts with # or <# (original inline comment)\n    // 2. Appears to be comment text (no $ or [ at start, longer text)\n    const trimmed = part.value.trim();\n    if (trimmed.startsWith(\"#\") || trimmed.startsWith(\"<#\")) {\n        return true;\n    }\n\n    // If the text doesn't start with typical PowerShell syntax markers\n    // and appears to be prose, it's likely comment text\n    if (\n        !trimmed.startsWith(\"$\") &&\n        !trimmed.startsWith(\"[\") &&\n        !trimmed.startsWith(\"(\") &&\n        !trimmed.startsWith(\"{\") &&\n        !trimmed.includes(\"=\") &&\n        trimmed.length > 10\n    ) {\n        return true;\n    }\n\n    return false;\n}\n\nfunction extractCommentText(node: ExpressionNode): string | null {\n    if (!isCommentExpression(node)) {\n        return null;\n    }\n\n    const part = node.parts[0];\n    if (part.type !== \"Text\") {\n        return null;\n    }\n\n    const trimmed = part.value.trim();\n    // If it already starts with #, return as is\n    if (trimmed.startsWith(\"#\")) {\n        return trimmed;\n    }\n    // Otherwise, prepend # to make it a comment\n    return `# ${trimmed}`;\n}\n\nfunction printParenthesis(\n    node: ParenthesisNode,\n    options: ResolvedOptions\n): Doc {\n    if (node.elements.length === 0) {\n        return \"()\";\n    }\n    const groupId = Symbol(\"parenthesis\");\n    const elementDocs = node.elements.map((element) =>\n        printExpression(element, options)\n    );\n    if (elementDocs.length === 1 && !node.hasNewline) {\n        return group(\n            [\n                \"(\",\n                indent([softline, elementDocs[0]]),\n                softline,\n                \")\",\n            ],\n            {\n                id: groupId,\n            }\n        );\n    }\n\n    const hasComma = node.hasComma;\n    const forceMultiline =\n        node.hasNewline || (!node.hasComma && elementDocs.length > 1);\n    const separator: Doc = hasComma\n        ? [\",\", forceMultiline ? hardline : line]\n        : hardline;\n    const leadingLine = hasComma\n        ? forceMultiline\n            ? hardline\n            : line\n        : hardline;\n    const trailingLine = hasComma\n        ? forceMultiline\n            ? hardline\n            : line\n        : hardline;\n\n    return group(\n        [\n            \"(\",\n            indent([leadingLine, join(separator, elementDocs)]),\n            trailingLine,\n            \")\",\n        ],\n        {\n            id: groupId,\n        }\n    );\n}\n\nfunction trailingCommaDoc(\n    options: ResolvedOptions,\n    groupId: symbol,\n    hasElements: boolean,\n    delimiter: \",\" | \";\"\n): Doc {\n    if (!hasElements) {\n        return \"\";\n    }\n    switch (options.trailingComma) {\n        case \"all\":\n            return delimiter;\n        case \"multiline\":\n            return ifBreak(delimiter, \"\", { groupId });\n        case \"none\":\n        default:\n            return \"\";\n    }\n}\n\nexport function createPrinter(): Printer<ScriptNode> {\n    return powerShellPrinter;\n}\n\nexport const __printerTestUtils: {\n    gapBetween: typeof gapBetween;\n    getSymbol: typeof getSymbol;\n    shouldSkipPart: typeof shouldSkipPart;\n    normalizeStringLiteral: typeof normalizeStringLiteral;\n    printParamParenthesis: typeof printParamParenthesis;\n    printPipeline: typeof printPipeline;\n    trailingCommaDoc: typeof trailingCommaDoc;\n    isParamStatement: typeof isParamStatement;\n    printNode: typeof printNode;\n    printScript: typeof printScript;\n    concatDocs: typeof concatDocs;\n    indentStatement: typeof indentStatement;\n    printStatementList: typeof printStatementList;\n} = {\n    gapBetween,\n    getSymbol,\n    shouldSkipPart,\n    normalizeStringLiteral,\n    printParamParenthesis,\n    printPipeline,\n    trailingCommaDoc,\n    isParamStatement,\n    printNode,\n    printScript,\n    concatDocs,\n    indentStatement,\n    printStatementList,\n};\n\nfunction normalizeStringLiteral(\n    value: string,\n    options: ResolvedOptions\n): string {\n    if (!options.preferSingleQuote) {\n        return value;\n    }\n\n    if (!value.startsWith('\"') || !value.endsWith('\"')) {\n        return value;\n    }\n\n    const inner = value.slice(1, -1);\n\n    // Skip normalization for regex-like pattern strings to avoid altering embedded quoting\n    // Heuristics: starts with (? or contains unescaped character classes or anchors typical of patterns.\n    if (\n        /^\\(\\?[imxsU]/.test(inner) ||\n        /\\[[^\\]]+\\]/.test(inner) ||\n        /\\bWrite-(Warning|Error|Host|Output)\\b/.test(inner)\n    ) {\n        return value;\n    }\n\n    if (inner.includes(\"'\")) {\n        return value;\n    }\n\n    if (/[`$\"\\n]/.test(inner)) {\n        return value;\n    }\n\n    return `'${inner}'`;\n}\n\nfunction shouldSkipPart(part: ExpressionPartNode): boolean {\n    if (part.type === \"Text\") {\n        const trimmed = part.value.trim();\n        if (trimmed === \"`\") {\n            return true;\n        }\n    }\n    return false;\n}\n","import type { Plugin, SupportLanguage } from \"prettier\";\n\nimport { pluginOptions, defaultOptions } from \"./options.js\";\nimport { parsePowerShell, locEnd, locStart } from \"./parser.js\";\nimport { powerShellPrinter } from \"./printer.js\";\n\nconst languages: SupportLanguage[] = [\n    {\n        name: \"PowerShell\",\n        parsers: [\"powershell\"],\n        extensions: [\n            \".ps1\",\n            \".psm1\",\n            \".psd1\",\n        ],\n        tmScope: \"source.powershell\",\n        aceMode: \"powershell\",\n        linguistLanguageId: 131,\n        vscodeLanguageIds: [\"powershell\"],\n    },\n] as const;\n\nconst parsers: Plugin[\"parsers\"] = {\n    powershell: {\n        parse: parsePowerShell,\n        astFormat: \"powershell-ast\",\n        locStart,\n        locEnd,\n        hasPragma() {\n            return false;\n        },\n    },\n} as const;\n\nconst printers: Plugin[\"printers\"] = {\n    \"powershell-ast\": powerShellPrinter,\n};\n\nconst plugin: Plugin = {\n    languages,\n    parsers,\n    printers,\n    options: pluginOptions,\n    defaultOptions,\n};\n\nexport default plugin;\n"]}