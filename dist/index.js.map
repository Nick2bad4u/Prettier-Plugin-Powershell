{"version":3,"sources":["../src/options.ts","../src/tokenizer.ts","../src/parser.ts","../src/printer.ts","../src/index.ts"],"names":["currentSegment","segments"],"mappings":"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","file":"index.js","sourcesContent":["import type { ParserOptions, SupportOptions } from \"prettier\";\n\nexport type TrailingCommaOption = \"none\" | \"multiline\" | \"all\";\nexport type IndentStyleOption = \"spaces\" | \"tabs\";\nexport type BraceStyleOption = \"1tbs\" | \"allman\";\nexport type KeywordCaseOption = \"preserve\" | \"lower\" | \"upper\" | \"pascal\";\n\nexport interface PluginConfiguration {\n    powershellIndentStyle: IndentStyleOption;\n    powershellIndentSize: number;\n    powershellTrailingComma: TrailingCommaOption;\n    powershellSortHashtableKeys: boolean;\n    powershellBlankLinesBetweenFunctions: number;\n    powershellBlankLineAfterParam: boolean;\n    powershellBraceStyle: BraceStyleOption;\n    powershellLineWidth: number;\n    powershellPreferSingleQuote: boolean;\n    powershellKeywordCase: KeywordCaseOption;\n    powershellRewriteAliases: boolean;\n    powershellRewriteWriteHost: boolean;\n}\n\nexport const pluginOptions: SupportOptions = {\n    powershellIndentStyle: {\n        category: \"PowerShell\",\n        type: \"choice\",\n        default: \"spaces\",\n        description: \"Indent PowerShell code using spaces or tabs.\",\n        choices: [\n            { value: \"spaces\", description: \"Use spaces for indentation.\" },\n            { value: \"tabs\", description: \"Use tabs for indentation.\" },\n        ],\n    },\n    powershellIndentSize: {\n        category: \"PowerShell\",\n        type: \"int\",\n        default: 2,\n        description: \"Number of indentation characters for each level.\",\n        range: { start: 1, end: 8, step: 1 },\n    },\n    powershellTrailingComma: {\n        category: \"PowerShell\",\n        type: \"choice\",\n        default: \"multiline\",\n        description:\n            \"Control trailing commas for array and hashtable literals.\",\n        choices: [\n            {\n                value: \"none\",\n                description: \"Never add a trailing comma or semicolon.\",\n            },\n            {\n                value: \"multiline\",\n                description:\n                    \"Add trailing comma/semicolon when the literal spans multiple lines.\",\n            },\n            {\n                value: \"all\",\n                description:\n                    \"Always add trailing comma/semicolon when possible.\",\n            },\n        ],\n    },\n    powershellSortHashtableKeys: {\n        category: \"PowerShell\",\n        type: \"boolean\",\n        default: false,\n        description: \"Sort hashtable keys alphabetically when formatting.\",\n    },\n    powershellBlankLinesBetweenFunctions: {\n        category: \"PowerShell\",\n        type: \"int\",\n        default: 1,\n        description:\n            \"Number of blank lines to ensure between function declarations.\",\n        range: { start: 0, end: 3, step: 1 },\n    },\n    powershellBlankLineAfterParam: {\n        category: \"PowerShell\",\n        type: \"boolean\",\n        default: true,\n        description:\n            \"Insert a blank line after param(...) blocks inside script blocks.\",\n    },\n    powershellBraceStyle: {\n        category: \"PowerShell\",\n        type: \"choice\",\n        default: \"1tbs\",\n        description:\n            \"Control placement of opening braces for script blocks and functions.\",\n        choices: [\n            {\n                value: \"1tbs\",\n                description:\n                    \"One True Brace Style  keep opening braces on the same line.\",\n            },\n            {\n                value: \"allman\",\n                description:\n                    \"Allman style  place opening braces on the next line.\",\n            },\n        ],\n    },\n    powershellLineWidth: {\n        category: \"PowerShell\",\n        type: \"int\",\n        default: 120,\n        description: \"Maximum preferred line width for PowerShell documents.\",\n        range: { start: 40, end: 200, step: 1 },\n    },\n    powershellPreferSingleQuote: {\n        category: \"PowerShell\",\n        type: \"boolean\",\n        default: false,\n        description:\n            \"Prefer single-quoted strings when no interpolation is required.\",\n    },\n    powershellKeywordCase: {\n        category: \"PowerShell\",\n        type: \"choice\",\n        default: \"preserve\",\n        description: \"Normalise the casing of PowerShell keywords.\",\n        choices: [\n            {\n                value: \"preserve\",\n                description: \"Leave keyword casing unchanged.\",\n            },\n            { value: \"lower\", description: \"Convert keywords to lower-case.\" },\n            { value: \"upper\", description: \"Convert keywords to upper-case.\" },\n            {\n                value: \"pascal\",\n                description: \"Capitalise keywords (PascalCase).\",\n            },\n        ],\n    },\n    powershellRewriteAliases: {\n        category: \"PowerShell\",\n        type: \"boolean\",\n        default: false,\n        description: \"Rewrite common cmdlet aliases to their canonical names.\",\n    },\n    powershellRewriteWriteHost: {\n        category: \"PowerShell\",\n        type: \"boolean\",\n        default: false,\n        description:\n            \"Rewrite Write-Host invocations to Write-Output to discourage host-only output.\",\n    },\n};\n\nexport const defaultOptions = {\n    tabWidth: 2,\n};\n\nexport interface ResolvedOptions {\n    indentStyle: IndentStyleOption;\n    indentSize: number;\n    trailingComma: TrailingCommaOption;\n    sortHashtableKeys: boolean;\n    blankLinesBetweenFunctions: number;\n    blankLineAfterParam: boolean;\n    braceStyle: BraceStyleOption;\n    lineWidth: number;\n    preferSingleQuote: boolean;\n    keywordCase: KeywordCaseOption;\n    rewriteAliases: boolean;\n    rewriteWriteHost: boolean;\n}\n\n/**\n * Resolves PowerShell-specific options and normalizes Prettier options.\n *\n * Note: This function mutates the input `options` object by setting `useTabs`,\n * `tabWidth`, and `printWidth` to ensure consistency between\n * PowerShell-specific settings and Prettier's core settings.\n */\nexport function resolveOptions(options: ParserOptions): ResolvedOptions {\n    const indentStyle =\n        (options.powershellIndentStyle as IndentStyleOption | undefined) ??\n        \"spaces\";\n    const rawIndentOverride = options.powershellIndentSize;\n    const normalizedIndentOverride = Number(rawIndentOverride);\n    const normalizedTabWidth = Number(options.tabWidth);\n    const indentSize =\n        Number.isFinite(normalizedIndentOverride) &&\n        normalizedIndentOverride > 0\n            ? Math.floor(normalizedIndentOverride)\n            : Number.isFinite(normalizedTabWidth) && normalizedTabWidth > 0\n              ? Math.floor(normalizedTabWidth)\n              : 2;\n\n    if (indentStyle === \"tabs\") {\n        options.useTabs = true;\n    } else {\n        options.useTabs = false;\n    }\n    options.tabWidth = indentSize;\n\n    const trailingComma =\n        (options.powershellTrailingComma as TrailingCommaOption | undefined) ??\n        \"multiline\";\n    const sortHashtableKeys = Boolean(options.powershellSortHashtableKeys);\n    const rawBlankLines = Number(\n        options.powershellBlankLinesBetweenFunctions ?? 1\n    );\n    const normalizedBlankLines = Number.isFinite(rawBlankLines)\n        ? rawBlankLines\n        : 1;\n    const blankLinesBetweenFunctions = Math.max(\n        0,\n        Math.min(3, Math.floor(normalizedBlankLines))\n    );\n    let blankLineAfterParam = true;\n    /* c8 ignore next */\n    if (options.powershellBlankLineAfterParam === false) {\n        blankLineAfterParam = false;\n    }\n    const braceStyle =\n        (options.powershellBraceStyle as BraceStyleOption | undefined) ??\n        \"1tbs\";\n    const lineWidth = Math.max(\n        40,\n        Math.min(200, Number(options.powershellLineWidth ?? 120))\n    );\n    const preferSingleQuote = options.powershellPreferSingleQuote === true;\n    const keywordCase =\n        (options.powershellKeywordCase as KeywordCaseOption | undefined) ??\n        \"preserve\";\n    const rewriteAliases = options.powershellRewriteAliases === true;\n    const rewriteWriteHost = options.powershellRewriteWriteHost === true;\n\n    if (!options.printWidth || options.printWidth > lineWidth) {\n        options.printWidth = lineWidth;\n    }\n\n    return {\n        indentStyle,\n        indentSize,\n        trailingComma,\n        sortHashtableKeys,\n        blankLinesBetweenFunctions,\n        blankLineAfterParam,\n        braceStyle,\n        lineWidth,\n        preferSingleQuote,\n        keywordCase,\n        rewriteAliases,\n        rewriteWriteHost,\n    } satisfies ResolvedOptions;\n}\n","import type { HereStringNode } from \"./ast.js\";\r\n\r\nexport type TokenType =\r\n    | \"newline\"\r\n    | \"identifier\"\r\n    | \"keyword\"\r\n    | \"variable\"\r\n    | \"number\"\r\n    | \"string\"\r\n    | \"heredoc\"\r\n    | \"comment\"\r\n    | \"block-comment\"\r\n    | \"attribute\"\r\n    | \"punctuation\"\r\n    | \"operator\"\r\n    | \"unknown\";\r\n\r\nexport interface Token {\r\n    type: TokenType;\r\n    value: string;\r\n    start: number;\r\n    end: number;\r\n    quote?: \"single\" | \"double\";\r\n}\r\n\r\nconst KEYWORDS = new Set([\r\n    \"function\",\r\n    \"if\",\r\n    \"elseif\",\r\n    \"else\",\r\n    \"for\",\r\n    \"foreach\",\r\n    \"while\",\r\n    \"switch\",\r\n    \"try\",\r\n    \"catch\",\r\n    \"finally\",\r\n    \"param\",\r\n    \"class\",\r\n    \"enum\",\r\n    \"begin\",\r\n    \"process\",\r\n    \"end\",\r\n    \"dynamicparam\",\r\n    \"filter\",\r\n    \"workflow\",\r\n    \"configuration\",\r\n    \"inlinescript\",\r\n    \"parallel\",\r\n    \"sequence\",\r\n    \"break\",\r\n    \"continue\",\r\n    \"return\",\r\n    \"throw\",\r\n    \"exit\",\r\n    \"trap\",\r\n    \"data\",\r\n    \"do\",\r\n    \"until\",\r\n    \"default\",\r\n]);\r\n\r\n// PowerShell operators (case-insensitive)\r\nconst POWERSHELL_OPERATORS = new Set([\r\n    // Comparison operators\r\n    \"-eq\",\r\n    \"-ne\",\r\n    \"-gt\",\r\n    \"-ge\",\r\n    \"-lt\",\r\n    \"-le\",\r\n    \"-like\",\r\n    \"-notlike\",\r\n    \"-match\",\r\n    \"-notmatch\",\r\n    \"-contains\",\r\n    \"-notcontains\",\r\n    \"-in\",\r\n    \"-notin\",\r\n    \"-is\",\r\n    \"-isnot\",\r\n    // Case-sensitive variants\r\n    \"-ceq\",\r\n    \"-cne\",\r\n    \"-cgt\",\r\n    \"-cge\",\r\n    \"-clt\",\r\n    \"-cle\",\r\n    \"-clike\",\r\n    \"-cnotlike\",\r\n    \"-cmatch\",\r\n    \"-cnotmatch\",\r\n    \"-ccontains\",\r\n    \"-cnotcontains\",\r\n    \"-cin\",\r\n    \"-cnotin\",\r\n    // Case-insensitive explicit variants\r\n    \"-ieq\",\r\n    \"-ine\",\r\n    \"-igt\",\r\n    \"-ige\",\r\n    \"-ilt\",\r\n    \"-ile\",\r\n    \"-ilike\",\r\n    \"-inotlike\",\r\n    \"-imatch\",\r\n    \"-inotmatch\",\r\n    \"-icontains\",\r\n    \"-inotcontains\",\r\n    \"-iin\",\r\n    \"-inotin\",\r\n    // Logical operators\r\n    \"-and\",\r\n    \"-or\",\r\n    \"-xor\",\r\n    \"-not\",\r\n    // Bitwise operators\r\n    \"-band\",\r\n    \"-bor\",\r\n    \"-bxor\",\r\n    \"-bnot\",\r\n    \"-shl\",\r\n    \"-shr\",\r\n    // String operators\r\n    \"-split\",\r\n    \"-join\",\r\n    \"-replace\",\r\n    \"-f\",\r\n    // Type operators\r\n    \"-as\",\r\n    // Other operators\r\n    \"-creplace\",\r\n    \"-ireplace\",\r\n    \"-csplit\",\r\n    \"-isplit\",\r\n]);\r\n\r\nconst PUNCTUATION = new Set([\r\n    \"{\",\r\n    \"}\",\r\n    \"(\",\r\n    \")\",\r\n    \"[\",\r\n    \"]\",\r\n    \",\",\r\n    \";\",\r\n    \".\",\r\n    \":\",\r\n]);\r\n\r\n// Cached regex patterns for performance\r\n// These are defined at module level to avoid recreation in the tokenize loop\r\nconst WHITESPACE_PATTERN = /[\\s\\u00A0\\u200B\\u2060\\uFEFF]/;\r\nconst IDENTIFIER_START_PATTERN = /[A-Za-z_]/;\r\nconst UNICODE_VAR_CHAR_PATTERN = /^[\\p{L}\\p{N}_:\\-]$/u;\r\nconst HEX_DIGIT_PATTERN = /[0-9A-Fa-f]/;\r\nconst BINARY_DIGIT_PATTERN = /[01]/;\r\nconst DECIMAL_DIGIT_PATTERN = /[0-9]/;\r\nconst NUMBER_SUFFIX_PATTERN = /[dDfFlLuU]/;\r\nconst UNICODE_IDENTIFIER_START_PATTERN = /[\\p{L}_]/u;\r\nconst UNICODE_IDENTIFIER_CHAR_PATTERN = /[\\p{L}\\p{N}_-]/u;\r\nconst UNICODE_IDENTIFIER_AFTER_DASH_PATTERN = /[-\\p{L}]/u;\r\n\r\n/**\r\n * Tokenizes PowerShell source code into an array of tokens.\r\n *\r\n * This is the first stage of parsing. It breaks the source into meaningful\r\n * chunks:\r\n *\r\n * - Keywords (if, function, class, etc.)\r\n * - Operators (-eq, -and, &&, ||, etc.)\r\n * - Variables ($var, $$, $global:name, etc.)\r\n * - Numbers (42, 0xFF, 1.5e10, 100MB, etc.)\r\n * - Strings (single, double, here-strings)\r\n * - Comments (# line, <# block #>)\r\n * - Punctuation ({, }, [, ], etc.)\r\n *\r\n * The tokenizer is designed to be resilient - it will tokenize even malformed\r\n * PowerShell to allow the formatter to work on incomplete code.\r\n *\r\n * @param source - The PowerShell source code to tokenize\r\n *\r\n * @returns An array of tokens with type, value, and position information\r\n */\r\nexport function tokenize(source: string): Token[] {\r\n    const tokens: Token[] = [];\r\n    const length = source.length;\r\n    let index = 0;\r\n\r\n    const push = (token: Token) => {\r\n        tokens.push(token);\r\n    };\r\n\r\n    const readCodePoint = (\r\n        position: number\r\n    ): { codePoint: number; text: string; width: number } | null => {\r\n        const codePoint = source.codePointAt(position);\r\n        if (codePoint === undefined) {\r\n            return null;\r\n        }\r\n        const text = String.fromCodePoint(codePoint);\r\n        return {\r\n            codePoint,\r\n            text,\r\n            width: text.length,\r\n        };\r\n    };\r\n\r\n    const isWhitespaceCharacter = (ch: string): boolean => {\r\n        switch (ch) {\r\n            case \" \":\r\n            case \"\\t\":\r\n            case \"\\f\":\r\n            case \"\\v\":\r\n            case \"\\u00A0\":\r\n            case \"\\u200B\":\r\n            case \"\\u2060\":\r\n            case \"\\uFEFF\":\r\n                return true;\r\n            default:\r\n                return false;\r\n        }\r\n    };\r\n\r\n    while (index < length) {\r\n        const char = source[index];\r\n        const start = index;\r\n\r\n        if (char === \"\\r\" || char === \"\\n\") {\r\n            if (char === \"\\r\" && source[index + 1] === \"\\n\") {\r\n                index += 2;\r\n                push({ type: \"newline\", value: \"\\r\\n\", start, end: index });\r\n            } else {\r\n                index += 1;\r\n                push({ type: \"newline\", value: \"\\n\", start, end: index });\r\n            }\r\n            continue;\r\n        }\r\n\r\n        if (isWhitespaceCharacter(char)) {\r\n            index += 1;\r\n            continue;\r\n        }\r\n\r\n        if (char === \"<\" && index + 1 < length && source[index + 1] === \"#\") {\r\n            let scanIndex = index + 2;\r\n            while (scanIndex < length) {\r\n                if (\r\n                    scanIndex + 1 < length &&\r\n                    source[scanIndex] === \"#\" &&\r\n                    source[scanIndex + 1] === \">\"\r\n                ) {\r\n                    scanIndex += 2;\r\n                    break;\r\n                }\r\n                scanIndex += 1;\r\n            }\r\n            const end = scanIndex >= length ? length : scanIndex;\r\n            push({\r\n                type: \"block-comment\",\r\n                value: source.slice(start, end),\r\n                start,\r\n                end,\r\n            });\r\n            index = end;\r\n            continue;\r\n        }\r\n\r\n        if (char === \"#\") {\r\n            index += 1;\r\n            while (\r\n                index < length &&\r\n                source[index] !== \"\\r\" &&\r\n                source[index] !== \"\\n\"\r\n            ) {\r\n                index += 1;\r\n            }\r\n            push({\r\n                type: \"comment\",\r\n                value: source.slice(start + 1, index).trimEnd(),\r\n                start,\r\n                end: index,\r\n            });\r\n            continue;\r\n        }\r\n\r\n        if (char === \"[\") {\r\n            let lookahead = index + 1;\r\n            while (\r\n                lookahead < length &&\r\n                WHITESPACE_PATTERN.test(source[lookahead])\r\n            ) {\r\n                lookahead += 1;\r\n            }\r\n            if (\r\n                lookahead < length &&\r\n                IDENTIFIER_START_PATTERN.test(source[lookahead])\r\n            ) {\r\n                let depth = 1;\r\n                let scanIndex = index + 1;\r\n                while (scanIndex < length && depth > 0) {\r\n                    const current = source[scanIndex];\r\n                    if (current === \"'\" || current === '\"') {\r\n                        const quote = current;\r\n                        scanIndex += 1;\r\n                        while (scanIndex < length) {\r\n                            const currentChar = source[scanIndex];\r\n                            if (currentChar === \"`\") {\r\n                                // Only advance by 2 if there is a character after the backtick\r\n                                if (scanIndex + 1 < length) {\r\n                                    scanIndex += 2;\r\n                                } else {\r\n                                    // Backtick is the last character, advance by 1 and exit loop\r\n                                    scanIndex += 1;\r\n                                    break;\r\n                                }\r\n                                continue;\r\n                            }\r\n                            if (currentChar === quote) {\r\n                                scanIndex += 1;\r\n                                break;\r\n                            }\r\n                            scanIndex += 1;\r\n                        }\r\n                        continue;\r\n                    }\r\n                    if (current === \"[\") {\r\n                        depth += 1;\r\n                        scanIndex += 1;\r\n                        continue;\r\n                    }\r\n                    if (current === \"]\") {\r\n                        depth -= 1;\r\n                        scanIndex += 1;\r\n                        if (depth === 0) {\r\n                            break;\r\n                        }\r\n                        continue;\r\n                    }\r\n                    scanIndex += 1;\r\n                }\r\n                const attributeEnd = depth === 0 ? scanIndex : length;\r\n                push({\r\n                    type: \"attribute\",\r\n                    value: source.slice(start, attributeEnd),\r\n                    start,\r\n                    end: attributeEnd,\r\n                });\r\n                index = attributeEnd;\r\n                continue;\r\n            }\r\n        }\r\n\r\n        if (\r\n            char === \"@\" &&\r\n            (source[index + 1] === '\"' || source[index + 1] === \"'\")\r\n        ) {\r\n            const quoteChar = source[index + 1];\r\n            const quote = quoteChar === '\"' ? \"double\" : \"single\";\r\n            let scanIndex = index + 2;\r\n            let closing = -1;\r\n            while (scanIndex < length) {\r\n                if (\r\n                    scanIndex + 1 < length &&\r\n                    source[scanIndex] === quoteChar &&\r\n                    source[scanIndex + 1] === \"@\"\r\n                ) {\r\n                    const prevChar = source[scanIndex - 1];\r\n                    const prevPrev = source[scanIndex - 2];\r\n                    const atImmediateClosing = scanIndex === index + 2;\r\n                    const atUnixLineStart = prevChar === \"\\n\";\r\n                    const atWindowsLineStart =\r\n                        prevChar === \"\\n\" && prevPrev === \"\\r\";\r\n                    if (\r\n                        atImmediateClosing ||\r\n                        atUnixLineStart ||\r\n                        atWindowsLineStart\r\n                    ) {\r\n                        closing = scanIndex;\r\n                        break;\r\n                    }\r\n                }\r\n                scanIndex += 1;\r\n            }\r\n\r\n            let end = length;\r\n            /* c8 ignore next */\r\n            if (closing !== -1) {\r\n                end = closing + 2;\r\n            }\r\n\r\n            push({\r\n                type: \"heredoc\",\r\n                value: source.slice(index, end),\r\n                start,\r\n                end,\r\n                quote,\r\n            });\r\n            index = end;\r\n            continue;\r\n        }\r\n\r\n        if (char === \"'\" || char === '\"') {\r\n            const quote = char === '\"' ? \"double\" : \"single\";\r\n            index += 1;\r\n            let escaped = false;\r\n            while (index < length) {\r\n                const current = source[index];\r\n                if (escaped) {\r\n                    escaped = false;\r\n                } else if (current === \"`\") {\r\n                    escaped = true;\r\n                } else if (current === char) {\r\n                    index += 1;\r\n                    break;\r\n                }\r\n                index += 1;\r\n            }\r\n            push({\r\n                type: \"string\",\r\n                value: source.slice(start, index),\r\n                start,\r\n                end: index,\r\n                quote,\r\n            });\r\n            continue;\r\n        }\r\n\r\n        if (\r\n            char === \"@\" &&\r\n            (source[index + 1] === \"{\" || source[index + 1] === \"(\")\r\n        ) {\r\n            const value = `@${source[index + 1]}`;\r\n            index += 2;\r\n            push({ type: \"operator\", value, start, end: index });\r\n            continue;\r\n        }\r\n\r\n        if (\r\n            char === \"@\" &&\r\n            index + 1 < length &&\r\n            (UNICODE_IDENTIFIER_START_PATTERN.test(source[index + 1]) ||\r\n                source[index + 1] === \"_\")\r\n        ) {\r\n            let scanIndex = index + 2;\r\n            while (scanIndex < length) {\r\n                const peek = readCodePoint(scanIndex);\r\n                if (!peek) {\r\n                    break;\r\n                }\r\n                if (!UNICODE_IDENTIFIER_CHAR_PATTERN.test(peek.text)) {\r\n                    break;\r\n                }\r\n                scanIndex += peek.width;\r\n            }\r\n            push({\r\n                type: \"identifier\",\r\n                value: source.slice(start, scanIndex),\r\n                start,\r\n                end: scanIndex,\r\n            });\r\n            index = scanIndex;\r\n            continue;\r\n        }\r\n\r\n        if (char === \":\" && source[index + 1] === \":\") {\r\n            index += 2;\r\n            push({ type: \"operator\", value: \"::\", start, end: index });\r\n            continue;\r\n        }\r\n\r\n        if (PUNCTUATION.has(char)) {\r\n            index += 1;\r\n            push({ type: \"punctuation\", value: char, start, end: index });\r\n            continue;\r\n        }\r\n\r\n        if (char === \"|\" || char === \"=\") {\r\n            let value = char;\r\n            if (source[index + 1] === char) {\r\n                value += char;\r\n                index += 2;\r\n            } else {\r\n                index += 1;\r\n            }\r\n            push({ type: \"operator\", value, start, end: index });\r\n            continue;\r\n        }\r\n\r\n        // Pipeline chain operators: && and ||\r\n        if (char === \"&\" && source[index + 1] === \"&\") {\r\n            index += 2;\r\n            push({ type: \"operator\", value: \"&&\", start, end: index });\r\n            continue;\r\n        }\r\n\r\n        // Redirection operators: >, >>, <, 2>, 2>>, 3>, etc.\r\n        if (char === \">\" || char === \"<\") {\r\n            let value = char;\r\n            if (source[index + 1] === char) {\r\n                value += char;\r\n                index += 2;\r\n            } else {\r\n                index += 1;\r\n            }\r\n            if (\r\n                source[index] === \"&\" &&\r\n                /[1-6]/.test(source[index + 1] ?? \"\")\r\n            ) {\r\n                value += \"&\" + source[index + 1];\r\n                index += 2;\r\n            }\r\n            push({ type: \"operator\", value, start, end: index });\r\n            continue;\r\n        }\r\n\r\n        // Stream redirection operators: 2>, 3>, 4>, 5>, 6>, *>\r\n        if (/[2-6*]/.test(char) && source[index + 1] === \">\") {\r\n            let value = char + \">\";\r\n            index += 2;\r\n            // Check for >> (append)\r\n            if (source[index] === \">\") {\r\n                value += \">\";\r\n                index += 1;\r\n            }\r\n            // Check for merging redirection: 2>&1, *>&2, etc.\r\n            if (source[index] === \"&\" && /[1-6]/.test(source[index + 1])) {\r\n                value += \"&\" + source[index + 1];\r\n                index += 2;\r\n            }\r\n            push({ type: \"operator\", value, start, end: index });\r\n            continue;\r\n        }\r\n\r\n        if (char === \"&\") {\r\n            index += 1;\r\n            push({ type: \"operator\", value: \"&\", start, end: index });\r\n            continue;\r\n        }\r\n\r\n        // Merging redirection for stream 1: 1>&2\r\n        if (\r\n            char === \"1\" &&\r\n            source[index + 1] === \">\" &&\r\n            source[index + 2] === \"&\" &&\r\n            /[2-6]/.test(source[index + 3])\r\n        ) {\r\n            const value = \"1>&\" + source[index + 3];\r\n            index += 4;\r\n            push({ type: \"operator\", value, start, end: index });\r\n            continue;\r\n        }\r\n\r\n        if (char === \"$\") {\r\n            index += 1;\r\n\r\n            // Special variables: $$, $^, $?, $_\r\n            if (index < length) {\r\n                const nextChar = source[index];\r\n                if (\r\n                    nextChar === \"$\" ||\r\n                    nextChar === \"^\" ||\r\n                    nextChar === \"?\" ||\r\n                    nextChar === \"_\"\r\n                ) {\r\n                    index += 1;\r\n                    push({\r\n                        type: \"variable\",\r\n                        value: source.slice(start, index),\r\n                        start,\r\n                        end: index,\r\n                    });\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            while (index < length) {\r\n                const peek = readCodePoint(index);\r\n                if (!peek) {\r\n                    break;\r\n                }\r\n                const currentChar = peek.text;\r\n                // PowerShell supports Unicode variable names\r\n                // Match Unicode letters, numbers, underscore, colon, and hyphen\r\n                if (UNICODE_VAR_CHAR_PATTERN.test(currentChar)) {\r\n                    index += peek.width;\r\n                    continue;\r\n                }\r\n                if (currentChar === \"{\") {\r\n                    index += 1;\r\n                    while (index < length && source[index] !== \"}\") {\r\n                        index += 1;\r\n                    }\r\n                    if (source[index] === \"}\") {\r\n                        index += 1;\r\n                    }\r\n                    continue;\r\n                }\r\n                break;\r\n            }\r\n            push({\r\n                type: \"variable\",\r\n                value: source.slice(start, index),\r\n                start,\r\n                end: index,\r\n            });\r\n            continue;\r\n        }\r\n\r\n        if (/[0-9]/.test(char)) {\r\n            index += 1;\r\n\r\n            // Check for hex number (0x...)\r\n            if (\r\n                char === \"0\" &&\r\n                index < length &&\r\n                (source[index] === \"x\" || source[index] === \"X\")\r\n            ) {\r\n                index += 1; // consume 'x' or 'X'\r\n                while (\r\n                    index < length &&\r\n                    HEX_DIGIT_PATTERN.test(source[index])\r\n                ) {\r\n                    index += 1;\r\n                }\r\n                // Check for unsigned/long suffixes (U/u/L/l)\r\n                if (\r\n                    index < length &&\r\n                    (source[index] === \"L\" ||\r\n                        source[index] === \"l\" ||\r\n                        source[index] === \"U\" ||\r\n                        source[index] === \"u\")\r\n                ) {\r\n                    index += 1;\r\n                }\r\n                // Check for multiplier suffixes (KB, MB, GB, TB, PB)\r\n                if (index + 1 < length) {\r\n                    const suffix = source.slice(index, index + 2).toUpperCase();\r\n                    if (\r\n                        [\r\n                            \"KB\",\r\n                            \"MB\",\r\n                            \"GB\",\r\n                            \"TB\",\r\n                            \"PB\",\r\n                        ].includes(suffix)\r\n                    ) {\r\n                        index += 2;\r\n                    }\r\n                }\r\n                push({\r\n                    type: \"number\",\r\n                    value: source.slice(start, index),\r\n                    start,\r\n                    end: index,\r\n                });\r\n                continue;\r\n            }\r\n\r\n            // Check for binary number (0b...)\r\n            if (\r\n                char === \"0\" &&\r\n                index < length &&\r\n                (source[index] === \"b\" || source[index] === \"B\")\r\n            ) {\r\n                index += 1; // consume 'b' or 'B'\r\n                while (\r\n                    index < length &&\r\n                    BINARY_DIGIT_PATTERN.test(source[index])\r\n                ) {\r\n                    index += 1;\r\n                }\r\n                if (\r\n                    index < length &&\r\n                    (source[index] === \"U\" ||\r\n                        source[index] === \"u\" ||\r\n                        source[index] === \"L\" ||\r\n                        source[index] === \"l\")\r\n                ) {\r\n                    index += 1;\r\n                }\r\n                push({\r\n                    type: \"number\",\r\n                    value: source.slice(start, index),\r\n                    start,\r\n                    end: index,\r\n                });\r\n                continue;\r\n            }\r\n\r\n            // Regular decimal number\r\n            while (\r\n                index < length &&\r\n                DECIMAL_DIGIT_PATTERN.test(source[index])\r\n            ) {\r\n                index += 1;\r\n            }\r\n\r\n            // Check for decimal point\r\n            if (\r\n                index + 1 < length &&\r\n                source[index] === \".\" &&\r\n                DECIMAL_DIGIT_PATTERN.test(source[index + 1])\r\n            ) {\r\n                index += 2;\r\n                while (\r\n                    index < length &&\r\n                    DECIMAL_DIGIT_PATTERN.test(source[index])\r\n                ) {\r\n                    index += 1;\r\n                }\r\n            }\r\n\r\n            // Check for scientific notation (e or E)\r\n            if (\r\n                index < length &&\r\n                (source[index] === \"e\" || source[index] === \"E\")\r\n            ) {\r\n                index += 1;\r\n                // Optional sign\r\n                if (\r\n                    index < length &&\r\n                    (source[index] === \"+\" || source[index] === \"-\")\r\n                ) {\r\n                    index += 1;\r\n                }\r\n                // Exponent digits\r\n                while (\r\n                    index < length &&\r\n                    DECIMAL_DIGIT_PATTERN.test(source[index])\r\n                ) {\r\n                    index += 1;\r\n                }\r\n            }\r\n\r\n            // Check for type suffixes (d/D for decimal, f/F for float, l/L for long)\r\n            if (index < length && NUMBER_SUFFIX_PATTERN.test(source[index])) {\r\n                index += 1;\r\n            }\r\n\r\n            // Check for multiplier suffixes (KB, MB, GB, TB, PB)\r\n            if (index + 1 < length) {\r\n                const suffix = source.slice(index, index + 2).toUpperCase();\r\n                if (\r\n                    [\r\n                        \"KB\",\r\n                        \"MB\",\r\n                        \"GB\",\r\n                        \"TB\",\r\n                        \"PB\",\r\n                    ].includes(suffix)\r\n                ) {\r\n                    index += 2;\r\n                }\r\n            }\r\n\r\n            push({\r\n                type: \"number\",\r\n                value: source.slice(start, index),\r\n                start,\r\n                end: index,\r\n            });\r\n            continue;\r\n        }\r\n\r\n        // Stop parsing token: --%\r\n        if (char === \"-\" && source.slice(index, index + 3) === \"--%\") {\r\n            // Consume everything until end of line as the stop parsing argument\r\n            let endIndex = index + 3;\r\n            while (\r\n                endIndex < length &&\r\n                source[endIndex] !== \"\\n\" &&\r\n                source[endIndex] !== \"\\r\"\r\n            ) {\r\n                endIndex += 1;\r\n            }\r\n            push({\r\n                type: \"operator\",\r\n                value: source.slice(start, endIndex),\r\n                start,\r\n                end: endIndex,\r\n            });\r\n            index = endIndex;\r\n            continue;\r\n        }\r\n\r\n        const startCodePoint = readCodePoint(index);\r\n        if (\r\n            startCodePoint &&\r\n            UNICODE_IDENTIFIER_START_PATTERN.test(startCodePoint.text)\r\n        ) {\r\n            index += startCodePoint.width;\r\n            while (index < length) {\r\n                const peek = readCodePoint(index);\r\n                if (!peek || !UNICODE_IDENTIFIER_CHAR_PATTERN.test(peek.text)) {\r\n                    break;\r\n                }\r\n                index += peek.width;\r\n            }\r\n            const raw = source.slice(start, index);\r\n            const lower = raw.toLowerCase();\r\n            if (KEYWORDS.has(lower)) {\r\n                push({ type: \"keyword\", value: raw, start, end: index });\r\n            } else if (POWERSHELL_OPERATORS.has(lower)) {\r\n                push({ type: \"operator\", value: raw, start, end: index });\r\n            } else {\r\n                push({ type: \"identifier\", value: raw, start, end: index });\r\n            }\r\n            continue;\r\n        }\r\n\r\n        if (startCodePoint && startCodePoint.text === \"-\") {\r\n            const afterDash = readCodePoint(index + startCodePoint.width);\r\n            if (\r\n                afterDash &&\r\n                UNICODE_IDENTIFIER_AFTER_DASH_PATTERN.test(afterDash.text)\r\n            ) {\r\n                index += startCodePoint.width;\r\n                while (index < length) {\r\n                    const peek = readCodePoint(index);\r\n                    if (\r\n                        !peek ||\r\n                        !UNICODE_IDENTIFIER_CHAR_PATTERN.test(peek.text)\r\n                    ) {\r\n                        break;\r\n                    }\r\n                    index += peek.width;\r\n                }\r\n                const raw = source.slice(start, index);\r\n                const lower = raw.toLowerCase();\r\n                if (KEYWORDS.has(lower)) {\r\n                    push({ type: \"keyword\", value: raw, start, end: index });\r\n                } else if (POWERSHELL_OPERATORS.has(lower)) {\r\n                    push({ type: \"operator\", value: raw, start, end: index });\r\n                } else {\r\n                    push({ type: \"identifier\", value: raw, start, end: index });\r\n                }\r\n                continue;\r\n            }\r\n        }\r\n\r\n        // fallback single character token\r\n        index += 1;\r\n        push({ type: \"unknown\", value: char, start, end: index });\r\n    }\r\n\r\n    return tokens;\r\n}\r\n\r\n/**\r\n * Normalizes a here-string by removing the opening and closing delimiters.\r\n *\r\n * PowerShell here-strings have the format:\r\n *\r\n * @param node - The here-string AST node\r\n *\r\n * @returns The normalized content without delimiters\r\n *\r\n * @\"\r\n * content\r\n * \"@\r\n *\r\n * or\r\n *\r\n * @'\r\n * content\r\n * '@\r\n *\r\n * This function extracts just the content between the delimiters.\r\n * If the here-string is too short (malformed), returns it as-is.\r\n */\r\nexport function normalizeHereString(node: HereStringNode): string {\r\n    const lines = node.value.split(/\\r?\\n/);\r\n    if (lines.length <= 2) {\r\n        return node.value;\r\n    }\r\n    return lines.slice(1, -1).join(\"\\n\");\r\n}\r\n","import type { ParserOptions } from \"prettier\";\r\n\r\nimport type {\r\n    ArrayLiteralNode,\r\n    BlankLineNode,\r\n    CommentNode,\r\n    ExpressionNode,\r\n    ExpressionPartNode,\r\n    FunctionDeclarationNode,\r\n    HashtableEntryNode,\r\n    HashtableNode,\r\n    HereStringNode,\r\n    ParenthesisNode,\r\n    PipelineNode,\r\n    ScriptBlockNode,\r\n    ScriptBodyNode,\r\n    ScriptNode,\r\n    SourceLocation,\r\n    TextNode,\r\n    TokenRole,\r\n} from \"./ast.js\";\r\nimport { resolveOptions } from \"./options.js\";\r\nimport type { Token } from \"./tokenizer.js\";\r\nimport { tokenize } from \"./tokenizer.js\";\r\n\r\nconst FALLBACK_OPERATOR_TOKENS = new Set([\r\n    \"+\",\r\n    \"-\",\r\n    \"*\",\r\n    \"/\",\r\n    \"%\",\r\n    \"&\",\r\n    \"|\",\r\n    \"^\",\r\n    \"!\",\r\n    \"?\",\r\n    \"++\",\r\n    \"--\",\r\n    \"+=\",\r\n    \"-=\",\r\n    \"*=\",\r\n    \"/=\",\r\n    \"%=\",\r\n    \"&=\",\r\n    \"|=\",\r\n    \"^=\",\r\n    \"??\",\r\n]);\r\n\r\nfunction extendNodeLocation(node: { loc: SourceLocation }, end: number): void {\r\n    if (end > node.loc.end) {\r\n        node.loc = { ...node.loc, end };\r\n    }\r\n}\r\n\r\nclass Parser {\r\n    private tokenIndex = 0;\r\n\r\n    constructor(\r\n        private readonly tokens: Token[],\r\n        private readonly source: string\r\n    ) {}\r\n\r\n    parseScript(terminators: Set<string> = new Set()): ScriptNode {\r\n        const body: ScriptBodyNode[] = [];\r\n        const start = this.tokens.length > 0 ? this.tokens[0].start : 0;\r\n\r\n        const appendNode = (node: ScriptBodyNode | null | undefined) => {\r\n            if (!node) {\r\n                return;\r\n            }\r\n\r\n            const last = body[body.length - 1];\r\n            if (last && shouldMergeNodes(last, node)) {\r\n                mergeNodes(last, node);\r\n            } else {\r\n                body.push(node);\r\n            }\r\n        };\r\n\r\n        while (!this.isEOF()) {\r\n            const token = this.peek()!;\r\n\r\n            if (terminators.has(token.value) && token.type === \"punctuation\") {\r\n                break;\r\n            }\r\n\r\n            if (this.classifyStatementTerminator(token, 0) === \"semicolon\") {\r\n                this.advance();\r\n                const nextToken = this.peek();\r\n                if (\r\n                    nextToken &&\r\n                    nextToken.type === \"comment\" &&\r\n                    this.isInlineComment(nextToken)\r\n                ) {\r\n                    const commentNode = this.createCommentNode(\r\n                        this.advance(),\r\n                        true\r\n                    );\r\n                    appendNode(commentNode);\r\n                }\r\n                continue;\r\n            }\r\n\r\n            if (token.type === \"newline\") {\r\n                const blank = this.consumeBlankLines();\r\n                appendNode(blank);\r\n                continue;\r\n            }\r\n\r\n            if (token.type === \"comment\" || token.type === \"block-comment\") {\r\n                const commentToken = this.advance();\r\n                const commentNode = this.createCommentNode(commentToken, false);\r\n                if (body.length > 0) {\r\n                    const previousNode = body[body.length - 1];\r\n                    let lookaheadOffset = 0;\r\n                    let nextToken: Token | undefined;\r\n                    while (\r\n                        (nextToken = this.peek(lookaheadOffset)) !== undefined\r\n                    ) {\r\n                        if (nextToken.type === \"newline\") {\r\n                            lookaheadOffset += 1;\r\n                            continue;\r\n                        }\r\n                        break;\r\n                    }\r\n                    if (previousNode.type === \"Pipeline\") {\r\n                        const lastSegment =\r\n                            previousNode.segments[\r\n                                previousNode.segments.length - 1\r\n                            ];\r\n                        const lastPart =\r\n                            lastSegment?.parts[lastSegment.parts.length - 1];\r\n                        const belongsToBlock = Boolean(\r\n                            lastPart &&\r\n                                lastPart.type === \"ScriptBlock\" &&\r\n                                (commentNode.loc.start < lastPart.loc.end ||\r\n                                    (nextToken &&\r\n                                        nextToken.type === \"punctuation\" &&\r\n                                        nextToken.value === \"}\"))\r\n                        );\r\n                        if (\r\n                            belongsToBlock &&\r\n                            lastPart &&\r\n                            lastPart.type === \"ScriptBlock\" &&\r\n                            lastSegment\r\n                        ) {\r\n                            lastPart.body.push(commentNode);\r\n                            extendNodeLocation(lastPart, commentNode.loc.end);\r\n                            extendNodeLocation(\r\n                                lastSegment,\r\n                                commentNode.loc.end\r\n                            );\r\n                            extendNodeLocation(\r\n                                previousNode,\r\n                                commentNode.loc.end\r\n                            );\r\n                            continue;\r\n                        }\r\n                    }\r\n                }\r\n                appendNode(commentNode);\r\n                continue;\r\n            }\r\n\r\n            if (this.isFunctionDeclaration()) {\r\n                appendNode(this.parseFunction());\r\n                continue;\r\n            }\r\n\r\n            const statement = this.parseStatement();\r\n            if (statement) {\r\n                appendNode(statement);\r\n            } else {\r\n                // avoid infinite loops\r\n                this.advance();\r\n            }\r\n        }\r\n\r\n        const end = body.length > 0 ? body[body.length - 1].loc.end : start;\r\n        return {\r\n            type: \"Script\",\r\n            body,\r\n            loc: { start, end },\r\n        } satisfies ScriptNode;\r\n    }\r\n\r\n    private parseFunction(): FunctionDeclarationNode {\r\n        const startToken = this.advance(); // function keyword\r\n        const headerTokens: Token[] = [startToken];\r\n\r\n        while (!this.isEOF()) {\r\n            const token = this.peek()!;\r\n            if (token.type === \"comment\") {\r\n                break;\r\n            }\r\n            if (token.type === \"punctuation\" && token.value === \"{\") {\r\n                break;\r\n            }\r\n            headerTokens.push(this.advance());\r\n        }\r\n\r\n        const headerExpression = buildExpressionFromTokens(\r\n            headerTokens,\r\n            this.source\r\n        );\r\n        const body = this.parseScriptBlock();\r\n        const end = body.loc.end;\r\n\r\n        return {\r\n            type: \"FunctionDeclaration\",\r\n            header: headerExpression,\r\n            body,\r\n            loc: { start: startToken.start, end },\r\n        } satisfies FunctionDeclarationNode;\r\n    }\r\n\r\n    private parseStatement(): PipelineNode | null {\r\n        const segments: Token[][] = [[]];\r\n        let trailingComment: CommentNode | undefined;\r\n\r\n        const structureStack: string[] = [];\r\n        let lineContinuation = false;\r\n\r\n        while (!this.isEOF()) {\r\n            const token = this.peek()!;\r\n            const terminatorType = this.classifyStatementTerminator(\r\n                token,\r\n                structureStack.length\r\n            );\r\n\r\n            if (terminatorType === \"newline\") {\r\n                if (lineContinuation) {\r\n                    this.advance();\r\n                    lineContinuation = false;\r\n                    continue;\r\n                }\r\n                /* c8 ignore next */\r\n                if (structureStack.length > 0) {\r\n                    const newlineToken = this.advance();\r\n                    segments[segments.length - 1].push(newlineToken);\r\n                    continue;\r\n                }\r\n                if (\r\n                    structureStack.length === 0 &&\r\n                    this.isPipelineContinuationAfterNewline()\r\n                ) {\r\n                    this.advance();\r\n                    continue;\r\n                }\r\n                break;\r\n            }\r\n\r\n            if (terminatorType === \"semicolon\") {\r\n                break;\r\n            }\r\n\r\n            if (\r\n                terminatorType === \"closing-brace\" ||\r\n                terminatorType === \"closing-paren\"\r\n            ) {\r\n                break;\r\n            }\r\n\r\n            if (token.type === \"comment\") {\r\n                if (\r\n                    structureStack.length === 0 &&\r\n                    this.isInlineComment(token)\r\n                ) {\r\n                    trailingComment = this.createCommentNode(\r\n                        this.advance(),\r\n                        true\r\n                    );\r\n                }\r\n                if (structureStack.length === 0) {\r\n                    break;\r\n                }\r\n                // Inside a structure - include the comment as part of the statement\r\n                const currentSegment = segments[segments.length - 1];\r\n                currentSegment.push(this.advance());\r\n                continue;\r\n            }\r\n\r\n            if (token.type === \"block-comment\") {\r\n                if (structureStack.length === 0) {\r\n                    break;\r\n                }\r\n                // Inside a structure - include the block comment\r\n                const currentSegment = segments[segments.length - 1];\r\n                currentSegment.push(this.advance());\r\n                continue;\r\n            }\r\n\r\n            if (token.type === \"operator\" && token.value === \"|\") {\r\n                if (structureStack.length > 0) {\r\n                    const currentSegment = segments[segments.length - 1];\r\n                    currentSegment.push(this.advance());\r\n                    lineContinuation = false;\r\n                    continue;\r\n                }\r\n\r\n                this.advance();\r\n                segments.push([]);\r\n                lineContinuation = false;\r\n                continue;\r\n            }\r\n\r\n            /* c8 ignore next */\r\n            if (token.type === \"unknown\" && token.value === \"`\") {\r\n                this.advance();\r\n                lineContinuation = true;\r\n                continue;\r\n            }\r\n\r\n            const currentSegment = segments[segments.length - 1];\r\n            currentSegment.push(this.advance());\r\n            lineContinuation = false;\r\n\r\n            if (isOpeningToken(token)) {\r\n                structureStack.push(token.value);\r\n            } else if (isClosingToken(token)) {\r\n                structureStack.pop();\r\n            }\r\n        }\r\n\r\n        const filteredSegments = segments.filter(\r\n            (segment) => segment.length > 0\r\n        );\r\n        if (filteredSegments.length === 0) {\r\n            return null;\r\n        }\r\n\r\n        const expressionSegments = filteredSegments.map((segmentTokens) =>\r\n            buildExpressionFromTokens(segmentTokens, this.source)\r\n        );\r\n        const start = expressionSegments[0].loc.start;\r\n        const end = expressionSegments[expressionSegments.length - 1].loc.end;\r\n\r\n        const pipelineNode: PipelineNode = {\r\n            type: \"Pipeline\",\r\n            segments: expressionSegments,\r\n            loc: { start, end },\r\n        };\r\n\r\n        if (trailingComment) {\r\n            pipelineNode.trailingComment = trailingComment;\r\n        }\r\n\r\n        return pipelineNode;\r\n    }\r\n\r\n    private classifyStatementTerminator(\r\n        token: Token | undefined,\r\n        structureDepth: number\r\n    ): \"newline\" | \"semicolon\" | \"closing-brace\" | \"closing-paren\" | null {\r\n        if (!token) {\r\n            return null;\r\n        }\r\n        if (token.type === \"newline\") {\r\n            return structureDepth === 0 ? \"newline\" : null;\r\n        }\r\n        if (structureDepth === 0 && token.type === \"punctuation\") {\r\n            if (token.value === \";\") {\r\n                return \"semicolon\";\r\n            }\r\n            if (token.value === \"}\") {\r\n                return \"closing-brace\";\r\n            }\r\n            if (token.value === \")\") {\r\n                return \"closing-paren\";\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    private parseScriptBlock(): ScriptBlockNode {\r\n        const openToken = this.peek();\r\n        if (\r\n            !openToken ||\r\n            openToken.type !== \"punctuation\" ||\r\n            openToken.value !== \"{\"\r\n        ) {\r\n            return {\r\n                type: \"ScriptBlock\",\r\n                body: [],\r\n                loc: { start: openToken?.start ?? 0, end: openToken?.end ?? 0 },\r\n            } satisfies ScriptBlockNode;\r\n        }\r\n        this.advance();\r\n\r\n        const { contentTokens, closingToken } =\r\n            this.collectBalancedTokens(openToken);\r\n        const nestedParser = new Parser(contentTokens, this.source);\r\n        const script = nestedParser.parseScript(new Set());\r\n        const closingEnd = closingToken?.end ?? openToken.end;\r\n        const bodyEnd =\r\n            script.body.length > 0\r\n                ? script.body[script.body.length - 1].loc.end\r\n                : closingEnd;\r\n        const end = Math.max(closingEnd, bodyEnd);\r\n\r\n        return {\r\n            type: \"ScriptBlock\",\r\n            body: script.body,\r\n            loc: { start: openToken.start, end },\r\n        } satisfies ScriptBlockNode;\r\n    }\r\n\r\n    private collectBalancedTokens(startToken: Token): {\r\n        contentTokens: Token[];\r\n        closingToken?: Token;\r\n    } {\r\n        const contentTokens: Token[] = [];\r\n        const stack: string[] = [startToken.value];\r\n\r\n        while (!this.isEOF()) {\r\n            const token = this.advance();\r\n\r\n            if (isOpeningToken(token)) {\r\n                stack.push(token.value);\r\n                contentTokens.push(token);\r\n                continue;\r\n            }\r\n\r\n            if (isClosingToken(token)) {\r\n                if (stack.length <= 1) {\r\n                    return { contentTokens, closingToken: token };\r\n                }\r\n                stack.pop();\r\n                contentTokens.push(token);\r\n                continue;\r\n            }\r\n\r\n            contentTokens.push(token);\r\n        }\r\n\r\n        return { contentTokens };\r\n    }\r\n\r\n    private consumeBlankLines(): BlankLineNode {\r\n        let count = 0;\r\n        const start = this.peek()!.start;\r\n        let end = start;\r\n        while (!this.isEOF()) {\r\n            const token = this.peek();\r\n            if (!token || token.type !== \"newline\") {\r\n                break;\r\n            }\r\n            const current = this.advance();\r\n            count += 1;\r\n            end = current.end;\r\n        }\r\n        return {\r\n            type: \"BlankLine\",\r\n            count,\r\n            loc: { start, end },\r\n        } satisfies BlankLineNode;\r\n    }\r\n\r\n    private createCommentNode(token: Token, inline: boolean): CommentNode {\r\n        const style = token.type === \"block-comment\" ? \"block\" : \"line\";\r\n        const isInline =\r\n            style === \"line\" && inline && this.isInlineComment(token);\r\n\r\n        return {\r\n            type: \"Comment\",\r\n            value: token.value,\r\n            inline: isInline,\r\n            style,\r\n            loc: { start: token.start, end: token.end },\r\n        } satisfies CommentNode;\r\n    }\r\n\r\n    private isInlineComment(token: Token): boolean {\r\n        if (token.type !== \"comment\") {\r\n            return false;\r\n        }\r\n        // Empty source means no context, treat as not inline\r\n        if (this.source.length === 0) {\r\n            return false;\r\n        }\r\n        // Comment at position 0 is at the beginning, not inline\r\n        if (token.start === 0) {\r\n            return false;\r\n        }\r\n\r\n        let cursor = token.start - 1;\r\n        while (cursor >= 0) {\r\n            const char = this.source[cursor];\r\n            if (char === \"\\n\") {\r\n                return false;\r\n            }\r\n            if (char === \"\\r\") {\r\n                return false;\r\n            }\r\n            if (!/\\s/.test(char)) {\r\n                return true;\r\n            }\r\n            cursor -= 1;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Checks if there's a pipeline continuation (|) after newlines. This\r\n     * handles multi-line pipelines where the pipe operator appears on a\r\n     * subsequent line.\r\n     */\r\n    private isPipelineContinuationAfterNewline(): boolean {\r\n        let offset = 1;\r\n        let next: Token | undefined;\r\n        while ((next = this.peek(offset)) !== undefined) {\r\n            if (next.type === \"newline\") {\r\n                offset += 1;\r\n                continue;\r\n            }\r\n            if (next.type === \"comment\") {\r\n                return false;\r\n            }\r\n            if (next.type === \"operator\" && next.value === \"|\") {\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    private isFunctionDeclaration(): boolean {\r\n        const token = this.peek();\r\n        return Boolean(\r\n            token &&\r\n                token.type === \"keyword\" &&\r\n                token.value.toLowerCase() === \"function\"\r\n        );\r\n    }\r\n\r\n    private peek(offset = 0): Token | undefined {\r\n        return this.tokens[this.tokenIndex + offset];\r\n    }\r\n\r\n    private advance(): Token {\r\n        const token = this.tokens[this.tokenIndex];\r\n        this.tokenIndex += 1;\r\n        return token;\r\n    }\r\n\r\n    private isEOF(): boolean {\r\n        return this.tokenIndex >= this.tokens.length;\r\n    }\r\n}\r\n\r\nfunction isOpeningToken(token: Token): boolean {\r\n    if (token.type === \"operator\") {\r\n        return token.value === \"@{\" || token.value === \"@(\";\r\n    }\r\n    return (\r\n        token.type === \"punctuation\" &&\r\n        (token.value === \"{\" || token.value === \"(\" || token.value === \"[\")\r\n    );\r\n}\r\n\r\nfunction isClosingToken(token: Token): boolean {\r\n    return (\r\n        token.type === \"punctuation\" &&\r\n        (token.value === \"}\" || token.value === \")\" || token.value === \"]\")\r\n    );\r\n}\r\n\r\nfunction shouldMergeNodes(\r\n    previous: ScriptBodyNode,\r\n    next: ScriptBodyNode\r\n): boolean {\r\n    if (previous.type === \"Pipeline\" && next.type === \"Comment\") {\r\n        return Boolean(next.inline);\r\n    }\r\n\r\n    if (previous.type === \"BlankLine\" && next.type === \"BlankLine\") {\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nfunction mergeNodes(previous: ScriptBodyNode, next: ScriptBodyNode): void {\r\n    if (previous.type === \"Pipeline\" && next.type === \"Comment\") {\r\n        previous.trailingComment = next;\r\n        extendNodeLocation(previous, next.loc.end);\r\n        return;\r\n    }\r\n\r\n    if (previous.type === \"BlankLine\" && next.type === \"BlankLine\") {\r\n        previous.count += next.count;\r\n        extendNodeLocation(previous, next.loc.end);\r\n        return;\r\n    }\r\n}\r\n\r\nfunction buildExpressionFromTokens(\r\n    tokens: Token[],\r\n    source: string = \"\"\r\n): ExpressionNode {\r\n    const firstToken = tokens.find((token) => token.type !== \"newline\");\r\n    const lastToken = [...tokens]\r\n        .reverse()\r\n        .find((token) => token.type !== \"newline\");\r\n    if (!firstToken || !lastToken) {\r\n        return {\r\n            type: \"Expression\",\r\n            parts: [],\r\n            loc: {\r\n                start: tokens[0]?.start ?? 0,\r\n                end: tokens[tokens.length - 1]?.end ?? 0,\r\n            },\r\n        } satisfies ExpressionNode;\r\n    }\r\n\r\n    const parts: ExpressionPartNode[] = [];\r\n    let index = 0;\r\n\r\n    while (index < tokens.length) {\r\n        const token = tokens[index];\r\n\r\n        if (token.type === \"newline\") {\r\n            index += 1;\r\n            continue;\r\n        }\r\n\r\n        if (token.type === \"operator\" && token.value === \"@{\") {\r\n            const { node, nextIndex } = parseHashtablePart(\r\n                tokens,\r\n                index,\r\n                source\r\n            );\r\n            parts.push(node);\r\n            index = nextIndex;\r\n            continue;\r\n        }\r\n\r\n        if (\r\n            (token.type === \"operator\" && token.value === \"@(\") ||\r\n            (token.type === \"punctuation\" && token.value === \"[\")\r\n        ) {\r\n            const { node, nextIndex } = parseArrayPart(tokens, index, source);\r\n            parts.push(node);\r\n            index = nextIndex;\r\n            continue;\r\n        }\r\n\r\n        if (token.type === \"punctuation\" && token.value === \"{\") {\r\n            const { node, nextIndex } = parseScriptBlockPart(\r\n                tokens,\r\n                index,\r\n                source\r\n            );\r\n            parts.push(node);\r\n            index = nextIndex;\r\n            continue;\r\n        }\r\n\r\n        if (token.type === \"punctuation\" && token.value === \"(\") {\r\n            const { node, nextIndex } = parseParenthesisPart(\r\n                tokens,\r\n                index,\r\n                source\r\n            );\r\n            parts.push(node);\r\n            index = nextIndex;\r\n            continue;\r\n        }\r\n\r\n        if (token.type === \"heredoc\") {\r\n            parts.push(createHereStringNode(token));\r\n            index += 1;\r\n            continue;\r\n        }\r\n\r\n        if (token.type === \"attribute\") {\r\n            parts.push(createTextNode(token));\r\n            index += 1;\r\n            continue;\r\n        }\r\n\r\n        parts.push(createTextNode(token));\r\n        index += 1;\r\n    }\r\n\r\n    const expressionEnd =\r\n        parts.length > 0 ? parts[parts.length - 1].loc.end : lastToken.end;\r\n\r\n    return {\r\n        type: \"Expression\",\r\n        parts,\r\n        loc: {\r\n            start: firstToken.start,\r\n            end: expressionEnd,\r\n        },\r\n    } satisfies ExpressionNode;\r\n}\r\n\r\nfunction parseHashtablePart(\r\n    tokens: Token[],\r\n    startIndex: number,\r\n    source: string = \"\"\r\n): { node: HashtableNode; nextIndex: number } {\r\n    const startToken = tokens[startIndex];\r\n    const { contentTokens, endIndex, closingToken } = collectStructureTokens(\r\n        tokens,\r\n        startIndex\r\n    );\r\n    const entries = splitHashtableEntries(contentTokens).map((entryTokens) =>\r\n        buildHashtableEntry(entryTokens, source)\r\n    );\r\n    const end =\r\n        closingToken?.end ??\r\n        contentTokens[contentTokens.length - 1]?.end ??\r\n        startToken.end;\r\n    return {\r\n        node: {\r\n            type: \"Hashtable\",\r\n            entries,\r\n            loc: { start: startToken.start, end },\r\n        },\r\n        nextIndex: endIndex,\r\n    };\r\n}\r\n\r\nfunction resolveStructureEnd(\r\n    startToken: Token,\r\n    closingToken: Token | undefined,\r\n    contentTokens: Token[]\r\n): number {\r\n    if (closingToken) {\r\n        return closingToken.end;\r\n    }\r\n    const lastContent =\r\n        contentTokens.length > 0\r\n            ? contentTokens[contentTokens.length - 1]\r\n            : undefined;\r\n    if (lastContent) {\r\n        return lastContent.end;\r\n    }\r\n    return startToken.end;\r\n}\r\n\r\nfunction parseArrayPart(\r\n    tokens: Token[],\r\n    startIndex: number,\r\n    source: string = \"\"\r\n): { node: ArrayLiteralNode; nextIndex: number } {\r\n    const startToken = tokens[startIndex];\r\n    const { contentTokens, endIndex, closingToken } = collectStructureTokens(\r\n        tokens,\r\n        startIndex\r\n    );\r\n    const elements = splitArrayElements(contentTokens).map((elementTokens) =>\r\n        buildExpressionFromTokens(elementTokens, source)\r\n    );\r\n    /* c8 ignore next */\r\n    const kind = startToken.value === \"@(\" ? \"implicit\" : \"explicit\";\r\n    const end = resolveStructureEnd(startToken, closingToken, contentTokens);\r\n    return {\r\n        node: {\r\n            type: \"ArrayLiteral\",\r\n            elements,\r\n            kind,\r\n            loc: { start: startToken.start, end },\r\n        },\r\n        nextIndex: endIndex,\r\n    } satisfies { node: ArrayLiteralNode; nextIndex: number };\r\n}\r\n\r\nfunction parseParenthesisPart(\r\n    tokens: Token[],\r\n    startIndex: number,\r\n    source: string = \"\"\r\n): { node: ParenthesisNode; nextIndex: number } {\r\n    const startToken = tokens[startIndex];\r\n    const { contentTokens, endIndex, closingToken } = collectStructureTokens(\r\n        tokens,\r\n        startIndex\r\n    );\r\n    const elements = splitArrayElements(contentTokens).map((elementTokens) =>\r\n        buildExpressionFromTokens(elementTokens, source)\r\n    );\r\n    const hasComma = hasTopLevelComma(contentTokens);\r\n    const hasNewline = contentTokens.some((token) => token.type === \"newline\");\r\n    const end = resolveStructureEnd(startToken, closingToken, contentTokens);\r\n    return {\r\n        node: {\r\n            type: \"Parenthesis\",\r\n            elements,\r\n            hasComma,\r\n            hasNewline,\r\n            loc: { start: startToken.start, end },\r\n        },\r\n        nextIndex: endIndex,\r\n    };\r\n}\r\n\r\nfunction parseScriptBlockPart(\r\n    tokens: Token[],\r\n    startIndex: number,\r\n    source: string = \"\"\r\n): { node: ScriptBlockNode; nextIndex: number } {\r\n    const startToken = tokens[startIndex];\r\n    const { contentTokens, endIndex, closingToken } = collectStructureTokens(\r\n        tokens,\r\n        startIndex\r\n    );\r\n    const nestedParser = new Parser(contentTokens, source);\r\n    const script = nestedParser.parseScript();\r\n    const closingEnd = resolveStructureEnd(\r\n        startToken,\r\n        closingToken,\r\n        contentTokens\r\n    );\r\n    const bodyEnd =\r\n        script.body.length > 0\r\n            ? script.body[script.body.length - 1].loc.end\r\n            : closingEnd;\r\n    const end = Math.max(closingEnd, bodyEnd);\r\n    return {\r\n        node: {\r\n            type: \"ScriptBlock\",\r\n            body: script.body,\r\n            loc: { start: startToken.start, end },\r\n        },\r\n        nextIndex: endIndex,\r\n    };\r\n}\r\n\r\nfunction createHereStringNode(token: Token): HereStringNode {\r\n    const quote = token.quote ?? \"double\";\r\n    return {\r\n        type: \"HereString\",\r\n        quote,\r\n        value: token.value,\r\n        loc: { start: token.start, end: token.end },\r\n    } satisfies HereStringNode;\r\n}\r\n\r\nfunction createTextNode(token: Token): TextNode {\r\n    const tokenTypeToRole: Record<string, TokenRole> = {\r\n        identifier: \"word\",\r\n        keyword: \"keyword\",\r\n        number: \"number\",\r\n        variable: \"variable\",\r\n        string: \"string\",\r\n        operator: \"operator\",\r\n        punctuation: \"punctuation\",\r\n    };\r\n    let role: TokenRole = tokenTypeToRole[token.type] ?? \"unknown\";\r\n\r\n    if (\r\n        (role === \"unknown\" || role === \"word\") &&\r\n        FALLBACK_OPERATOR_TOKENS.has(token.value)\r\n    ) {\r\n        role = \"operator\";\r\n    }\r\n\r\n    return {\r\n        type: \"Text\",\r\n        value: token.value,\r\n        role,\r\n        loc: { start: token.start, end: token.end },\r\n    } satisfies TextNode;\r\n}\r\n\r\nfunction collectStructureTokens(\r\n    tokens: Token[],\r\n    startIndex: number\r\n): { contentTokens: Token[]; endIndex: number; closingToken?: Token } {\r\n    const contentTokens: Token[] = [];\r\n    const stack: string[] = [tokens[startIndex].value];\r\n    let index = startIndex + 1;\r\n\r\n    while (index < tokens.length) {\r\n        const token = tokens[index];\r\n\r\n        if (isOpeningToken(token)) {\r\n            stack.push(token.value);\r\n            contentTokens.push(token);\r\n            index += 1;\r\n            continue;\r\n        }\r\n\r\n        if (isClosingToken(token)) {\r\n            if (stack.length === 1) {\r\n                return {\r\n                    contentTokens,\r\n                    endIndex: index + 1,\r\n                    closingToken: token,\r\n                };\r\n            }\r\n            stack.pop();\r\n            contentTokens.push(token);\r\n            index += 1;\r\n            continue;\r\n        }\r\n\r\n        contentTokens.push(token);\r\n        index += 1;\r\n    }\r\n\r\n    return { contentTokens, endIndex: tokens.length };\r\n}\r\n\r\nfunction parseStatementForTest(tokens: Token[]): PipelineNode | null {\r\n    const parser = new Parser(tokens, \"\");\r\n    const internal = parser as unknown as {\r\n        parseStatement(): PipelineNode | null;\r\n    };\r\n    return internal.parseStatement();\r\n}\r\n\r\ntype SplitDecision = \"skip\" | void;\r\n\r\ninterface SplitContext<TState> {\r\n    token: Token;\r\n    state: TState;\r\n    current: Token[];\r\n    stack: string[];\r\n    topLevel: boolean;\r\n}\r\n\r\ninterface SplitOptions<TState = Record<string, never>> {\r\n    delimiterValues?: string[];\r\n    splitOnNewline?: (context: SplitContext<TState>) => boolean;\r\n    shouldSplitOnDelimiter?: (context: SplitContext<TState>) => boolean;\r\n    onToken?: (context: SplitContext<TState>) => SplitDecision;\r\n    onBeforeAddToken?: (context: SplitContext<TState>) => void;\r\n    onAfterAddToken?: (context: SplitContext<TState>) => void;\r\n    onFlush?: (\r\n        segment: Token[],\r\n        state: TState,\r\n        segments: Token[][],\r\n        force: boolean\r\n    ) => Token[] | void;\r\n    createInitialState?: () => TState;\r\n}\r\n\r\nfunction splitTopLevelTokens<TState = Record<string, never>>(\r\n    tokens: Token[],\r\n    options: SplitOptions<TState> = {}\r\n): Token[][] {\r\n    const result: Token[][] = [];\r\n    let current: Token[] = [];\r\n    const stack: string[] = [];\r\n    const state = options.createInitialState\r\n        ? options.createInitialState()\r\n        : ({} as TState);\r\n\r\n    const flush = (force = false) => {\r\n        if (!force && current.length === 0) {\r\n            return;\r\n        }\r\n        const maybeSegment = options.onFlush?.(current, state, result, force);\r\n        const segment = maybeSegment ?? current;\r\n        if (segment.length > 0) {\r\n            result.push(segment);\r\n        }\r\n        current = [];\r\n    };\r\n\r\n    for (const token of tokens) {\r\n        const topLevel = stack.length === 0;\r\n        const context: SplitContext<TState> = {\r\n            token,\r\n            state,\r\n            current,\r\n            stack,\r\n            topLevel,\r\n        };\r\n\r\n        if (token.type === \"newline\" && topLevel) {\r\n            if (options.splitOnNewline?.(context)) {\r\n                flush();\r\n            }\r\n            continue;\r\n        }\r\n\r\n        if (\r\n            topLevel &&\r\n            token.type === \"punctuation\" &&\r\n            options.delimiterValues?.includes(token.value)\r\n        ) {\r\n            if (options.shouldSplitOnDelimiter?.(context) ?? true) {\r\n                flush();\r\n            }\r\n            continue;\r\n        }\r\n\r\n        const decision = options.onToken?.(context);\r\n        if (decision === \"skip\") {\r\n            continue;\r\n        }\r\n\r\n        options.onBeforeAddToken?.(context);\r\n\r\n        if (isOpeningToken(token)) {\r\n            stack.push(token.value);\r\n            current.push(token);\r\n        } else if (isClosingToken(token)) {\r\n            stack.pop();\r\n            current.push(token);\r\n        } else {\r\n            current.push(token);\r\n        }\r\n\r\n        options.onAfterAddToken?.({\r\n            token,\r\n            state,\r\n            current,\r\n            stack,\r\n            topLevel: stack.length === 0,\r\n        });\r\n    }\r\n\r\n    flush(true);\r\n\r\n    return result;\r\n}\r\n\r\nfunction splitHashtableEntries(tokens: Token[]): Token[][] {\r\n    type HashtableSplitState = {\r\n        hasEquals: boolean;\r\n        justSawEquals: boolean;\r\n        pendingComments: Token[];\r\n    };\r\n\r\n    const segments = splitTopLevelTokens<HashtableSplitState>(tokens, {\r\n        delimiterValues: [\";\"],\r\n        createInitialState: () => ({\r\n            hasEquals: false,\r\n            justSawEquals: false,\r\n            pendingComments: [],\r\n        }),\r\n        splitOnNewline: (context) => {\r\n            if (context.current.length === 0) {\r\n                return false;\r\n            }\r\n            if (!context.state.hasEquals || context.state.justSawEquals) {\r\n                return false;\r\n            }\r\n            if (context.state.pendingComments.length > 0) {\r\n                context.current.push(...context.state.pendingComments);\r\n                context.state.pendingComments = [];\r\n            }\r\n            return true;\r\n        },\r\n        shouldSplitOnDelimiter: (context) => {\r\n            if (context.current.length === 0) {\r\n                return false;\r\n            }\r\n            if (context.state.pendingComments.length > 0) {\r\n                context.current.push(...context.state.pendingComments);\r\n                context.state.pendingComments = [];\r\n            }\r\n            return true;\r\n        },\r\n        onToken: (context) => {\r\n            if (\r\n                context.token.type === \"comment\" ||\r\n                context.token.type === \"block-comment\"\r\n            ) {\r\n                context.state.pendingComments.push(context.token);\r\n                return \"skip\";\r\n            }\r\n        },\r\n        onBeforeAddToken: (context) => {\r\n            if (context.state.pendingComments.length > 0) {\r\n                context.current.push(...context.state.pendingComments);\r\n                context.state.pendingComments = [];\r\n            }\r\n        },\r\n        onAfterAddToken: (context) => {\r\n            const { token, state, topLevel } = context;\r\n            if (topLevel && token.type === \"operator\" && token.value === \"=\") {\r\n                state.hasEquals = true;\r\n                state.justSawEquals = true;\r\n                return;\r\n            }\r\n            if (\r\n                token.type !== \"newline\" &&\r\n                token.type !== \"comment\" &&\r\n                token.type !== \"block-comment\"\r\n            ) {\r\n                state.justSawEquals = false;\r\n            }\r\n        },\r\n        onFlush: (segment, state, segments, _force) => {\r\n            // Use the `_force` parameter to appease lint rules about unused vars\r\n            void _force;\r\n            if (state.pendingComments.length > 0) {\r\n                if (segment.length > 0) {\r\n                    segment.push(...state.pendingComments);\r\n                } else if (segments.length > 0) {\r\n                    segments[segments.length - 1].push(\r\n                        ...state.pendingComments\r\n                    );\r\n                }\r\n                state.pendingComments = [];\r\n            }\r\n            state.hasEquals = false;\r\n            state.justSawEquals = false;\r\n            return segment;\r\n        },\r\n    });\r\n\r\n    return segments;\r\n}\r\n\r\nfunction buildHashtableEntry(\r\n    tokens: Token[],\r\n    source: string = \"\"\r\n): HashtableEntryNode {\r\n    // Separate comments from other tokens\r\n    const leadingComments: Token[] = [];\r\n    const trailingComments: Token[] = [];\r\n    const otherTokens: Token[] = [];\r\n\r\n    let equalsIndex = -1;\r\n    let foundEquals = false;\r\n\r\n    for (let i = 0; i < tokens.length; i++) {\r\n        const token = tokens[i];\r\n\r\n        if (token.type === \"comment\" || token.type === \"block-comment\") {\r\n            // Comments before the = are leading, after are trailing\r\n            if (!foundEquals) {\r\n                leadingComments.push(token);\r\n            } else {\r\n                trailingComments.push(token);\r\n            }\r\n        } else {\r\n            if (\r\n                token.type === \"operator\" &&\r\n                token.value === \"=\" &&\r\n                !foundEquals\r\n            ) {\r\n                equalsIndex = otherTokens.length;\r\n                foundEquals = true;\r\n            }\r\n            otherTokens.push(token);\r\n        }\r\n    }\r\n\r\n    const keyTokens =\r\n        equalsIndex === -1 ? otherTokens : otherTokens.slice(0, equalsIndex);\r\n    const valueTokens =\r\n        equalsIndex === -1 ? [] : otherTokens.slice(equalsIndex + 1);\r\n    const keyExpression = buildExpressionFromTokens(keyTokens, source);\r\n    const valueExpression =\r\n        valueTokens.length > 0\r\n            ? buildExpressionFromTokens(valueTokens, source)\r\n            : buildExpressionFromTokens([], source);\r\n    const key = extractKeyText(keyTokens);\r\n\r\n    // Calculate start/end based on non-comment tokens like original logic\r\n    const start = keyTokens[0]?.start ?? valueTokens[0]?.start ?? 0;\r\n    const end =\r\n        (valueTokens[valueTokens.length - 1] ?? keyTokens[keyTokens.length - 1])\r\n            ?.end ?? start;\r\n\r\n    const entry: HashtableEntryNode = {\r\n        type: \"HashtableEntry\",\r\n        key,\r\n        rawKey: keyExpression,\r\n        value: valueExpression,\r\n        loc: { start, end },\r\n    };\r\n\r\n    // Add comments if present\r\n    if (leadingComments.length > 0) {\r\n        entry.leadingComments = leadingComments.map((token) => ({\r\n            type: \"Comment\" as const,\r\n            value: token.value,\r\n            inline: false,\r\n            style:\r\n                token.type === \"block-comment\"\r\n                    ? (\"block\" as const)\r\n                    : (\"line\" as const),\r\n            loc: { start: token.start, end: token.end },\r\n        }));\r\n    }\r\n\r\n    if (trailingComments.length > 0) {\r\n        const trailingNodes: CommentNode[] = [];\r\n        let referenceEnd =\r\n            valueTokens[valueTokens.length - 1]?.end ??\r\n            keyTokens[keyTokens.length - 1]?.end ??\r\n            tokens[0]?.start ??\r\n            0;\r\n\r\n        for (const token of trailingComments) {\r\n            const inline =\r\n                token.type === \"comment\" &&\r\n                isInlineSpacing(source, referenceEnd, token.start);\r\n\r\n            trailingNodes.push({\r\n                type: \"Comment\" as const,\r\n                value: token.value,\r\n                inline,\r\n                style:\r\n                    token.type === \"block-comment\"\r\n                        ? (\"block\" as const)\r\n                        : (\"line\" as const),\r\n                loc: { start: token.start, end: token.end },\r\n            });\r\n\r\n            referenceEnd = token.end;\r\n        }\r\n\r\n        if (trailingNodes.length > 1) {\r\n            for (const comment of trailingNodes) {\r\n                comment.inline = false;\r\n            }\r\n        }\r\n\r\n        if (trailingNodes.length > 0) {\r\n            entry.trailingComments = trailingNodes;\r\n        }\r\n    }\r\n\r\n    return entry;\r\n}\r\n\r\nfunction findTopLevelEquals(tokens: Token[]): number {\r\n    const stack: string[] = [];\r\n    for (let index = 0; index < tokens.length; index += 1) {\r\n        const token = tokens[index];\r\n        if (isOpeningToken(token)) {\r\n            stack.push(token.value);\r\n            continue;\r\n        }\r\n        if (isClosingToken(token)) {\r\n            stack.pop();\r\n            continue;\r\n        }\r\n        if (\r\n            stack.length === 0 &&\r\n            token.type === \"operator\" &&\r\n            token.value === \"=\"\r\n        ) {\r\n            return index;\r\n        }\r\n    }\r\n    return -1;\r\n}\r\n\r\nfunction isInlineSpacing(source: string, start: number, end: number): boolean {\r\n    if (start === undefined || end === undefined) {\r\n        return false;\r\n    }\r\n    for (let index = start; index < end; index += 1) {\r\n        const char = source[index];\r\n        if (char === \"\\n\" || char === \"\\r\") {\r\n            return false;\r\n        }\r\n        switch (char) {\r\n            case \" \":\r\n            case \"\\t\":\r\n            case \"\\f\":\r\n            case \"\\v\":\r\n            case \"\\u00A0\":\r\n            case \"\\u200B\":\r\n            case \"\\u2060\":\r\n            case \"\\uFEFF\":\r\n                break;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\n\r\nfunction extractKeyText(tokens: Token[]): string {\r\n    const text = tokens\r\n        .filter((token) => token.type !== \"newline\")\r\n        .map((token) => token.value)\r\n        .join(\" \")\r\n        .trim();\r\n    if (text.startsWith('\"') && text.endsWith('\"')) {\r\n        return text.slice(1, -1);\r\n    }\r\n    if (text.startsWith(\"'\") && text.endsWith(\"'\")) {\r\n        return text.slice(1, -1);\r\n    }\r\n    return text;\r\n}\r\n\r\nfunction splitArrayElements(tokens: Token[]): Token[][] {\r\n    return splitTopLevelTokens(tokens, {\r\n        delimiterValues: [\",\"],\r\n        splitOnNewline: (context) => context.current.length > 0,\r\n    });\r\n}\r\n\r\nfunction hasTopLevelComma(tokens: Token[]): boolean {\r\n    const stack: string[] = [];\r\n    for (const token of tokens) {\r\n        if (isOpeningToken(token)) {\r\n            stack.push(token.value);\r\n            continue;\r\n        }\r\n        if (isClosingToken(token)) {\r\n            stack.pop();\r\n            continue;\r\n        }\r\n        if (\r\n            stack.length === 0 &&\r\n            token.type === \"punctuation\" &&\r\n            token.value === \",\"\r\n        ) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\n/**\r\n * Parses PowerShell source code into an Abstract Syntax Tree (AST).\r\n *\r\n * This is the main entry point for parsing. It tokenizes the source, creates a\r\n * parser instance, and builds the AST representing the script structure.\r\n *\r\n * The parser is designed to be resilient and will attempt to parse even\r\n * malformed code to provide the best formatting experience possible.\r\n *\r\n * @param source - The PowerShell source code to parse\r\n * @param options - Parser options (currently used for resolving configuration)\r\n *\r\n * @returns A ScriptNode representing the root of the AST\r\n */\r\nexport function parsePowerShell(\r\n    source: string,\r\n    options: ParserOptions\r\n): ScriptNode {\r\n    resolveOptions(options);\r\n    const tokens = tokenize(source);\r\n    const parser = new Parser(tokens, source);\r\n    return parser.parseScript();\r\n}\r\n\r\n/**\r\n * Parses PowerShell source with custom terminator tokens.\r\n *\r\n * This is used internally for parsing sub-sections of scripts where certain\r\n * tokens should stop parsing (e.g., closing braces, specific keywords).\r\n *\r\n * @param source - The PowerShell source code to parse\r\n * @param terminators - Set of token values that should stop parsing\r\n *\r\n * @returns A ScriptNode representing the parsed section\r\n */\r\nexport function parseScriptWithTerminators(\r\n    source: string,\r\n    terminators: Set<string>\r\n): ScriptNode {\r\n    const tokens = tokenize(source);\r\n    const parser = new Parser(tokens, source);\r\n    return parser.parseScript(terminators);\r\n}\r\nexport const __parserTestUtils: {\r\n    isOpeningToken: typeof isOpeningToken;\r\n    isClosingToken: typeof isClosingToken;\r\n    collectStructureTokens: typeof collectStructureTokens;\r\n    splitHashtableEntries: typeof splitHashtableEntries;\r\n    findTopLevelEquals: typeof findTopLevelEquals;\r\n    extractKeyText: typeof extractKeyText;\r\n    splitArrayElements: typeof splitArrayElements;\r\n    hasTopLevelComma: typeof hasTopLevelComma;\r\n    splitTopLevelTokens: typeof splitTopLevelTokens;\r\n    parseScriptWithTerminators: typeof parseScriptWithTerminators;\r\n    buildExpressionFromTokens: typeof buildExpressionFromTokens;\r\n    createHereStringNode: typeof createHereStringNode;\r\n    createTextNode: typeof createTextNode;\r\n    buildHashtableEntry: typeof buildHashtableEntry;\r\n    resolveStructureEnd: typeof resolveStructureEnd;\r\n    parseStatementForTest: typeof parseStatementForTest;\r\n} = {\r\n    isOpeningToken,\r\n    isClosingToken,\r\n    collectStructureTokens,\r\n    splitHashtableEntries,\r\n    findTopLevelEquals,\r\n    extractKeyText,\r\n    splitArrayElements,\r\n    hasTopLevelComma,\r\n    splitTopLevelTokens,\r\n    parseScriptWithTerminators,\r\n    buildExpressionFromTokens,\r\n    createHereStringNode,\r\n    createTextNode,\r\n    buildHashtableEntry,\r\n    resolveStructureEnd,\r\n    parseStatementForTest,\r\n};\r\n\r\nexport const locStart = (node: { loc: { start: number } }): number =>\r\n    node.loc.start;\r\nexport const locEnd = (node: { loc: { end: number } }): number => node.loc.end;\r\n","import type { AstPath, Doc, ParserOptions, Printer } from \"prettier\";\r\nimport { doc } from \"prettier\";\r\n\r\nimport {\r\n    type ArrayLiteralNode,\r\n    type CommentNode,\r\n    type ExpressionNode,\r\n    type ExpressionPartNode,\r\n    type FunctionDeclarationNode,\r\n    type HashtableEntryNode,\r\n    type HashtableNode,\r\n    type HereStringNode,\r\n    type ParenthesisNode,\r\n    type PipelineNode,\r\n    type ScriptBlockNode,\r\n    type ScriptBodyNode,\r\n    type ScriptNode,\r\n    type TextNode,\r\n} from \"./ast.js\";\r\nimport { resolveOptions, type ResolvedOptions } from \"./options.js\";\r\n\r\nconst {\r\n    group,\r\n    indent,\r\n    line,\r\n    softline,\r\n    hardline,\r\n    join,\r\n    ifBreak,\r\n    lineSuffix,\r\n    dedentToRoot,\r\n    align,\r\n} = doc.builders;\r\n\r\n/**\r\n * The Prettier printer for PowerShell.\r\n *\r\n * This implements Prettier's Printer interface to convert PowerShell AST nodes\r\n * into formatted output using Prettier's document builders.\r\n *\r\n * The printer handles:\r\n *\r\n * - Indentation and spacing\r\n * - Line wrapping and breaking\r\n * - Operator formatting\r\n * - Comment preservation\r\n * - Hashtable alignment\r\n * - Pipeline formatting\r\n * - And much more!\r\n */\r\nexport const powerShellPrinter: Printer<ScriptNode> = {\r\n    print(path: AstPath, options: ParserOptions) {\r\n        const node = path.getValue() as\r\n            | ScriptNode\r\n            | ScriptBodyNode\r\n            | ExpressionPartNode\r\n            | undefined;\r\n        if (!node) {\r\n            return \"\";\r\n        }\r\n        const resolved = resolveOptions(options);\r\n        return printNode(node, resolved);\r\n    },\r\n};\r\n\r\n/**\r\n * Main routing function that dispatches AST nodes to their specific print\r\n * functions.\r\n *\r\n * @param node - The AST node to print\r\n * @param options - Resolved printer options\r\n *\r\n * @returns A Prettier Doc representing the formatted output\r\n */\r\nfunction printNode(\r\n    node:\r\n        | ScriptNode\r\n        | ScriptBodyNode\r\n        | ExpressionNode\r\n        | ExpressionPartNode\r\n        | HashtableEntryNode,\r\n    options: ResolvedOptions\r\n): Doc {\r\n    switch (node.type) {\r\n        case \"Script\":\r\n            return printScript(node, options);\r\n        case \"ScriptBlock\":\r\n            return printScriptBlock(node, options);\r\n        case \"FunctionDeclaration\":\r\n            return printFunction(node, options);\r\n        case \"Pipeline\":\r\n            return printPipeline(node, options);\r\n        case \"Expression\":\r\n            return printExpression(node, options);\r\n        case \"Text\":\r\n            return printText(node, options);\r\n        case \"Comment\":\r\n            return printComment(node);\r\n        case \"BlankLine\":\r\n            return Array.from({ length: node.count }, () => hardline);\r\n        case \"ArrayLiteral\":\r\n            return printArray(node, options);\r\n        case \"Hashtable\":\r\n            return printHashtable(node, options);\r\n        case \"HashtableEntry\":\r\n            return printHashtableEntry(node, options);\r\n        case \"HereString\":\r\n            return printHereString(node);\r\n        case \"Parenthesis\":\r\n            return printParenthesis(node, options);\r\n        default:\r\n            return \"\";\r\n    }\r\n}\r\n\r\nfunction concatDocs(docs: Doc[]): Doc {\r\n    if (docs.length === 0) {\r\n        return \"\";\r\n    }\r\n    let acc: Doc = docs[0];\r\n    for (let index = 1; index < docs.length; index += 1) {\r\n        acc = [acc, docs[index]] as Doc;\r\n    }\r\n    return acc;\r\n}\r\n\r\nfunction indentStatement(docToIndent: Doc, options: ResolvedOptions): Doc {\r\n    const indentUnit =\r\n        options.indentStyle === \"tabs\" ? \"\\t\" : \" \".repeat(options.indentSize);\r\n    return [indentUnit, align(indentUnit.length, docToIndent)] as Doc;\r\n}\r\n\r\nfunction printScript(node: ScriptNode, options: ResolvedOptions): Doc {\r\n    const bodyDoc = printStatementList(node.body, options, false);\r\n    if (!bodyDoc) {\r\n        return \"\";\r\n    }\r\n    return [bodyDoc, hardline];\r\n}\r\n\r\nfunction printStatementList(\r\n    body: ScriptBodyNode[],\r\n    options: ResolvedOptions,\r\n    indentStatements: boolean\r\n): Doc {\r\n    const docs: Doc[] = [];\r\n    let previous: ScriptBodyNode | null = null;\r\n    let pendingBlankLines = 0;\r\n\r\n    for (const entry of body) {\r\n        if (entry.type === \"BlankLine\") {\r\n            pendingBlankLines = Math.max(pendingBlankLines, entry.count);\r\n            continue;\r\n        }\r\n\r\n        if (previous) {\r\n            const blankLines = determineBlankLines(\r\n                previous,\r\n                entry,\r\n                pendingBlankLines,\r\n                options\r\n            );\r\n            for (let index = 0; index < blankLines; index += 1) {\r\n                docs.push(hardline);\r\n            }\r\n        }\r\n\r\n        const printed = printNode(entry, options);\r\n        if (\r\n            entry.type === \"Comment\" &&\r\n            previous &&\r\n            entry.loc.start < previous.loc.end &&\r\n            docs.length > 0\r\n        ) {\r\n            const commentDoc = indentStatements\r\n                ? indentStatement(printed, options)\r\n                : printed;\r\n            const lastIndex = docs.length - 1;\r\n            const priorDoc = docs[lastIndex];\r\n            docs[lastIndex] = priorDoc\r\n                ? concatDocs([\r\n                      priorDoc,\r\n                      hardline,\r\n                      commentDoc,\r\n                  ])\r\n                : commentDoc;\r\n            previous = entry;\r\n            pendingBlankLines = 0;\r\n            continue;\r\n        }\r\n\r\n        docs.push(\r\n            indentStatements ? indentStatement(printed, options) : printed\r\n        );\r\n        previous = entry;\r\n        pendingBlankLines = 0;\r\n    }\r\n\r\n    return concatDocs(docs);\r\n}\r\n\r\nfunction determineBlankLines(\r\n    previous: ScriptBodyNode,\r\n    current: ScriptBodyNode,\r\n    pendingBlankLines: number,\r\n    options: ResolvedOptions\r\n): number {\r\n    let base = pendingBlankLines > 0 ? pendingBlankLines : 1;\r\n    const desiredFunctionSpacing = options.blankLinesBetweenFunctions + 1;\r\n\r\n    if (\r\n        (previous.type === \"FunctionDeclaration\" &&\r\n            current.type === \"FunctionDeclaration\") ||\r\n        (previous.type === \"FunctionDeclaration\" &&\r\n            current.type !== \"BlankLine\") ||\r\n        (current.type === \"FunctionDeclaration\" &&\r\n            previous.type !== \"BlankLine\")\r\n    ) {\r\n        base = Math.max(base, desiredFunctionSpacing);\r\n    }\r\n\r\n    if (options.blankLineAfterParam && isParamStatement(previous)) {\r\n        base = Math.max(base, 2);\r\n    }\r\n\r\n    return base;\r\n}\r\n\r\nfunction printScriptBlock(\r\n    node: ScriptBlockNode,\r\n    options: ResolvedOptions\r\n): Doc {\r\n    if (node.body.length === 0) {\r\n        return \"{}\";\r\n    }\r\n\r\n    const bodyDoc = printStatementList(node.body, options, true);\r\n    return group([\r\n        \"{\",\r\n        hardline,\r\n        bodyDoc,\r\n        hardline,\r\n        \"}\",\r\n    ]);\r\n}\r\n\r\nfunction printFunction(\r\n    node: FunctionDeclarationNode,\r\n    options: ResolvedOptions\r\n): Doc {\r\n    const headerDoc = printExpression(node.header, options);\r\n    const bodyDoc = printScriptBlock(node.body, options);\r\n    if (options.braceStyle === \"allman\") {\r\n        return group([\r\n            headerDoc,\r\n            hardline,\r\n            bodyDoc,\r\n        ]);\r\n    }\r\n    return group([\r\n        headerDoc,\r\n        \" \",\r\n        bodyDoc,\r\n    ]);\r\n}\r\n\r\nfunction printPipeline(node: PipelineNode, options: ResolvedOptions): Doc {\r\n    const segmentDocs = node.segments.map((segment) =>\r\n        printExpression(segment, options)\r\n    );\r\n    if (segmentDocs.length === 0) {\r\n        return \"\";\r\n    }\r\n\r\n    let pipelineDoc: Doc = segmentDocs[0];\r\n\r\n    if (segmentDocs.length > 1) {\r\n        // For long pipelines, always break to improve readability\r\n        const shouldAlwaysBreak = segmentDocs.length > 3;\r\n\r\n        const restDocs = segmentDocs\r\n            .slice(1)\r\n            .map((segmentDoc) => [line, [\"| \", segmentDoc]]);\r\n\r\n        if (shouldAlwaysBreak) {\r\n            // Force line breaks for long pipelines\r\n            pipelineDoc = [\r\n                segmentDocs[0],\r\n                indent(restDocs.flatMap((docItem) => docItem)),\r\n            ];\r\n        } else {\r\n            pipelineDoc = group([\r\n                segmentDocs[0],\r\n                indent(restDocs.flatMap((docItem) => docItem)),\r\n            ]);\r\n        }\r\n    }\r\n\r\n    if (node.trailingComment) {\r\n        if (node.trailingComment.inline) {\r\n            pipelineDoc = [\r\n                pipelineDoc,\r\n                lineSuffix([\" #\", node.trailingComment.value]),\r\n            ];\r\n        } else {\r\n            pipelineDoc = [\r\n                pipelineDoc,\r\n                hardline,\r\n                printComment(node.trailingComment),\r\n            ];\r\n        }\r\n    }\r\n\r\n    return pipelineDoc;\r\n}\r\n\r\n/**\r\n * Heuristic to detect if text appears to be comment prose rather than code.\r\n * Uses a minimum length threshold to avoid false positives with short variable\r\n * names or keywords that might not have typical syntax markers.\r\n */\r\nfunction looksLikeCommentText(text: string): boolean {\r\n    const trimmed = text.trim();\r\n\r\n    // Too short to determine reliably\r\n    if (trimmed.length <= MINIMUM_COMMENT_LENGTH) {\r\n        return false;\r\n    }\r\n\r\n    // Definitely code if it starts with typical PowerShell syntax\r\n    if (\r\n        trimmed.startsWith(\"$\") ||\r\n        trimmed.startsWith(\"[\") ||\r\n        trimmed.startsWith(\"(\") ||\r\n        trimmed.startsWith(\"{\") ||\r\n        trimmed.startsWith(\"@\")\r\n    ) {\r\n        return false;\r\n    }\r\n\r\n    // Likely code if it contains assignment or typical operators\r\n    if (\r\n        trimmed.includes(\"=\") ||\r\n        trimmed.includes(\"->\") ||\r\n        trimmed.includes(\"::\") ||\r\n        trimmed.match(/\\b(function|param|if|foreach|while)\\b/i)\r\n    ) {\r\n        return false;\r\n    }\r\n\r\n    // If it contains spaces and looks like natural language, it's likely a comment\r\n    const hasSpaces = trimmed.includes(\" \");\r\n    const wordCount = trimmed.split(/\\s+/).length;\r\n    return hasSpaces && wordCount >= 3;\r\n}\r\n\r\nfunction printExpression(node: ExpressionNode, options: ResolvedOptions): Doc {\r\n    const docs: Doc[] = [];\r\n\r\n    const filteredParts = node.parts.filter((part) => !shouldSkipPart(part));\r\n    const normalizedParts: ExpressionPartNode[] = [];\r\n\r\n    for (let index = 0; index < filteredParts.length; index += 1) {\r\n        const current = filteredParts[index];\r\n        if (current.type === \"Text\" && current.role === \"operator\") {\r\n            const next = filteredParts[index + 1];\r\n            if (next && next.type === \"Text\" && next.role === \"operator\") {\r\n                const combinedValue = current.value + next.value;\r\n                if (CONCATENATED_OPERATOR_PAIRS.has(combinedValue)) {\r\n                    normalizedParts.push({\r\n                        ...current,\r\n                        value: combinedValue,\r\n                        loc: { start: current.loc.start, end: next.loc.end },\r\n                    });\r\n                    index += 1;\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n        normalizedParts.push(current);\r\n    }\r\n\r\n    let previous: ExpressionPartNode | null = null;\r\n\r\n    for (let index = 0; index < normalizedParts.length; index += 1) {\r\n        const part = normalizedParts[index];\r\n\r\n        if (part.type === \"Parenthesis\" && isParamKeyword(previous)) {\r\n            docs.push(printParamParenthesis(part, options));\r\n            previous = part;\r\n            continue;\r\n        }\r\n\r\n        // Check if this is comment text (not starting with #, but appears to be prose)\r\n        if (\r\n            part.type === \"Text\" &&\r\n            part.role === \"unknown\" &&\r\n            previous &&\r\n            !part.value.trim().startsWith(\"#\") &&\r\n            looksLikeCommentText(part.value)\r\n        ) {\r\n            // This looks like comment text - treat it as an inline comment\r\n            docs.push(lineSuffix([\" # \", part.value.trim()]));\r\n            previous = part;\r\n            continue;\r\n        }\r\n\r\n        if (previous) {\r\n            // Special case: word followed by parenthesis could be method call or cmdlet\r\n            // Check if the word comes after . or :: (method call - no space)\r\n            if (\r\n                part.type === \"Parenthesis\" &&\r\n                previous.type === \"Text\" &&\r\n                previous.role === \"word\" &&\r\n                index >= 2\r\n            ) {\r\n                const beforeWord = normalizedParts[index - 2];\r\n                if (\r\n                    beforeWord &&\r\n                    beforeWord.type === \"Text\" &&\r\n                    (beforeWord.value === \".\" || beforeWord.value === \"::\")\r\n                ) {\r\n                    // This is a method call - no space before (\r\n                    docs.push(printNode(part, options));\r\n                    previous = part;\r\n                    continue;\r\n                }\r\n            }\r\n\r\n            const separator = gapBetween(previous, part);\r\n            if (separator) {\r\n                docs.push(separator);\r\n            }\r\n        }\r\n\r\n        docs.push(printNode(part, options));\r\n        previous = part;\r\n    }\r\n\r\n    return docs.length === 0 ? \"\" : group(docs);\r\n}\r\n\r\nfunction gapBetween(\r\n    previous: ExpressionPartNode,\r\n    current: ExpressionPartNode\r\n): Doc | null {\r\n    const prevSymbol = getSymbol(previous);\r\n    const currentSymbol = getSymbol(current);\r\n\r\n    if (\r\n        current.type === \"ArrayLiteral\" &&\r\n        current.kind === \"explicit\" &&\r\n        Boolean(previous)\r\n    ) {\r\n        return null;\r\n    }\r\n\r\n    if (\r\n        current.type === \"Text\" &&\r\n        current.role === \"operator\" &&\r\n        (current.value === \"++\" || current.value === \"--\")\r\n    ) {\r\n        return null;\r\n    }\r\n\r\n    if (\r\n        previous.type === \"Text\" &&\r\n        previous.role === \"operator\" &&\r\n        current.type === \"Text\" &&\r\n        current.role === \"operator\"\r\n    ) {\r\n        const combined = previous.value + current.value;\r\n        if (CONCATENATED_OPERATOR_PAIRS.has(combined)) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    if (current.type === \"Parenthesis\") {\r\n        if (previous && previous.type === \"Text\") {\r\n            if (previous.value.toLowerCase() === \"param\") {\r\n                return null;\r\n            }\r\n            if (previous.role === \"keyword\") {\r\n                return \" \";\r\n            }\r\n            // Operators need space before parenthesis\r\n            if (previous.role === \"operator\") {\r\n                return \" \";\r\n            }\r\n            // Cmdlets and functions (words) need space before parenthesis\r\n            // Method calls are handled in printExpression\r\n            if (previous.role === \"word\") {\r\n                return \" \";\r\n            }\r\n            // PowerShell logical operators need space before parenthesis\r\n            const prevLower = previous.value.toLowerCase();\r\n            if (\r\n                prevLower.startsWith(\"-\") &&\r\n                (prevLower === \"-not\" ||\r\n                    prevLower === \"-and\" ||\r\n                    prevLower === \"-or\" ||\r\n                    prevLower === \"-xor\")\r\n            ) {\r\n                return \" \";\r\n            }\r\n            return null;\r\n        }\r\n        return \" \";\r\n    }\r\n\r\n    if (previous.type === \"Parenthesis\") {\r\n        if (currentSymbol && NO_SPACE_BEFORE.has(currentSymbol)) {\r\n            return null;\r\n        }\r\n        return \" \";\r\n    }\r\n\r\n    if (!prevSymbol && !currentSymbol) {\r\n        return \" \";\r\n    }\r\n\r\n    if (!prevSymbol) {\r\n        if (currentSymbol && NO_SPACE_BEFORE.has(currentSymbol)) {\r\n            return null;\r\n        }\r\n        return \" \";\r\n    }\r\n\r\n    if (NO_SPACE_AFTER.has(prevSymbol)) {\r\n        return null;\r\n    }\r\n\r\n    if (currentSymbol && NO_SPACE_BEFORE.has(currentSymbol)) {\r\n        return null;\r\n    }\r\n\r\n    if (\r\n        prevSymbol &&\r\n        currentSymbol &&\r\n        SYMBOL_NO_GAP.has(`${prevSymbol}:${currentSymbol}`)\r\n    ) {\r\n        return null;\r\n    }\r\n\r\n    if (prevSymbol && currentSymbol) {\r\n        const pair = `${prevSymbol}${currentSymbol}`;\r\n        if (CONCATENATED_OPERATOR_PAIRS.has(pair)) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n    /* c8 ignore next */\r\n    if (prevSymbol === \"=\" || currentSymbol === \"=\") {\r\n        return \" \";\r\n    }\r\n\r\n    if (\r\n        current.type === \"ScriptBlock\" ||\r\n        current.type === \"Hashtable\" ||\r\n        current.type === \"ArrayLiteral\"\r\n    ) {\r\n        return \" \";\r\n    }\r\n\r\n    return \" \";\r\n}\r\n\r\nfunction isParamStatement(node: ScriptBodyNode | null): boolean {\r\n    if (!node || node.type !== \"Pipeline\") {\r\n        return false;\r\n    }\r\n    if (node.segments.length === 0) {\r\n        return false;\r\n    }\r\n    const firstSegment = node.segments[0];\r\n    if (firstSegment.parts.length === 0) {\r\n        return false;\r\n    }\r\n    const firstPart = firstSegment.parts.find((part) => part.type === \"Text\");\r\n    if (!firstPart || firstPart.type !== \"Text\") {\r\n        return false;\r\n    }\r\n    return firstPart.value.toLowerCase() === \"param\";\r\n}\r\n\r\nconst NO_SPACE_BEFORE = new Set([\r\n    \")\",\r\n    \"]\",\r\n    \"}\",\r\n    \",\",\r\n    \";\",\r\n    \".\",\r\n    \"::\",\r\n    \":\",\r\n    \">\",\r\n    \"<\",\r\n]);\r\nconst NO_SPACE_AFTER = new Set([\r\n    \"(\",\r\n    \"[\",\r\n    \"{\",\r\n    \".\",\r\n    \"::\",\r\n    \":\",\r\n    \"@\",\r\n    \">\",\r\n    \"<\",\r\n    \">>\",\r\n    \"2>\",\r\n    \"2>>\",\r\n    \"3>\",\r\n    \"3>>\",\r\n    \"4>\",\r\n    \"4>>\",\r\n    \"5>\",\r\n    \"5>>\",\r\n    \"6>\",\r\n    \"6>>\",\r\n    \"*>\",\r\n    \"*>>\",\r\n    \"2>&1\",\r\n    \"3>&1\",\r\n    \"4>&1\",\r\n    \"5>&1\",\r\n    \"6>&1\",\r\n    \"*>&1\",\r\n    \"1>&2\",\r\n    \"2>&2\",\r\n    \"3>&2\",\r\n    \"4>&2\",\r\n    \"5>&2\",\r\n    \"6>&2\",\r\n    \"*>&2\",\r\n]);\r\n/**\r\n * Minimum character length for text to be considered comment prose. Used to\r\n * avoid false positives with short variable names or keywords.\r\n */\r\nconst MINIMUM_COMMENT_LENGTH = 10;\r\nconst SYMBOL_NO_GAP = new Set([\r\n    \".:word\",\r\n    \"::word\",\r\n    \"word:(\",\r\n    \"word:[\",\r\n]);\r\nconst CONCATENATED_OPERATOR_PAIRS = new Set([\r\n    \"++\",\r\n    \"--\",\r\n    \"+=\",\r\n    \"-=\",\r\n    \"*=\",\r\n    \"/=\",\r\n    \"%=\",\r\n    \"&=\",\r\n    \"|=\",\r\n    \"^=\",\r\n    \"??\",\r\n]);\r\n\r\nfunction getSymbol(node: ExpressionPartNode | null): string | null {\r\n    if (!node) {\r\n        return null;\r\n    }\r\n    if (\r\n        node.type === \"Text\" &&\r\n        (node.role === \"punctuation\" || node.role === \"operator\")\r\n    ) {\r\n        return node.value;\r\n    }\r\n    // Handle special characters that may be role=\"unknown\"\r\n    if (node.type === \"Text\" && node.role === \"unknown\") {\r\n        const val = node.value.trim();\r\n        if (val === \"@\" || val === \"::\" || val === \":\") {\r\n            return val;\r\n        }\r\n    }\r\n    if (node.type === \"Parenthesis\") {\r\n        return \"(\";\r\n    }\r\n    return null;\r\n}\r\n\r\nfunction isParamKeyword(node: ExpressionPartNode | null): boolean {\r\n    return Boolean(\r\n        node && node.type === \"Text\" && node.value.toLowerCase() === \"param\"\r\n    );\r\n}\r\n\r\nconst KEYWORD_CASE_TRANSFORMS: Record<string, (value: string) => string> = {\r\n    preserve: (value) => value,\r\n    lower: (value) => value.toLowerCase(),\r\n    upper: (value) => value.toUpperCase(),\r\n    pascal: (value) =>\r\n        value.length === 0\r\n            ? value\r\n            : value[0].toUpperCase() + value.slice(1).toLowerCase(),\r\n};\r\n\r\nconst CMDLET_ALIAS_MAP: Record<string, string> = {\r\n    gi: \"Get-Item\",\r\n    gci: \"Get-ChildItem\",\r\n    ls: \"Get-ChildItem\",\r\n    dir: \"Get-ChildItem\",\r\n    ld: \"Get-ChildItem\",\r\n    la: \"Get-ChildItem\",\r\n    gcm: \"Get-Command\",\r\n    gm: \"Get-Member\",\r\n    gps: \"Get-Process\",\r\n    ps: \"Get-Process\",\r\n    gwmi: \"Get-WmiObject\",\r\n    gsv: \"Get-Service\",\r\n    cat: \"Get-Content\",\r\n    gc: \"Get-Content\",\r\n    echo: \"Write-Output\",\r\n    write: \"Write-Output\",\r\n    \"%\": \"ForEach-Object\",\r\n    foreach: \"ForEach-Object\",\r\n    \"?\": \"Where-Object\",\r\n    where: \"Where-Object\",\r\n};\r\n\r\nconst DISALLOWED_CMDLET_REWRITE = new Map([[\"write-host\", \"Write-Output\"]]);\r\n\r\nfunction printText(node: TextNode, options: ResolvedOptions): Doc {\r\n    if (node.role === \"string\") {\r\n        return normalizeStringLiteral(node.value, options);\r\n    }\r\n\r\n    let value = node.value;\r\n\r\n    if (node.role === \"keyword\") {\r\n        const transform =\r\n            KEYWORD_CASE_TRANSFORMS[options.keywordCase] ??\r\n            KEYWORD_CASE_TRANSFORMS.preserve;\r\n        value = transform(value);\r\n    }\r\n\r\n    if (\r\n        options.rewriteAliases &&\r\n        (node.role === \"word\" ||\r\n            node.role === \"operator\" ||\r\n            node.role === \"unknown\")\r\n    ) {\r\n        const aliasKey = value.toLowerCase();\r\n        if (Object.prototype.hasOwnProperty.call(CMDLET_ALIAS_MAP, aliasKey)) {\r\n            value = CMDLET_ALIAS_MAP[aliasKey]!;\r\n        }\r\n    }\r\n\r\n    if (node.role === \"word\" && options.rewriteWriteHost) {\r\n        const replacement = DISALLOWED_CMDLET_REWRITE.get(value.toLowerCase());\r\n        if (replacement) {\r\n            value = replacement;\r\n        }\r\n    }\r\n\r\n    return value;\r\n}\r\n\r\nfunction printComment(node: CommentNode): Doc {\r\n    if (node.style === \"block\") {\r\n        return node.value;\r\n    }\r\n    return [\"#\", node.value];\r\n}\r\n\r\nfunction printArray(node: ArrayLiteralNode, options: ResolvedOptions): Doc {\r\n    const open = node.kind === \"implicit\" ? \"@(\" : \"[\";\r\n    const close = node.kind === \"implicit\" ? \")\" : \"]\";\r\n    if (node.elements.length === 0) {\r\n        return [open, close];\r\n    }\r\n    const groupId = Symbol(\"array\");\r\n    const elementDocs = node.elements.map((element) =>\r\n        printExpression(element, options)\r\n    );\r\n    const shouldBreak = elementDocs.length > 1;\r\n    const separator: Doc = [\",\", line];\r\n    // PowerShell does NOT support trailing commas in arrays, so never add them\r\n\r\n    return group(\r\n        [\r\n            open,\r\n            indent([\r\n                shouldBreak ? line : softline,\r\n                join(separator, elementDocs),\r\n            ]),\r\n            shouldBreak ? line : softline,\r\n            close,\r\n        ],\r\n        { id: groupId }\r\n    );\r\n}\r\n\r\nfunction printHashtable(node: HashtableNode, options: ResolvedOptions): Doc {\r\n    const entries = options.sortHashtableKeys\r\n        ? [...node.entries].sort((a, b) =>\r\n              a.key.localeCompare(b.key, undefined, { sensitivity: \"base\" })\r\n          )\r\n        : node.entries;\r\n\r\n    if (entries.length === 0) {\r\n        return \"@{}\";\r\n    }\r\n\r\n    const groupId = Symbol(\"hashtable\");\r\n\r\n    const entryDocs = entries.map((entry, index) => {\r\n        const entryDoc = printHashtableEntry(entry, options);\r\n        const isLast = index === entries.length - 1;\r\n        const separator = isLast\r\n            ? trailingCommaDoc(options, groupId, true, \";\")\r\n            : ifBreak(\"\", \";\", { groupId });\r\n        return [entryDoc, separator];\r\n    });\r\n\r\n    return group(\r\n        [\r\n            \"@{\",\r\n            indent([line, join(line, entryDocs)]),\r\n            line,\r\n            \"}\",\r\n        ],\r\n        {\r\n            id: groupId,\r\n        }\r\n    );\r\n}\r\n\r\nfunction printHashtableEntry(\r\n    node: HashtableEntryNode,\r\n    options: ResolvedOptions\r\n): Doc {\r\n    const keyDoc = printExpression(node.rawKey, options);\r\n    const valueDoc = printExpression(node.value, options);\r\n\r\n    // Check if the value expression starts with a control flow keyword\r\n    // (if, switch, foreach, etc.) - these should stay on the same line as '='\r\n    const firstPart = node.value.parts[0];\r\n    const startsWithKeyword =\r\n        firstPart &&\r\n        firstPart.type === \"Text\" &&\r\n        firstPart.role === \"keyword\" &&\r\n        /^(if|switch|foreach|while|for)$/i.test(firstPart.value);\r\n\r\n    let entryDoc: Doc;\r\n    if (startsWithKeyword) {\r\n        // Keep keyword expressions on the same line as the '=' sign\r\n        entryDoc = group([\r\n            keyDoc,\r\n            \" = \",\r\n            valueDoc,\r\n        ]);\r\n    } else {\r\n        entryDoc = group([\r\n            keyDoc,\r\n            \" =\",\r\n            indent([line, valueDoc]),\r\n        ]);\r\n    }\r\n\r\n    // Add leading comments\r\n    if (node.leadingComments && node.leadingComments.length > 0) {\r\n        const commentDocs = node.leadingComments.map((comment) =>\r\n            printComment(comment)\r\n        );\r\n        entryDoc = [\r\n            join(hardline, commentDocs),\r\n            hardline,\r\n            entryDoc,\r\n        ];\r\n    }\r\n\r\n    // Add trailing comments\r\n    if (node.trailingComments && node.trailingComments.length > 0) {\r\n        for (const comment of node.trailingComments) {\r\n            if (comment.inline) {\r\n                entryDoc = [entryDoc, lineSuffix([\" \", printComment(comment)])];\r\n            } else {\r\n                entryDoc = [\r\n                    entryDoc,\r\n                    hardline,\r\n                    printComment(comment),\r\n                ];\r\n            }\r\n        }\r\n    }\r\n\r\n    return entryDoc;\r\n}\r\n\r\nfunction printHereString(node: HereStringNode): Doc {\r\n    return dedentToRoot(node.value);\r\n}\r\n\r\nfunction printParamParenthesis(\r\n    node: ParenthesisNode,\r\n    options: ResolvedOptions\r\n): Doc {\r\n    if (node.elements.length === 0) {\r\n        return \"()\";\r\n    }\r\n\r\n    if (node.elements.length <= 1 && !node.hasNewline) {\r\n        return printParenthesis(node, options);\r\n    }\r\n\r\n    const groupId = Symbol(\"param\");\r\n    const elementDocs: Doc[] = [];\r\n    let pendingAttributes: Doc[] = [];\r\n\r\n    const flushAttributes = (nextDoc?: Doc) => {\r\n        if (pendingAttributes.length === 0) {\r\n            if (nextDoc) {\r\n                elementDocs.push(nextDoc);\r\n            }\r\n            return;\r\n        }\r\n\r\n        const attributeDoc =\r\n            pendingAttributes.length === 1\r\n                ? pendingAttributes[0]\r\n                : join(hardline, pendingAttributes);\r\n\r\n        if (nextDoc) {\r\n            elementDocs.push(\r\n                group([\r\n                    attributeDoc,\r\n                    hardline,\r\n                    nextDoc,\r\n                ])\r\n            );\r\n        } else {\r\n            elementDocs.push(attributeDoc);\r\n        }\r\n        pendingAttributes = [];\r\n    };\r\n\r\n    for (let index = 0; index < node.elements.length; index += 1) {\r\n        const element = node.elements[index];\r\n\r\n        // Skip comment-only expressions - they'll be handled as trailing comments\r\n        if (isCommentExpression(element)) {\r\n            continue;\r\n        }\r\n\r\n        if (isAttributeExpression(element)) {\r\n            pendingAttributes.push(printExpression(element, options));\r\n            continue;\r\n        }\r\n\r\n        let printed = printExpression(element, options);\r\n\r\n        // Check if the next element is a comment - if so, attach it inline\r\n        const nextElement = node.elements[index + 1];\r\n        if (nextElement && isCommentExpression(nextElement)) {\r\n            const commentText = extractCommentText(nextElement);\r\n            if (commentText) {\r\n                printed = [printed, lineSuffix([\" \", commentText])];\r\n                index += 1; // Skip the comment element since we've consumed it\r\n            }\r\n        }\r\n\r\n        flushAttributes(printed);\r\n    }\r\n\r\n    flushAttributes();\r\n    const separator: Doc = [\",\", hardline];\r\n\r\n    return group(\r\n        [\r\n            \"(\",\r\n            indent([hardline, join(separator, elementDocs)]),\r\n            hardline,\r\n            \")\",\r\n        ],\r\n        {\r\n            id: groupId,\r\n        }\r\n    );\r\n}\r\n\r\nfunction isAttributeExpression(node: ExpressionNode): boolean {\r\n    if (node.parts.length === 0) {\r\n        return false;\r\n    }\r\n\r\n    return node.parts.every((part) => {\r\n        if (part.type !== \"Text\") {\r\n            return false;\r\n        }\r\n        const trimmed = part.value.trim();\r\n        return trimmed.startsWith(\"[\") && trimmed.endsWith(\"]\");\r\n    });\r\n}\r\n\r\nfunction isCommentExpression(node: ExpressionNode): boolean {\r\n    if (node.parts.length !== 1) {\r\n        return false;\r\n    }\r\n\r\n    const part = node.parts[0];\r\n    if (part.type !== \"Text\") {\r\n        return false;\r\n    }\r\n\r\n    // Check if it's likely a comment based on context:\r\n    // 1. Starts with # or <# (original inline comment)\r\n    // 2. Appears to be comment text (no $ or [ at start, longer text)\r\n    const trimmed = part.value.trim();\r\n    if (trimmed.startsWith(\"#\") || trimmed.startsWith(\"<#\")) {\r\n        return true;\r\n    }\r\n\r\n    return looksLikeCommentText(trimmed);\r\n}\r\n\r\nfunction extractCommentText(node: ExpressionNode): string | null {\r\n    if (!isCommentExpression(node)) {\r\n        return null;\r\n    }\r\n\r\n    const part = node.parts[0];\r\n    if (part.type !== \"Text\") {\r\n        return null;\r\n    }\r\n\r\n    const trimmed = part.value.trim();\r\n    // If it already starts with #, return as is\r\n    if (trimmed.startsWith(\"#\")) {\r\n        return trimmed;\r\n    }\r\n    // Otherwise, prepend # to make it a comment\r\n    return `# ${trimmed}`;\r\n}\r\n\r\nfunction printParenthesis(\r\n    node: ParenthesisNode,\r\n    options: ResolvedOptions\r\n): Doc {\r\n    if (node.elements.length === 0) {\r\n        return \"()\";\r\n    }\r\n    const groupId = Symbol(\"parenthesis\");\r\n    const elementDocs = node.elements.map((element) =>\r\n        printExpression(element, options)\r\n    );\r\n    if (elementDocs.length === 1 && !node.hasNewline) {\r\n        return group(\r\n            [\r\n                \"(\",\r\n                indent([softline, elementDocs[0]]),\r\n                softline,\r\n                \")\",\r\n            ],\r\n            {\r\n                id: groupId,\r\n            }\r\n        );\r\n    }\r\n\r\n    const hasComma = node.hasComma;\r\n    const forceMultiline =\r\n        node.hasNewline || (!node.hasComma && elementDocs.length > 1);\r\n    const separator: Doc = hasComma\r\n        ? [\",\", forceMultiline ? hardline : line]\r\n        : hardline;\r\n    const leadingLine = hasComma\r\n        ? forceMultiline\r\n            ? hardline\r\n            : line\r\n        : hardline;\r\n    const trailingLine = hasComma\r\n        ? forceMultiline\r\n            ? hardline\r\n            : line\r\n        : hardline;\r\n\r\n    return group(\r\n        [\r\n            \"(\",\r\n            indent([leadingLine, join(separator, elementDocs)]),\r\n            trailingLine,\r\n            \")\",\r\n        ],\r\n        {\r\n            id: groupId,\r\n        }\r\n    );\r\n}\r\n\r\nfunction trailingCommaDoc(\r\n    options: ResolvedOptions,\r\n    groupId: symbol,\r\n    hasElements: boolean,\r\n    delimiter: \",\" | \";\"\r\n): Doc {\r\n    if (!hasElements) {\r\n        return \"\";\r\n    }\r\n    switch (options.trailingComma) {\r\n        case \"all\":\r\n            return delimiter;\r\n        case \"multiline\":\r\n            return ifBreak(delimiter, \"\", { groupId });\r\n        case \"none\":\r\n        default:\r\n            return \"\";\r\n    }\r\n}\r\n\r\nexport function createPrinter(): Printer<ScriptNode> {\r\n    return powerShellPrinter;\r\n}\r\n\r\nexport const __printerTestUtils: {\r\n    gapBetween: typeof gapBetween;\r\n    getSymbol: typeof getSymbol;\r\n    shouldSkipPart: typeof shouldSkipPart;\r\n    normalizeStringLiteral: typeof normalizeStringLiteral;\r\n    printParamParenthesis: typeof printParamParenthesis;\r\n    printPipeline: typeof printPipeline;\r\n    trailingCommaDoc: typeof trailingCommaDoc;\r\n    isParamStatement: typeof isParamStatement;\r\n    printNode: typeof printNode;\r\n    printScript: typeof printScript;\r\n    concatDocs: typeof concatDocs;\r\n    indentStatement: typeof indentStatement;\r\n    printStatementList: typeof printStatementList;\r\n} = {\r\n    gapBetween,\r\n    getSymbol,\r\n    shouldSkipPart,\r\n    normalizeStringLiteral,\r\n    printParamParenthesis,\r\n    printPipeline,\r\n    trailingCommaDoc,\r\n    isParamStatement,\r\n    printNode,\r\n    printScript,\r\n    concatDocs,\r\n    indentStatement,\r\n    printStatementList,\r\n};\r\n\r\nfunction normalizeStringLiteral(\r\n    value: string,\r\n    options: ResolvedOptions\r\n): string {\r\n    if (!options.preferSingleQuote) {\r\n        return value;\r\n    }\r\n\r\n    if (!value.startsWith('\"') || !value.endsWith('\"')) {\r\n        return value;\r\n    }\r\n\r\n    const inner = value.slice(1, -1);\r\n\r\n    // Skip normalization for regex-like pattern strings to avoid altering embedded quoting\r\n    // Heuristics: starts with (? or contains unescaped character classes or anchors typical of patterns.\r\n    if (\r\n        /^\\(\\?[imxsU]/.test(inner) ||\r\n        /\\[[^\\]]+\\]/.test(inner) ||\r\n        /\\bWrite-(Warning|Error|Host|Output)\\b/.test(inner)\r\n    ) {\r\n        return value;\r\n    }\r\n\r\n    if (inner.includes(\"'\")) {\r\n        return value;\r\n    }\r\n\r\n    if (/[`$\"\\n]/.test(inner)) {\r\n        return value;\r\n    }\r\n\r\n    return `'${inner}'`;\r\n}\r\n\r\nfunction shouldSkipPart(part: ExpressionPartNode): boolean {\r\n    if (part.type === \"Text\") {\r\n        const trimmed = part.value.trim();\r\n        if (trimmed === \"`\") {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n","import type { Plugin, SupportLanguage } from \"prettier\";\n\nimport { pluginOptions, defaultOptions } from \"./options.js\";\nimport { parsePowerShell, locEnd, locStart } from \"./parser.js\";\nimport { powerShellPrinter } from \"./printer.js\";\n\nconst languages: SupportLanguage[] = [\n    {\n        name: \"PowerShell\",\n        parsers: [\"powershell\"],\n        extensions: [\n            \".ps1\",\n            \".psm1\",\n            \".psd1\",\n        ],\n        tmScope: \"source.powershell\",\n        aceMode: \"powershell\",\n        linguistLanguageId: 131,\n        vscodeLanguageIds: [\"powershell\"],\n    },\n] as const;\n\nconst parsers: Plugin[\"parsers\"] = {\n    powershell: {\n        parse: parsePowerShell,\n        astFormat: \"powershell-ast\",\n        locStart,\n        locEnd,\n        hasPragma() {\n            return false;\n        },\n    },\n} as const;\n\nconst printers: Plugin[\"printers\"] = {\n    \"powershell-ast\": powerShellPrinter,\n};\n\nconst plugin: Plugin = {\n    languages,\n    parsers,\n    printers,\n    options: pluginOptions,\n    defaultOptions,\n};\n\nexport default plugin;\n"]}