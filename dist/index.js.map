{"version":3,"sources":["../src/options.ts","../src/tokenizer.ts","../src/parser.ts","../src/printer.ts","../src/index.ts"],"names":[],"mappings":"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","file":"index.js","sourcesContent":["import type { ParserOptions, SupportOptions } from 'prettier';\n\nexport type TrailingCommaOption = 'none' | 'multiline' | 'all';\nexport type IndentStyleOption = 'spaces' | 'tabs';\nexport type BraceStyleOption = '1tbs' | 'allman';\nexport type KeywordCaseOption = 'preserve' | 'lower' | 'upper' | 'pascal';\n\nexport interface PluginConfiguration {\n  powershellIndentStyle: IndentStyleOption;\n  powershellIndentSize: number;\n  powershellTrailingComma: TrailingCommaOption;\n  powershellSortHashtableKeys: boolean;\n  powershellBlankLinesBetweenFunctions: number;\n  powershellBlankLineAfterParam: boolean;\n  powershellBraceStyle: BraceStyleOption;\n  powershellLineWidth: number;\n  powershellPreferSingleQuote: boolean;\n  powershellKeywordCase: KeywordCaseOption;\n  powershellRewriteAliases: boolean;\n  powershellRewriteWriteHost: boolean;\n}\n\nexport const pluginOptions: SupportOptions = {\n  powershellIndentStyle: {\n    category: 'PowerShell',\n    type: 'choice',\n    default: 'spaces',\n    description: 'Indent PowerShell code using spaces or tabs.',\n    choices: [\n      { value: 'spaces', description: 'Use spaces for indentation.' },\n      { value: 'tabs', description: 'Use tabs for indentation.' },\n    ],\n  },\n  powershellIndentSize: {\n    category: 'PowerShell',\n    type: 'int',\n    default: 2,\n    description: 'Number of indentation characters for each level.',\n    range: { start: 1, end: 8, step: 1 },\n  },\n  powershellTrailingComma: {\n    category: 'PowerShell',\n    type: 'choice',\n    default: 'multiline',\n    description: 'Control trailing commas for array and hashtable literals.',\n    choices: [\n      { value: 'none', description: 'Never add a trailing comma or semicolon.' },\n      {\n        value: 'multiline',\n        description: 'Add trailing comma/semicolon when the literal spans multiple lines.',\n      },\n      { value: 'all', description: 'Always add trailing comma/semicolon when possible.' },\n    ],\n  },\n  powershellSortHashtableKeys: {\n    category: 'PowerShell',\n    type: 'boolean',\n    default: false,\n    description: 'Sort hashtable keys alphabetically when formatting.',\n  },\n  powershellBlankLinesBetweenFunctions: {\n    category: 'PowerShell',\n    type: 'int',\n    default: 1,\n    description: 'Number of blank lines to ensure between function declarations.',\n    range: { start: 0, end: 3, step: 1 },\n  },\n  powershellBlankLineAfterParam: {\n    category: 'PowerShell',\n    type: 'boolean',\n    default: true,\n    description: 'Insert a blank line after param(...) blocks inside script blocks.',\n  },\n  powershellBraceStyle: {\n    category: 'PowerShell',\n    type: 'choice',\n    default: '1tbs',\n    description: 'Control placement of opening braces for script blocks and functions.',\n    choices: [\n      {\n        value: '1tbs',\n        description: 'One True Brace Style – keep opening braces on the same line.',\n      },\n      { value: 'allman', description: 'Allman style – place opening braces on the next line.' },\n    ],\n  },\n  powershellLineWidth: {\n    category: 'PowerShell',\n    type: 'int',\n    default: 120,\n    description: 'Maximum preferred line width for PowerShell documents.',\n    range: { start: 40, end: 200, step: 1 },\n  },\n  powershellPreferSingleQuote: {\n    category: 'PowerShell',\n    type: 'boolean',\n    default: false,\n    description: 'Prefer single-quoted strings when no interpolation is required.',\n  },\n  powershellKeywordCase: {\n    category: 'PowerShell',\n    type: 'choice',\n    default: 'preserve',\n    description: 'Normalise the casing of PowerShell keywords.',\n    choices: [\n      { value: 'preserve', description: 'Leave keyword casing unchanged.' },\n      { value: 'lower', description: 'Convert keywords to lower-case.' },\n      { value: 'upper', description: 'Convert keywords to upper-case.' },\n      { value: 'pascal', description: 'Capitalise keywords (PascalCase).' },\n    ],\n  },\n  powershellRewriteAliases: {\n    category: 'PowerShell',\n    type: 'boolean',\n    default: false,\n    description: 'Rewrite common cmdlet aliases to their canonical names.',\n  },\n  powershellRewriteWriteHost: {\n    category: 'PowerShell',\n    type: 'boolean',\n    default: false,\n    description: 'Rewrite Write-Host invocations to Write-Output to discourage host-only output.',\n  },\n};\n\nexport const defaultOptions = {\n  tabWidth: 2,\n};\n\nexport interface ResolvedOptions {\n  indentStyle: IndentStyleOption;\n  indentSize: number;\n  trailingComma: TrailingCommaOption;\n  sortHashtableKeys: boolean;\n  blankLinesBetweenFunctions: number;\n  blankLineAfterParam: boolean;\n  braceStyle: BraceStyleOption;\n  lineWidth: number;\n  preferSingleQuote: boolean;\n  keywordCase: KeywordCaseOption;\n  rewriteAliases: boolean;\n  rewriteWriteHost: boolean;\n}\n\nexport function resolveOptions(options: ParserOptions): ResolvedOptions {\n  const indentStyle = (options.powershellIndentStyle as IndentStyleOption | undefined) ?? 'spaces';\n  const indentSize = (options.powershellIndentSize as number | undefined) ?? options.tabWidth ?? 2;\n\n  if (indentStyle === 'tabs') {\n    options.useTabs = true;\n  } else {\n    options.useTabs = false;\n  }\n  options.tabWidth = indentSize;\n\n  const trailingComma =\n    (options.powershellTrailingComma as TrailingCommaOption | undefined) ?? 'multiline';\n  const sortHashtableKeys = Boolean(options.powershellSortHashtableKeys);\n  const blankLinesBetweenFunctions = Math.max(\n    0,\n    Math.min(3, Number(options.powershellBlankLinesBetweenFunctions ?? 1)),\n  );\n  const blankLineAfterParam = options.powershellBlankLineAfterParam === false ? false : true;\n  const braceStyle = (options.powershellBraceStyle as BraceStyleOption | undefined) ?? '1tbs';\n  const lineWidth = Math.max(40, Math.min(200, Number(options.powershellLineWidth ?? 120)));\n  const preferSingleQuote = options.powershellPreferSingleQuote === true;\n  const keywordCase =\n    (options.powershellKeywordCase as KeywordCaseOption | undefined) ?? 'preserve';\n  const rewriteAliases = options.powershellRewriteAliases === true;\n  const rewriteWriteHost = options.powershellRewriteWriteHost === true;\n\n  if (!options.printWidth || options.printWidth > lineWidth) {\n    options.printWidth = lineWidth;\n  }\n\n  return {\n    indentStyle,\n    indentSize,\n    trailingComma,\n    sortHashtableKeys,\n    blankLinesBetweenFunctions,\n    blankLineAfterParam,\n    braceStyle,\n    lineWidth,\n    preferSingleQuote,\n    keywordCase,\n    rewriteAliases,\n    rewriteWriteHost,\n  } satisfies ResolvedOptions;\n}\n","import type { HereStringNode } from './ast.js';\n\nexport type TokenType =\n  | 'newline'\n  | 'identifier'\n  | 'keyword'\n  | 'variable'\n  | 'number'\n  | 'string'\n  | 'heredoc'\n  | 'comment'\n  | 'punctuation'\n  | 'operator'\n  | 'unknown';\n\nexport interface Token {\n  type: TokenType;\n  value: string;\n  start: number;\n  end: number;\n  quote?: 'single' | 'double';\n}\n\nconst KEYWORDS = new Set([\n  'function',\n  'if',\n  'elseif',\n  'else',\n  'for',\n  'foreach',\n  'while',\n  'switch',\n  'try',\n  'catch',\n  'finally',\n  'param',\n  'class',\n]);\n\nconst PUNCTUATION = new Set(['{', '}', '(', ')', '[', ']', ',', ';', '.', ':']);\n\nexport function tokenize(source: string): Token[] {\n  const tokens: Token[] = [];\n  const length = source.length;\n  let index = 0;\n\n  const push = (token: Token) => {\n    tokens.push(token);\n  };\n\n  while (index < length) {\n    const char = source[index];\n    const start = index;\n\n    if (char === '\\r' || char === '\\n') {\n      if (char === '\\r' && source[index + 1] === '\\n') {\n        index += 2;\n        push({ type: 'newline', value: '\\r\\n', start, end: index });\n      } else {\n        index += 1;\n        push({ type: 'newline', value: '\\n', start, end: index });\n      }\n      continue;\n    }\n\n    if (char === ' ' || char === '\\t' || char === '\\f') {\n      index += 1;\n      continue;\n    }\n\n    if (char === '#') {\n      index += 1;\n      while (index < length && source[index] !== '\\r' && source[index] !== '\\n') {\n        index += 1;\n      }\n      push({ type: 'comment', value: source.slice(start + 1, index).trimEnd(), start, end: index });\n      continue;\n    }\n\n    if (char === '@' && (source[index + 1] === '\"' || source[index + 1] === \"'\")) {\n      const quoteChar = source[index + 1];\n      const quote = quoteChar === '\"' ? 'double' : 'single';\n      let searchIndex = index + 2;\n      let closing = -1;\n      while (searchIndex < length - 1) {\n        if (source[searchIndex] === quoteChar && source[searchIndex + 1] === '@') {\n          const prevChar = source[searchIndex - 1];\n          const prevPrev = source[searchIndex - 2];\n          if (\n            searchIndex === index + 2 ||\n            prevChar === '\\n' ||\n            (prevChar === '\\r' && prevPrev === '\\n')\n          ) {\n            closing = searchIndex;\n            break;\n          }\n        }\n        searchIndex += 1;\n      }\n\n      let end = length;\n      if (closing !== -1) {\n        end = closing + 2;\n      }\n\n      push({\n        type: 'heredoc',\n        value: source.slice(index, end),\n        start,\n        end,\n        quote,\n      });\n      index = end;\n      continue;\n    }\n\n    if (char === \"'\" || char === '\"') {\n      const quote = char === '\"' ? 'double' : 'single';\n      index += 1;\n      let escaped = false;\n      while (index < length) {\n        const current = source[index];\n        if (escaped) {\n          escaped = false;\n        } else if (current === '`') {\n          escaped = true;\n        } else if (current === char) {\n          index += 1;\n          break;\n        }\n        index += 1;\n      }\n      push({\n        type: 'string',\n        value: source.slice(start, index),\n        start,\n        end: index,\n        quote,\n      });\n      continue;\n    }\n\n    if (char === '@' && (source[index + 1] === '{' || source[index + 1] === '(')) {\n      const value = `@${source[index + 1]}`;\n      index += 2;\n      push({ type: 'operator', value, start, end: index });\n      continue;\n    }\n\n    if (PUNCTUATION.has(char)) {\n      index += 1;\n      push({ type: 'punctuation', value: char, start, end: index });\n      continue;\n    }\n\n    if (char === '|' || char === '=') {\n      let value = char;\n      if (source[index + 1] === char) {\n        value += char;\n        index += 2;\n      } else {\n        index += 1;\n      }\n      push({ type: 'operator', value, start, end: index });\n      continue;\n    }\n\n    if (char === ':' && source[index + 1] === ':') {\n      index += 2;\n      push({ type: 'operator', value: '::', start, end: index });\n      continue;\n    }\n\n    if (char === '$') {\n      index += 1;\n      while (index < length) {\n        const c = source[index];\n        if (/^[A-Za-z0-9_:-]$/.test(c)) {\n          index += 1;\n          continue;\n        }\n        if (c === '{') {\n          index += 1;\n          while (index < length && source[index] !== '}') {\n            index += 1;\n          }\n          if (source[index] === '}') {\n            index += 1;\n          }\n          continue;\n        }\n        break;\n      }\n      push({ type: 'variable', value: source.slice(start, index), start, end: index });\n      continue;\n    }\n\n    if (/[0-9]/.test(char)) {\n      index += 1;\n      while (index < length && /[0-9]/.test(source[index])) {\n        index += 1;\n      }\n      if (source[index] === '.' && /[0-9]/.test(source[index + 1])) {\n        index += 2;\n        while (index < length && /[0-9]/.test(source[index])) {\n          index += 1;\n        }\n      }\n      push({ type: 'number', value: source.slice(start, index), start, end: index });\n      continue;\n    }\n\n    if (/[A-Za-z_]/.test(char) || (char === '-' && /[A-Za-z]/.test(source[index + 1]))) {\n      index += 1;\n      while (index < length && /[A-Za-z0-9_-]/.test(source[index])) {\n        index += 1;\n      }\n      const raw = source.slice(start, index);\n      const lower = raw.toLowerCase();\n      if (KEYWORDS.has(lower)) {\n        push({ type: 'keyword', value: raw, start, end: index });\n      } else {\n        push({ type: 'identifier', value: raw, start, end: index });\n      }\n      continue;\n    }\n\n    // fallback single character token\n    index += 1;\n    push({ type: 'unknown', value: char, start, end: index });\n  }\n\n  return tokens;\n}\n\nexport function normalizeHereString(node: HereStringNode): string {\n  const lines = node.value.split(/\\r?\\n/);\n  if (lines.length <= 2) {\n    return node.value;\n  }\n  return lines.slice(1, -1).join('\\n');\n}\n","import type { ParserOptions } from 'prettier';\n\nimport type {\n  ArrayLiteralNode,\n  BlankLineNode,\n  CommentNode,\n  ExpressionNode,\n  ExpressionPartNode,\n  FunctionDeclarationNode,\n  HashtableEntryNode,\n  HashtableNode,\n  HereStringNode,\n  ParenthesisNode,\n  PipelineNode,\n  ScriptBlockNode,\n  ScriptBodyNode,\n  ScriptNode,\n  TextNode,\n} from './ast.js';\nimport { resolveOptions } from './options.js';\nimport type { Token } from './tokenizer.js';\nimport { tokenize } from './tokenizer.js';\n\nclass Parser {\n  private index = 0;\n\n  constructor(\n    private readonly tokens: Token[],\n    private readonly source: string,\n  ) {}\n\n  parseScript(terminators: Set<string> = new Set()): ScriptNode {\n    const body: ScriptBodyNode[] = [];\n    const start = this.tokens.length > 0 ? this.tokens[0].start : 0;\n\n    while (!this.isEOF()) {\n      const token = this.peek();\n      if (!token) {\n        break;\n      }\n\n      if (terminators.has(token.value) && token.type === 'punctuation') {\n        break;\n      }\n\n      if (token.type === 'newline') {\n        const blank = this.consumeBlankLines();\n        if (blank) {\n          body.push(blank);\n        }\n        continue;\n      }\n\n      if (token.type === 'comment') {\n        const commentToken = this.advance();\n        body.push(this.createCommentNode(commentToken, false));\n        continue;\n      }\n\n      if (this.isFunctionDeclaration()) {\n        body.push(this.parseFunction());\n        continue;\n      }\n\n      const statement = this.parseStatement();\n      if (statement) {\n        body.push(statement);\n      } else {\n        // avoid infinite loops\n        this.advance();\n      }\n    }\n\n    const end = body.length > 0 ? body[body.length - 1].loc.end : start;\n    return {\n      type: 'Script',\n      body,\n      loc: { start, end },\n    } satisfies ScriptNode;\n  }\n\n  private parseFunction(): FunctionDeclarationNode {\n    const startToken = this.advance(); // function keyword\n    const headerTokens: Token[] = [startToken];\n\n    while (!this.isEOF()) {\n      const token = this.peek();\n      if (!token) {\n        break;\n      }\n      if (token.type === 'comment') {\n        break;\n      }\n      if (token.type === 'punctuation' && token.value === '{') {\n        break;\n      }\n      headerTokens.push(this.advance());\n    }\n\n    const headerExpression = buildExpressionFromTokens(headerTokens);\n    const body = this.parseScriptBlock();\n    const end = body.loc.end;\n\n    return {\n      type: 'FunctionDeclaration',\n      header: headerExpression,\n      body,\n      loc: { start: startToken.start, end },\n    } satisfies FunctionDeclarationNode;\n  }\n\n  private parseStatement(): PipelineNode | null {\n    const startToken = this.peek();\n    if (!startToken) {\n      return null;\n    }\n\n    const segments: Token[][] = [[]];\n    let trailingComment: CommentNode | undefined;\n\n    const structureStack: string[] = [];\n    let lineContinuation = false;\n\n    while (!this.isEOF()) {\n      const token = this.peek();\n      if (!token) {\n        break;\n      }\n\n      if (token.type === 'newline') {\n        if (lineContinuation) {\n          this.advance();\n          lineContinuation = false;\n          continue;\n        }\n        if (structureStack.length > 0) {\n          const newlineToken = this.advance();\n          segments[segments.length - 1].push(newlineToken);\n          continue;\n        }\n        if (structureStack.length === 0 && this.isPipelineContinuationAfterNewline()) {\n          this.advance();\n          continue;\n        }\n        break;\n      }\n\n      if (token.type === 'punctuation' && token.value === ';' && structureStack.length === 0) {\n        this.advance();\n        break;\n      }\n\n      if (token.type === 'punctuation' && token.value === '}' && structureStack.length === 0) {\n        break;\n      }\n\n      if (token.type === 'comment') {\n        trailingComment = this.createCommentNode(this.advance(), true);\n        break;\n      }\n\n      if (token.type === 'operator' && token.value === '|') {\n        this.advance();\n        segments.push([]);\n        lineContinuation = false;\n        continue;\n      }\n\n      if (token.type === 'unknown' && token.value === '`') {\n        this.advance();\n        lineContinuation = true;\n        continue;\n      }\n\n      const currentSegment = segments[segments.length - 1];\n      currentSegment.push(this.advance());\n      lineContinuation = false;\n\n      if (isOpeningToken(token)) {\n        structureStack.push(token.value);\n      } else if (isClosingToken(token)) {\n        structureStack.pop();\n      }\n    }\n\n    const filteredSegments = segments.filter((segment) => segment.length > 0);\n    if (filteredSegments.length === 0) {\n      return null;\n    }\n\n    const expressionSegments = filteredSegments.map((segmentTokens) =>\n      buildExpressionFromTokens(segmentTokens),\n    );\n    const end = expressionSegments[expressionSegments.length - 1].loc.end;\n\n    const pipelineNode: PipelineNode = {\n      type: 'Pipeline',\n      segments: expressionSegments,\n      loc: { start: startToken.start, end },\n    };\n\n    if (trailingComment) {\n      pipelineNode.trailingComment = trailingComment;\n    }\n\n    return pipelineNode;\n  }\n\n  private parseScriptBlock(): ScriptBlockNode {\n    const openToken = this.peek();\n    if (!openToken || openToken.type !== 'punctuation' || openToken.value !== '{') {\n      return {\n        type: 'ScriptBlock',\n        body: [],\n        loc: { start: openToken?.start ?? 0, end: openToken?.end ?? 0 },\n      } satisfies ScriptBlockNode;\n    }\n    this.advance();\n\n    const { contentTokens, closingToken } = this.collectBalancedTokens(openToken);\n    const nestedParser = new Parser(contentTokens, this.source);\n    const script = nestedParser.parseScript(new Set());\n    const end = closingToken?.end ?? openToken.end;\n\n    return {\n      type: 'ScriptBlock',\n      body: script.body,\n      loc: { start: openToken.start, end },\n    } satisfies ScriptBlockNode;\n  }\n\n  private collectBalancedTokens(startToken: Token): {\n    contentTokens: Token[];\n    closingToken?: Token;\n  } {\n    const contentTokens: Token[] = [];\n    const stack: string[] = [startToken.value];\n\n    while (!this.isEOF()) {\n      const token = this.advance();\n      if (!token) {\n        break;\n      }\n\n      if (isOpeningToken(token)) {\n        stack.push(token.value);\n        contentTokens.push(token);\n        continue;\n      }\n\n      if (isClosingToken(token)) {\n        if (stack.length <= 1) {\n          return { contentTokens, closingToken: token };\n        }\n        stack.pop();\n        contentTokens.push(token);\n        continue;\n      }\n\n      contentTokens.push(token);\n    }\n\n    return { contentTokens };\n  }\n\n  private consumeBlankLines(): BlankLineNode | null {\n    let count = 0;\n    const start = this.peek()?.start ?? 0;\n    let end = start;\n    while (!this.isEOF()) {\n      const token = this.peek();\n      if (!token || token.type !== 'newline') {\n        break;\n      }\n      const current = this.advance();\n      count += 1;\n      end = current.end;\n    }\n    if (count === 0) {\n      return null;\n    }\n    return {\n      type: 'BlankLine',\n      count,\n      loc: { start, end },\n    } satisfies BlankLineNode;\n  }\n\n  private createCommentNode(token: Token, inline: boolean): CommentNode {\n    return {\n      type: 'Comment',\n      value: token.value,\n      inline,\n      loc: { start: token.start, end: token.end },\n    } satisfies CommentNode;\n  }\n\n  private isPipelineContinuationAfterNewline(): boolean {\n    let offset = 1;\n    while (true) {\n      const next = this.peek(offset);\n      if (!next) {\n        return false;\n      }\n      if (next.type === 'newline') {\n        offset += 1;\n        continue;\n      }\n      if (next.type === 'comment') {\n        return false;\n      }\n      if (next.type === 'operator' && next.value === '|') {\n        return true;\n      }\n      return false;\n    }\n  }\n\n  private isFunctionDeclaration(): boolean {\n    const token = this.peek();\n    return Boolean(token && token.type === 'keyword' && token.value.toLowerCase() === 'function');\n  }\n\n  private peek(offset = 0): Token | undefined {\n    return this.tokens[this.index + offset];\n  }\n\n  private advance(): Token {\n    const token = this.tokens[this.index];\n    this.index += 1;\n    return token;\n  }\n\n  private isEOF(): boolean {\n    return this.index >= this.tokens.length;\n  }\n}\n\nfunction isOpeningToken(token: Token): boolean {\n  if (token.type === 'operator') {\n    return token.value === '@{' || token.value === '@(';\n  }\n  return (\n    token.type === 'punctuation' &&\n    (token.value === '{' || token.value === '(' || token.value === '[')\n  );\n}\n\nfunction isClosingToken(token: Token): boolean {\n  return (\n    token.type === 'punctuation' &&\n    (token.value === '}' || token.value === ')' || token.value === ']')\n  );\n}\n\nfunction buildExpressionFromTokens(tokens: Token[]): ExpressionNode {\n  const firstToken = tokens.find((token) => token.type !== 'newline');\n  const lastToken = [...tokens].reverse().find((token) => token.type !== 'newline');\n  if (!firstToken || !lastToken) {\n    return {\n      type: 'Expression',\n      parts: [],\n      loc: { start: tokens[0]?.start ?? 0, end: tokens[tokens.length - 1]?.end ?? 0 },\n    } satisfies ExpressionNode;\n  }\n\n  const parts: ExpressionPartNode[] = [];\n  let index = 0;\n\n  while (index < tokens.length) {\n    const token = tokens[index];\n\n    if (token.type === 'newline') {\n      index += 1;\n      continue;\n    }\n\n    if (token.type === 'operator' && token.value === '@{') {\n      const { node, nextIndex } = parseHashtablePart(tokens, index);\n      parts.push(node);\n      index = nextIndex;\n      continue;\n    }\n\n    if (\n      (token.type === 'operator' && token.value === '@(') ||\n      (token.type === 'punctuation' && token.value === '[')\n    ) {\n      const { node, nextIndex } = parseArrayPart(tokens, index);\n      parts.push(node);\n      index = nextIndex;\n      continue;\n    }\n\n    if (token.type === 'punctuation' && token.value === '{') {\n      const { node, nextIndex } = parseScriptBlockPart(tokens, index);\n      parts.push(node);\n      index = nextIndex;\n      continue;\n    }\n\n    if (token.type === 'punctuation' && token.value === '(') {\n      const { node, nextIndex } = parseParenthesisPart(tokens, index);\n      parts.push(node);\n      index = nextIndex;\n      continue;\n    }\n\n    if (token.type === 'heredoc') {\n      parts.push(createHereStringNode(token));\n      index += 1;\n      continue;\n    }\n\n    parts.push(createTextNode(token));\n    index += 1;\n  }\n\n  return {\n    type: 'Expression',\n    parts,\n    loc: {\n      start: firstToken.start,\n      end: lastToken.end,\n    },\n  } satisfies ExpressionNode;\n}\n\nfunction parseHashtablePart(\n  tokens: Token[],\n  startIndex: number,\n): { node: HashtableNode; nextIndex: number } {\n  const startToken = tokens[startIndex];\n  const { contentTokens, endIndex, closingToken } = collectStructureTokens(tokens, startIndex);\n  const entries = splitHashtableEntries(contentTokens).map((entryTokens) =>\n    buildHashtableEntry(entryTokens),\n  );\n  const end = closingToken?.end ?? contentTokens[contentTokens.length - 1]?.end ?? startToken.end;\n  return {\n    node: {\n      type: 'Hashtable',\n      entries,\n      loc: { start: startToken.start, end },\n    },\n    nextIndex: endIndex,\n  };\n}\n\nfunction parseArrayPart(\n  tokens: Token[],\n  startIndex: number,\n): { node: ArrayLiteralNode; nextIndex: number } {\n  const startToken = tokens[startIndex];\n  const { contentTokens, endIndex, closingToken } = collectStructureTokens(tokens, startIndex);\n  const elements = splitArrayElements(contentTokens).map((elementTokens) =>\n    buildExpressionFromTokens(elementTokens),\n  );\n  const kind = startToken.value === '@(' ? 'implicit' : 'explicit';\n  const end = closingToken?.end ?? contentTokens[contentTokens.length - 1]?.end ?? startToken.end;\n  return {\n    node: {\n      type: 'ArrayLiteral',\n      elements,\n      kind,\n      loc: { start: startToken.start, end },\n    },\n    nextIndex: endIndex,\n  } satisfies { node: ArrayLiteralNode; nextIndex: number };\n}\n\nfunction parseParenthesisPart(\n  tokens: Token[],\n  startIndex: number,\n): { node: ParenthesisNode; nextIndex: number } {\n  const startToken = tokens[startIndex];\n  const { contentTokens, endIndex, closingToken } = collectStructureTokens(tokens, startIndex);\n  const elements = splitArrayElements(contentTokens).map((elementTokens) =>\n    buildExpressionFromTokens(elementTokens),\n  );\n  const hasComma = hasTopLevelComma(contentTokens);\n  const hasNewline = contentTokens.some((token) => token.type === 'newline');\n  const end = closingToken?.end ?? contentTokens[contentTokens.length - 1]?.end ?? startToken.end;\n  return {\n    node: {\n      type: 'Parenthesis',\n      elements,\n      hasComma,\n      hasNewline,\n      loc: { start: startToken.start, end },\n    },\n    nextIndex: endIndex,\n  };\n}\n\nfunction parseScriptBlockPart(\n  tokens: Token[],\n  startIndex: number,\n): { node: ScriptBlockNode; nextIndex: number } {\n  const startToken = tokens[startIndex];\n  const { contentTokens, endIndex, closingToken } = collectStructureTokens(tokens, startIndex);\n  const nestedParser = new Parser(contentTokens, '');\n  const script = nestedParser.parseScript();\n  const end = closingToken?.end ?? contentTokens[contentTokens.length - 1]?.end ?? startToken.end;\n  return {\n    node: {\n      type: 'ScriptBlock',\n      body: script.body,\n      loc: { start: startToken.start, end },\n    },\n    nextIndex: endIndex,\n  };\n}\n\nfunction createHereStringNode(token: Token): HereStringNode {\n  const quote = token.quote ?? 'double';\n  return {\n    type: 'HereString',\n    quote,\n    value: token.value,\n    loc: { start: token.start, end: token.end },\n  } satisfies HereStringNode;\n}\n\nfunction createTextNode(token: Token): TextNode {\n  const role =\n    token.type === 'identifier'\n      ? 'word'\n      : token.type === 'keyword'\n        ? 'keyword'\n        : token.type === 'number'\n          ? 'number'\n          : token.type === 'variable'\n            ? 'variable'\n            : token.type === 'string'\n              ? 'string'\n              : token.type === 'operator'\n                ? 'operator'\n                : token.type === 'punctuation'\n                  ? 'punctuation'\n                  : 'unknown';\n\n  return {\n    type: 'Text',\n    value: token.value,\n    role,\n    loc: { start: token.start, end: token.end },\n  } satisfies TextNode;\n}\n\nfunction collectStructureTokens(\n  tokens: Token[],\n  startIndex: number,\n): { contentTokens: Token[]; endIndex: number; closingToken?: Token } {\n  const contentTokens: Token[] = [];\n  const stack: string[] = [tokens[startIndex].value];\n  let index = startIndex + 1;\n\n  while (index < tokens.length) {\n    const token = tokens[index];\n\n    if (isOpeningToken(token)) {\n      stack.push(token.value);\n      contentTokens.push(token);\n      index += 1;\n      continue;\n    }\n\n    if (isClosingToken(token)) {\n      if (stack.length === 1) {\n        return { contentTokens, endIndex: index + 1, closingToken: token };\n      }\n      stack.pop();\n      contentTokens.push(token);\n      index += 1;\n      continue;\n    }\n\n    contentTokens.push(token);\n    index += 1;\n  }\n\n  return { contentTokens, endIndex: tokens.length };\n}\n\nfunction splitHashtableEntries(tokens: Token[]): Token[][] {\n  const entries: Token[][] = [];\n  let current: Token[] = [];\n  const stack: string[] = [];\n\n  for (const token of tokens) {\n    if (token.type === 'newline' && stack.length === 0) {\n      if (current.length > 0) {\n        entries.push(current);\n        current = [];\n      }\n      continue;\n    }\n\n    if (token.type === 'punctuation' && token.value === ';' && stack.length === 0) {\n      if (current.length > 0) {\n        entries.push(current);\n        current = [];\n      }\n      continue;\n    }\n\n    if (isOpeningToken(token)) {\n      stack.push(token.value);\n      current.push(token);\n      continue;\n    }\n\n    if (isClosingToken(token)) {\n      if (stack.length > 0) {\n        stack.pop();\n      }\n      current.push(token);\n      continue;\n    }\n\n    current.push(token);\n  }\n\n  if (current.length > 0) {\n    entries.push(current);\n  }\n\n  return entries;\n}\n\nfunction buildHashtableEntry(tokens: Token[]): HashtableEntryNode {\n  const equalsIndex = findTopLevelEquals(tokens);\n  const keyTokens = equalsIndex === -1 ? tokens : tokens.slice(0, equalsIndex);\n  const valueTokens = equalsIndex === -1 ? [] : tokens.slice(equalsIndex + 1);\n  const keyExpression = buildExpressionFromTokens(keyTokens);\n  const valueExpression =\n    valueTokens.length > 0 ? buildExpressionFromTokens(valueTokens) : buildExpressionFromTokens([]);\n  const key = extractKeyText(keyTokens);\n  const start = keyTokens[0]?.start ?? valueTokens[0]?.start ?? 0;\n  const end =\n    (valueTokens[valueTokens.length - 1] ?? keyTokens[keyTokens.length - 1])?.end ?? start;\n\n  return {\n    type: 'HashtableEntry',\n    key,\n    rawKey: keyExpression,\n    value: valueExpression,\n    loc: { start, end },\n  } satisfies HashtableEntryNode;\n}\n\nfunction findTopLevelEquals(tokens: Token[]): number {\n  const stack: string[] = [];\n  for (let index = 0; index < tokens.length; index += 1) {\n    const token = tokens[index];\n    if (isOpeningToken(token)) {\n      stack.push(token.value);\n      continue;\n    }\n    if (isClosingToken(token)) {\n      stack.pop();\n      continue;\n    }\n    if (stack.length === 0 && token.type === 'operator' && token.value === '=') {\n      return index;\n    }\n  }\n  return -1;\n}\n\nfunction extractKeyText(tokens: Token[]): string {\n  const text = tokens\n    .filter((token) => token.type !== 'newline')\n    .map((token) => token.value)\n    .join(' ')\n    .trim();\n  if (text.startsWith('\"') && text.endsWith('\"')) {\n    return text.slice(1, -1);\n  }\n  if (text.startsWith(\"'\") && text.endsWith(\"'\")) {\n    return text.slice(1, -1);\n  }\n  return text;\n}\n\nfunction splitArrayElements(tokens: Token[]): Token[][] {\n  const elements: Token[][] = [];\n  let current: Token[] = [];\n  const stack: string[] = [];\n\n  for (const token of tokens) {\n    if (token.type === 'newline' && stack.length === 0) {\n      if (current.length > 0) {\n        elements.push(current);\n        current = [];\n      }\n      continue;\n    }\n\n    if (token.type === 'punctuation' && token.value === ',' && stack.length === 0) {\n      elements.push(current);\n      current = [];\n      continue;\n    }\n\n    if (isOpeningToken(token)) {\n      stack.push(token.value);\n      current.push(token);\n      continue;\n    }\n\n    if (isClosingToken(token)) {\n      if (stack.length > 0) {\n        stack.pop();\n      }\n      current.push(token);\n      continue;\n    }\n\n    current.push(token);\n  }\n\n  if (current.length > 0) {\n    elements.push(current);\n  }\n\n  return elements;\n}\n\nfunction hasTopLevelComma(tokens: Token[]): boolean {\n  const stack: string[] = [];\n  for (const token of tokens) {\n    if (isOpeningToken(token)) {\n      stack.push(token.value);\n      continue;\n    }\n    if (isClosingToken(token)) {\n      if (stack.length > 0) {\n        stack.pop();\n      }\n      continue;\n    }\n    if (stack.length === 0 && token.type === 'punctuation' && token.value === ',') {\n      return true;\n    }\n  }\n  return false;\n}\n\nexport function parsePowerShell(source: string, options: ParserOptions): ScriptNode {\n  resolveOptions(options);\n  const tokens = tokenize(source);\n  const parser = new Parser(tokens, source);\n  return parser.parseScript();\n}\n\nexport const locStart = (node: { loc: { start: number } }): number => node.loc.start;\nexport const locEnd = (node: { loc: { end: number } }): number => node.loc.end;\n","import type { AstPath, Doc, ParserOptions, Printer } from 'prettier';\nimport { doc } from 'prettier';\n\nimport {\n  type ArrayLiteralNode,\n  type CommentNode,\n  type ExpressionNode,\n  type ExpressionPartNode,\n  type FunctionDeclarationNode,\n  type HashtableEntryNode,\n  type HashtableNode,\n  type HereStringNode,\n  type ParenthesisNode,\n  type PipelineNode,\n  type ScriptBlockNode,\n  type ScriptBodyNode,\n  type ScriptNode,\n  type TextNode,\n} from './ast.js';\nimport { resolveOptions, type ResolvedOptions } from './options.js';\n\nconst { group, indent, line, softline, hardline, join, ifBreak, lineSuffix, dedentToRoot, align } =\n  doc.builders;\n\nexport const powerShellPrinter: Printer<ScriptNode> = {\n  print(path: AstPath, options: ParserOptions) {\n    const node = path.getValue() as ScriptNode | ScriptBodyNode | ExpressionPartNode | undefined;\n    if (!node) {\n      return '';\n    }\n    const resolved = resolveOptions(options);\n    return printNode(node, resolved);\n  },\n};\n\nfunction printNode(\n  node: ScriptNode | ScriptBodyNode | ExpressionNode | ExpressionPartNode | HashtableEntryNode,\n  options: ResolvedOptions,\n): Doc {\n  switch (node.type) {\n    case 'Script':\n      return printScript(node, options);\n    case 'ScriptBlock':\n      return printScriptBlock(node, options);\n    case 'FunctionDeclaration':\n      return printFunction(node, options);\n    case 'Pipeline':\n      return printPipeline(node, options);\n    case 'Expression':\n      return printExpression(node, options);\n    case 'Text':\n      return printText(node, options);\n    case 'Comment':\n      return printComment(node);\n    case 'BlankLine':\n      return Array.from({ length: node.count }, () => hardline);\n    case 'ArrayLiteral':\n      return printArray(node, options);\n    case 'Hashtable':\n      return printHashtable(node, options);\n    case 'HashtableEntry':\n      return printHashtableEntry(node, options);\n    case 'HereString':\n      return printHereString(node);\n    case 'Parenthesis':\n      return printParenthesis(node, options);\n    default:\n      return '';\n  }\n}\n\nfunction concatDocs(docs: Doc[]): Doc {\n  if (docs.length === 0) {\n    return '';\n  }\n  let acc: Doc = docs[0];\n  for (let index = 1; index < docs.length; index += 1) {\n    acc = [acc, docs[index]] as Doc;\n  }\n  return acc;\n}\n\nfunction indentStatement(docToIndent: Doc, options: ResolvedOptions): Doc {\n  const indentUnit = options.indentStyle === 'tabs' ? '\\t' : ' '.repeat(options.indentSize);\n  return [indentUnit, align(indentUnit.length, docToIndent)] as Doc;\n}\n\nfunction printScript(node: ScriptNode, options: ResolvedOptions): Doc {\n  const bodyDoc = printStatementList(node.body, options, false);\n  if (!bodyDoc) {\n    return '';\n  }\n  return [bodyDoc, hardline];\n}\n\nfunction printStatementList(\n  body: ScriptBodyNode[],\n  options: ResolvedOptions,\n  indentStatements: boolean,\n): Doc {\n  const docs: Doc[] = [];\n  let previous: ScriptBodyNode | null = null;\n  let pendingBlankLines = 0;\n\n  for (const entry of body) {\n    if (entry.type === 'BlankLine') {\n      pendingBlankLines += entry.count;\n      continue;\n    }\n\n    if (previous) {\n      const blankLines = determineBlankLines(previous, entry, pendingBlankLines, options);\n      for (let index = 0; index < blankLines; index += 1) {\n        docs.push(hardline);\n      }\n    }\n\n    const printed = printNode(entry, options);\n    docs.push(indentStatements ? indentStatement(printed, options) : printed);\n    previous = entry;\n    pendingBlankLines = 0;\n  }\n\n  return concatDocs(docs);\n}\n\nfunction determineBlankLines(\n  previous: ScriptBodyNode,\n  current: ScriptBodyNode,\n  pendingBlankLines: number,\n  options: ResolvedOptions,\n): number {\n  let base = pendingBlankLines > 0 ? pendingBlankLines : 1;\n  const desiredFunctionSpacing = options.blankLinesBetweenFunctions + 1;\n\n  if (\n    (previous.type === 'FunctionDeclaration' && current.type === 'FunctionDeclaration') ||\n    (previous.type === 'FunctionDeclaration' && current.type !== 'BlankLine') ||\n    (current.type === 'FunctionDeclaration' && previous.type !== 'BlankLine')\n  ) {\n    base = Math.max(base, desiredFunctionSpacing);\n  }\n\n  if (options.blankLineAfterParam && isParamStatement(previous)) {\n    base = Math.max(base, 2);\n  }\n\n  return base;\n}\n\nfunction printScriptBlock(node: ScriptBlockNode, options: ResolvedOptions): Doc {\n  if (node.body.length === 0) {\n    return '{}';\n  }\n\n  const bodyDoc = printStatementList(node.body, options, true);\n  return group(['{', hardline, bodyDoc, hardline, '}']);\n}\n\nfunction printFunction(node: FunctionDeclarationNode, options: ResolvedOptions): Doc {\n  const headerDoc = printExpression(node.header, options);\n  const bodyDoc = printScriptBlock(node.body, options);\n  if (options.braceStyle === 'allman') {\n    return group([headerDoc, hardline, bodyDoc]);\n  }\n  return group([headerDoc, ' ', bodyDoc]);\n}\n\nfunction printPipeline(node: PipelineNode, options: ResolvedOptions): Doc {\n  const segmentDocs = node.segments.map((segment) => printExpression(segment, options));\n  if (segmentDocs.length === 0) {\n    return '';\n  }\n\n  let pipelineDoc: Doc = segmentDocs[0];\n\n  if (segmentDocs.length > 1) {\n    const restDocs = segmentDocs.slice(1).map((segmentDoc) => [line, ['| ', segmentDoc]]);\n    pipelineDoc = group([segmentDocs[0], indent(restDocs.flatMap((docItem) => docItem))]);\n  }\n\n  if (node.trailingComment) {\n    pipelineDoc = [pipelineDoc, lineSuffix([' #', node.trailingComment.value])];\n  }\n\n  return pipelineDoc;\n}\n\nfunction printExpression(node: ExpressionNode, options: ResolvedOptions): Doc {\n  const docs: Doc[] = [];\n  let previous: ExpressionPartNode | null = null;\n\n  for (const part of node.parts) {\n    if (shouldSkipPart(part)) {\n      continue;\n    }\n\n    if (part.type === 'Parenthesis' && isParamKeyword(previous)) {\n      docs.push(printParamParenthesis(part, options));\n      previous = part;\n      continue;\n    }\n\n    if (previous) {\n      const separator = gapBetween(previous, part);\n      if (separator) {\n        docs.push(separator);\n      }\n    }\n\n    docs.push(printNode(part, options));\n    previous = part;\n  }\n\n  return docs.length === 0 ? '' : group(docs);\n}\n\nfunction gapBetween(previous: ExpressionPartNode, current: ExpressionPartNode): Doc | null {\n  const prevSymbol = getSymbol(previous);\n  const currentSymbol = getSymbol(current);\n\n  if (current.type === 'Parenthesis') {\n    if (previous.type === 'Text' && previous.value.toLowerCase() === 'param') {\n      return null;\n    }\n    if (previous.type === 'Text' && previous.role === 'keyword') {\n      return ' ';\n    }\n    return ' ';\n  }\n\n  if (previous.type === 'Parenthesis') {\n    if (currentSymbol && NO_SPACE_BEFORE.has(currentSymbol)) {\n      return null;\n    }\n    return ' ';\n  }\n\n  if (!prevSymbol && !currentSymbol) {\n    return ' ';\n  }\n\n  if (!prevSymbol) {\n    if (currentSymbol && NO_SPACE_BEFORE.has(currentSymbol)) {\n      return null;\n    }\n    return ' ';\n  }\n\n  if (NO_SPACE_AFTER.has(prevSymbol)) {\n    return null;\n  }\n\n  if (currentSymbol && NO_SPACE_BEFORE.has(currentSymbol)) {\n    return null;\n  }\n\n  if (prevSymbol && currentSymbol && SYMBOL_NO_GAP.has(`${prevSymbol}:${currentSymbol}`)) {\n    return null;\n  }\n\n  if (prevSymbol === '=' || currentSymbol === '=') {\n    return ' ';\n  }\n\n  if (\n    current.type === 'ScriptBlock' ||\n    current.type === 'Hashtable' ||\n    current.type === 'ArrayLiteral'\n  ) {\n    if (prevSymbol && NO_SPACE_BEFORE_BLOCK.has(prevSymbol)) {\n      return null;\n    }\n    return ' ';\n  }\n\n  return ' ';\n}\n\nfunction isParamStatement(node: ScriptBodyNode | null): boolean {\n  if (!node || node.type !== 'Pipeline') {\n    return false;\n  }\n  if (node.segments.length === 0) {\n    return false;\n  }\n  const firstSegment = node.segments[0];\n  if (firstSegment.parts.length === 0) {\n    return false;\n  }\n  const firstPart = firstSegment.parts.find((part) => part.type === 'Text');\n  if (!firstPart || firstPart.type !== 'Text') {\n    return false;\n  }\n  return firstPart.value.toLowerCase() === 'param';\n}\n\nconst NO_SPACE_BEFORE = new Set([')', ']', '}', ',', ';', '.', '::']);\nconst NO_SPACE_AFTER = new Set(['(', '[', '{', '.']);\nconst NO_SPACE_BEFORE_BLOCK = new Set(['(', '{', '=']);\nconst SYMBOL_NO_GAP = new Set(['.:word', '::word', 'word:(', 'word:[']);\n\nfunction getSymbol(node: ExpressionPartNode | null): string | null {\n  if (!node) {\n    return null;\n  }\n  if (node.type === 'Text' && (node.role === 'punctuation' || node.role === 'operator')) {\n    return node.value;\n  }\n  if (node.type === 'Parenthesis') {\n    return '(';\n  }\n  return null;\n}\n\nfunction isParamKeyword(node: ExpressionPartNode | null): boolean {\n  return Boolean(node && node.type === 'Text' && node.value.toLowerCase() === 'param');\n}\n\nconst KEYWORD_CASE_TRANSFORMS: Record<string, (value: string) => string> = {\n  preserve: (value) => value,\n  lower: (value) => value.toLowerCase(),\n  upper: (value) => value.toUpperCase(),\n  pascal: (value) =>\n    value.length === 0 ? value : value[0].toUpperCase() + value.slice(1).toLowerCase(),\n};\n\nconst CMDLET_ALIAS_MAP: Record<string, string> = {\n  gi: 'Get-Item',\n  gci: 'Get-ChildItem',\n  ls: 'Get-ChildItem',\n  dir: 'Get-ChildItem',\n  ld: 'Get-ChildItem',\n  la: 'Get-ChildItem',\n  gcm: 'Get-Command',\n  gm: 'Get-Member',\n  gps: 'Get-Process',\n  ps: 'Get-Process',\n  gwmi: 'Get-WmiObject',\n  gsv: 'Get-Service',\n  cat: 'Get-Content',\n  gc: 'Get-Content',\n  echo: 'Write-Output',\n  write: 'Write-Output',\n  '%': 'ForEach-Object',\n  foreach: 'ForEach-Object',\n  '?': 'Where-Object',\n  where: 'Where-Object',\n};\n\nconst DISALLOWED_CMDLET_REWRITE = new Map([['write-host', 'Write-Output']]);\n\nfunction printText(node: TextNode, options: ResolvedOptions): Doc {\n  if (node.role === 'string') {\n    return normalizeStringLiteral(node.value, options);\n  }\n\n  let value = node.value;\n\n  if (node.role === 'keyword') {\n    const transform =\n      KEYWORD_CASE_TRANSFORMS[options.keywordCase] ?? KEYWORD_CASE_TRANSFORMS.preserve;\n    value = transform(value);\n  }\n\n  if (\n    options.rewriteAliases &&\n    (node.role === 'word' || node.role === 'operator' || node.role === 'unknown')\n  ) {\n    const aliasKey = value.toLowerCase();\n    if (Object.prototype.hasOwnProperty.call(CMDLET_ALIAS_MAP, aliasKey)) {\n      value = CMDLET_ALIAS_MAP[aliasKey]!;\n    }\n  }\n\n  if (node.role === 'word' && options.rewriteWriteHost) {\n    const replacement = DISALLOWED_CMDLET_REWRITE.get(value.toLowerCase());\n    if (replacement) {\n      value = replacement;\n    }\n  }\n\n  return value;\n}\n\nfunction printComment(node: CommentNode): Doc {\n  return ['#', node.value];\n}\n\nfunction printArray(node: ArrayLiteralNode, options: ResolvedOptions): Doc {\n  const open = node.kind === 'implicit' ? '@(' : '[';\n  const close = node.kind === 'implicit' ? ')' : ']';\n  if (node.elements.length === 0) {\n    return [open, close];\n  }\n  const groupId = Symbol('array');\n  const elementDocs = node.elements.map((element) => printExpression(element, options));\n  const shouldBreak = elementDocs.length > 1;\n  const separator: Doc = [',', line];\n  const trailing = trailingCommaDoc(options, groupId, elementDocs.length > 0, ',');\n\n  return group(\n    [\n      open,\n      indent([shouldBreak ? line : softline, join(separator, elementDocs)]),\n      trailing,\n      shouldBreak ? line : softline,\n      close,\n    ],\n    { id: groupId },\n  );\n}\n\nfunction printHashtable(node: HashtableNode, options: ResolvedOptions): Doc {\n  const entries = options.sortHashtableKeys\n    ? [...node.entries].sort((a, b) =>\n        a.key.localeCompare(b.key, undefined, { sensitivity: 'base' }),\n      )\n    : node.entries;\n\n  if (entries.length === 0) {\n    return '@{}';\n  }\n\n  const groupId = Symbol('hashtable');\n\n  const entryDocs = entries.map((entry, index) => {\n    const entryDoc = printHashtableEntry(entry, options);\n    const isLast = index === entries.length - 1;\n    const separator = isLast\n      ? trailingCommaDoc(options, groupId, true, ';')\n      : ifBreak('', ';', { groupId });\n    return [entryDoc, separator];\n  });\n\n  return group(['@{', indent([line, join(line, entryDocs)]), line, '}'], { id: groupId });\n}\n\nfunction printHashtableEntry(node: HashtableEntryNode, options: ResolvedOptions): Doc {\n  const keyDoc = printExpression(node.rawKey, options);\n  const valueDoc = printExpression(node.value, options);\n  return group([keyDoc, ' =', indent([line, valueDoc])]);\n}\n\nfunction printHereString(node: HereStringNode): Doc {\n  return dedentToRoot(node.value);\n}\n\nfunction printParamParenthesis(node: ParenthesisNode, options: ResolvedOptions): Doc {\n  if (node.elements.length === 0) {\n    return '()';\n  }\n\n  if (node.elements.length <= 1 && !node.hasNewline) {\n    return printParenthesis(node, options);\n  }\n\n  const groupId = Symbol('param');\n  const elementDocs = node.elements.map((element) => printExpression(element, options));\n  const separator: Doc = [',', hardline];\n\n  return group(['(', indent([hardline, join(separator, elementDocs)]), hardline, ')'], {\n    id: groupId,\n  });\n}\n\nfunction printParenthesis(node: ParenthesisNode, options: ResolvedOptions): Doc {\n  if (node.elements.length === 0) {\n    return '()';\n  }\n  const groupId = Symbol('parenthesis');\n  const elementDocs = node.elements.map((element) => printExpression(element, options));\n  if (elementDocs.length === 1 && !node.hasNewline) {\n    return group(['(', indent([softline, elementDocs[0]]), softline, ')'], { id: groupId });\n  }\n\n  const hasComma = node.hasComma;\n  const forceMultiline = node.hasNewline || (!node.hasComma && elementDocs.length > 1);\n  const separator: Doc = hasComma\n    ? [',', forceMultiline ? hardline : line]\n    : forceMultiline\n      ? hardline\n      : line;\n\n  return group(\n    [\n      '(',\n      indent([\n        forceMultiline ? hardline : hasComma ? line : softline,\n        join(separator, elementDocs),\n      ]),\n      forceMultiline ? hardline : hasComma ? line : softline,\n      ')',\n    ],\n    { id: groupId },\n  );\n}\n\nfunction trailingCommaDoc(\n  options: ResolvedOptions,\n  groupId: symbol,\n  hasElements: boolean,\n  delimiter: ',' | ';',\n): Doc {\n  if (!hasElements) {\n    return '';\n  }\n  switch (options.trailingComma) {\n    case 'all':\n      return delimiter;\n    case 'multiline':\n      return ifBreak(delimiter, '', { groupId });\n    case 'none':\n    default:\n      return '';\n  }\n}\n\nexport function createPrinter(): Printer<ScriptNode> {\n  return powerShellPrinter;\n}\n\nfunction normalizeStringLiteral(value: string, options: ResolvedOptions): string {\n  if (!options.preferSingleQuote) {\n    return value;\n  }\n\n  if (!value.startsWith('\"') || !value.endsWith('\"')) {\n    return value;\n  }\n\n  const inner = value.slice(1, -1);\n\n  if (inner.includes(\"'\")) {\n    return value;\n  }\n\n  if (/[`$\"\\n]/.test(inner)) {\n    return value;\n  }\n\n  return `'${inner}'`;\n}\n\nfunction shouldSkipPart(part: ExpressionPartNode): boolean {\n  if (part.type === 'Text') {\n    const trimmed = part.value.trim();\n    if (trimmed === '`') {\n      return true;\n    }\n  }\n  return false;\n}\n","import type { Plugin, SupportLanguage } from 'prettier';\n\nimport { pluginOptions, defaultOptions } from './options.js';\nimport { parsePowerShell, locEnd, locStart } from './parser.js';\nimport { powerShellPrinter } from './printer.js';\n\nconst languages: SupportLanguage[] = [\n  {\n    name: 'PowerShell',\n    parsers: ['powershell'],\n    extensions: ['.ps1', '.psm1', '.psd1'],\n    tmScope: 'source.powershell',\n    aceMode: 'powershell',\n    linguistLanguageId: 131,\n    vscodeLanguageIds: ['powershell'],\n  },\n] as const;\n\nconst parsers: Plugin['parsers'] = {\n  powershell: {\n    parse: parsePowerShell,\n    astFormat: 'powershell-ast',\n    locStart,\n    locEnd,\n    hasPragma() {\n      return false;\n    },\n  },\n} as const;\n\nconst printers: Plugin['printers'] = {\n  'powershell-ast': powerShellPrinter,\n};\n\nconst plugin: Plugin = {\n  languages,\n  parsers,\n  printers,\n  options: pluginOptions,\n  defaultOptions,\n};\n\nexport default plugin;\n"]}